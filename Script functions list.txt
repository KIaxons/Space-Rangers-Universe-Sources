Специальные отладочные чит-коды:
SEED - вводится на этапе настроек перед запуском новой игры (должны быть включены "тонкие настройки"), позволяет передать игре зерно рандомизатора для генерации Галактики, то есть, по сути, в точности повторить определённую зерном генерацию;
SUDO - код для вызова консоли разработчика, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
EVENTS - код для вывода в лог всех текущих Галактических событий, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
INFOS - код для вывода в лог подробной информации обо всех инфошках на всех кораблях Галактики;
ZAWARUDO - код для "заморозки времени" (полностью останавливает расчёт ходов), однако при перелётах между системами может отрабатывать некорректно;

Особые игровые параметры для кастомных артефактов:
NoWear - полностью отключает износ у указанного кастомного артефакта, делает его неломаемым, а также меняет тип такого предмета с t_Artefact на t_Artefact2:
	1 - данный артефакт становится неломаемым;
CountsAs - заставляет ботов считать данный кастомный арт одним из оригинальных, что позволяет им использовать его автоматически:
	1 - системное название оригинального артефакта, пример: CountsAs=ArtMiniExpl
SharedUse - при указании этого тэга вместе с CountsAs, игра будет считать данный артефакт аналогом оригинала и не позволит установить его в слот, если на кораблей уже и так установлен оригинальный арт или любой другой арт с таким тэгом:
	1 - считать данный артефакт аналогом оригинала при установке в слот;
SharedEffect - при указании этого тэга вместе с CountsAs, игра превратит данный кастомный артефакт в полный аналог оригинального, включая полное повторение всех его активных и пассивных эффектов (но для блокировки слота указать SharedUse всё равно надо). Данный тэг может быть полезен, если вы хотите изменить работу оригинального арта, но вам также нужны переменные под запись данных в артефакт (CustomArtData), которых у оригинальных артов попросту нет:
	1 - данный артефакт будет иметь тот же эффект, что и оригинальный;

Полезные параметры для графических (и прочих) элементов в Main:
PosAutoCorrection - включает/выключает автокоррекцию позиции конкретного элемента для всех игровых разрешений: True - включить, False - выключить;
PosAutoCorrectionXCoef - коэффициент корректировки позиции по оси X, принимает дробные значения, в обычной ситуации от 0.0 (самая левая часть экрана) до 1.0 (самая правая часть экрана), хотя возможны и отрицательные значения;
PosAutoCorrectionYCoef - коэффициент корректировки позиции по оси Y, принимает дробные значения, в обычной ситуации от 0.0 (самая верхняя часть экрана) до 1.0 (самая нижняя часть экрана), хотя возможны и отрицательные значения;
  Примечание: Сперва настройте желаемую позицию элемента в разрешении 1024x768, а затем "подровняйте" его с помощью PosAutoCorrection на любом другом разрешении до желаемого результата (наиболее часто подходящие значения 0.5 и 1.0). В итоге вы получите полную адаптацию позиции элемента под любые разрешения.
TextColor - устанавливает цвет текста (в формате RGB) для элементов типа Label, пример: TextColor=0,27,50
TextShadow - включает и устанавливает сдвиг тени текста в пикселях для элементов типа Label, пример: TextShadow=1 (тень будет иметь сдвиг в один пиксель вниз и вправо)
TextShadowColor - устанавливает цвет тени (в формате RGB) для текста в элементах типа Label, пример: TextShadowColor=8,136,181
ImageFirst - параметр для объекта типа GAI, в котором указывается опорный кадр в случае, если прикреплённой анимации он необходим;
SoundStart - параметр для объекта типа GAI, проигрывает указанный звук при начале воспроизведения прикреплённой анимации, пример: SoundStart=Sound.Sell
Radius - параметр для звезды, задаёт радиус области в центре системы, в которой будет выводиться информация о звезде при наведении курсора;
SafeRadius - параметр для звезды, задаёт безопасный радиус облёта звезды, в зависимости от которого корабли будут выбирать свою траекторию;
DamageRadius - параметр для звезды, задаёт радиус, в пределах которого кораблям будет наноситься урон от звезды;
DrawLines - параметр для раздела 'Data.StyleConstellation' в Main.dat. Включает и отключает отрисовку линий между группами звёзд на галакарте:
	Yes - включить отрисовку линий созвездий;
	No - выключить отрисовку линий созвездий;
LinesColor - параметр для раздела 'Data.StyleConstellation' в Main.dat. Меняет цвет линий между группами звёзд на галакарте и имеет нестандартную форму записи формата RGB, где каждый цвет задаётся не байтовой переменной (0 - 255), а через float от 0.0 до 1.0 (пример, LinesColor=1.0,1.0,0.0);
WeaponPort1 - параметр для анимации корабля. Устанавливает точку на анимации, из которой будут отрисовываться выстрелы орудий. Всего можно добавить до 10 таких точек (WeaponPort1, WeaponPort2, WeaponPort3 и т.д.). Номер точки, из которой будет произведён следующий выстрел, определяется случайным образом.
  Примечание: Установка орудийных портов работает как для hai, так и для gai анимаций на станциях, но в случае с gai анимациями нулевой точкой отсчёта всегда будет являться центр.
Tail1 - устанавливает точку на анимации, из которой будет отрисован динамический след двигателя корабля. Всего можно установить до 10 таких точек (Tail1, Tail2, Tail3 и т.д.).
  Примечание: Параметры WeaponPort и Tail принимают координаты точки (пикселя) на анимации в формате 'Tail=X,Y'.
SizeSmall - параметр условно минимального визуального размера для данной hai анимации (корабля) в игре;
SizeLarge - параметр условно максимального визуального размера для данной hai анимации (корабля) в игре;
	Базовые значения параметров SizeSmall и SizeLarge для различных видов игровых корпусов:
	  Коалиция и пираты:
	    Рейнджер: 50 / 80
		Транспорт: 50 / 90
		Лайнер: 50 / 90
		Дипломат: 50 / 90
		Пират: 45 / 80
		Пират фэянин: 55 / 90 (связано с качеством его hai анимации)
		Военный: 45 / 80
		Военный фэянин: 55 / 80 (связано хз с чем)
		Военный флагман: 80 / 130
		Транклюкатор: 40 / 50
		Акриновый корпус (любой): 50 / 80
		Станция: 128 / 128 (все станции по умолчанию используют собственные gai анимации, так что это значение, хотя формально и применяется, не особо неактуально)
		По умолчанию для всего остального: 50 / 80
	  Доминаторы:
	    Клиг: 40 / 60
	    Штип: 40 / 60
	    Менок: 45 / 65
	    Смерш: 60 / 90
	    Ургант: 70 / 100
	    Эквентор: 110 / 127
	    Бертор: 130 / 160
		Босс: 127 / 127 (не используются в игре, т.к. все боссы имеют gai анимации)
	Примечание: При слишком малом или слишком большом размере корпуса возможен выход за указанные диапазоны, условные границы размеров, которые точно соответствуют значениям SizeSmall и SizeLarge по умолчанию это 250 ед. и 2000 ед. соответственно.


Прочие полезные фичи:
  Дополнительные параметры для палитр выстрелов орудий:
	  ShotVisual - параметр для акрина в Lang.dat, устанавливает номер палитры (палитра берется из общего списка палитр для оружия данного типа) для оружия, на которое будет наложен данный акрин:
	     1 - номер палитры, которую будет устанавливать данный акрин;
    Общие:
	  SoundShot - звук выстрела, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше (можно устанавливать отдельно в каждую палитру, а не только в общий раздел с ними);
	  SoundExpl - звук разрыва ракеты/торпеды, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше (можно устанавливать отдельно в каждую палитру, а не только в общий раздел с ними);
	Промышленный лазер:
	  Width - определяет ширину рисуемого луча (по умолчанию 2, тип int);
	  Time - определяет "время жизни" рисуемого луча (по умолчанию 40, тип int);
  Название атрибута для добавления серий корпуса флагманам:
    Flagman - подставляется в раздел конкретной серии в параметр ShipType (не включён в список атрибута Any);
  Дополнительные параметры Main.dat для ракет (раздел 'ML.Missile'):
	Scale - определяет визуальный размер анимации ракеты/торпеды, по умолчанию для всех ракет задан на 1.0;

Различные игровые параметры для бонусов (параметры добавляется в раздел бонуса в Lang, пример: Special=1):
Special - означает, что текущий бонус является акрином (или, по крайней мере, особым ММ), чтобы он не выпадал в списках выдачи ММ на ЦР:
	1 - бонус является акрином или особым ММ;
Color - параметр для указания цвета имени бонуса (ММ или акрина). В отличие от прямого подставления цветовых тэгов в параметр Name, Color полностью меняет имя бонуса во всех подстановках, в т.ч. цвет кавычек ММ после его установки в предмет, пример: Color=41,125,222 (цвета указываются в формате RGB);
Equipments - для акринов обозначает, к какому типу предметов игра будет автоматически применять данный акрин в магазинах, а для ММ, в предметы какого типа может быть установлен данный микромодуль:
	'Any' - аналогичен параметру "по умолчанию" (если Equipments в бонусе не указан) и включает в себя любые типы оборудования и оружия;
	   Важно: Если данное значение не занимает всю строку (к примеру записано Equipments=Any,Hull), то в качестве валидного показателя оно засчитано не будет и все необходимые типы предметов придётся указывать вручную.
	'Hull' - бонус может быть применён к любому корпусу;
	'Engine' - бонус может быть применён к любому двигателю;
	'FuelTank' - бонус может быть применён к любому топливному баку;
	'Radar' - бонус может быть применён к любому радару;
	'Scaner' - бонус может быть применён к любому сканеру;
	'Droid' - бонус может быть применён к любому дроиду;
	'Hook' - бонус может быть применён к любому захвату;
	'DefGenerator' - бонус может быть применён к любому ГЗП;
	'WEnergy' - бонус может быть применён к любому энергетическому оружию;
	'WSplinter' - бонус может быть применён к любому осколочному оружию;
	'WMissile' - бонус может быть применён к любому ракетному оружию;
	'W01' - бонус может быть применён к промышленному лазеру;
	'W02' - бонус может быть применён к осколочному орудию;
	'W03' - бонус может быть применён к лезке;
	'W04' - бонус может быть применён к ракетомету;
	'W05' - бонус может быть применён к третону;
	'W06' - бонус может быть применён к волновому фазеру;
	'W07' - бонус может быть применён к потоковому бластеру;
	'W08' - бонус может быть применён к электронному резаку;
	'W09' - бонус может быть применён к мультирезонатору;
	'W10' - бонус может быть применён к атомному визиону;
	'W11' - бонус может быть применён к дезинтегратору;
	'W12' - бонус может быть применён к турбогравиру;
	'W13' - бонус может быть применён к ИМХО-9000;
	'W14' - бонус может быть применён к вертиксу;
	'W15' - бонус может быть применён к торпедному аппарату;
	'W16' - бонус может быть применён к эсодаферу;
	'W17' - бонус может быть применён к кафаситору;
	'W18' - бонус может быть применён к лирекрону;
	'Имя типа кастомного оружия' - бонус может быть применён к указанному кастомному оружию;
Owner - для акринов обозначает, к каким расам игра будет автоматически применять данный акрин в магазинах (актуально только для коалиционных рас и пиратов), а для ММ, в предметы с какой расой может быть установлен данный микромодуль:
	'Any' - аналогичен параметру "по умолчанию" (если Owner в бонусе не указан) и включает в себя все расы, кроме неизвестной;
	  Важно: Если данное значение не занимает всю строку (к примеру записано Owner=Any,None), то в качестве валидного показателя оно засчитано не будет и все необходимые расы придётся указывать вручную.
	'Maloc' - добавляет в набор малокскую и доминаторскую расу;
	'Peleng' - добавляет в набор пеленгскую и доминаторскую расу;
	'People' - добавляет в набор человеческую и доминаторскую расу;
	'Fei' - добавляет в набор фэянскую и доминаторскую расу;
	'Gaal' - добавляет в набор гаальскую и доминаторскую расу;
	'PirateClan' - добавляет в набор пиратскую и доминаторскую расу;
	'None' - добавляет в набор неизвестную и доминаторскую расу;
	'Blazer' - ограничивает применение бонусов к доминаторскому оборудованию только блазероидной серией;
	'Keller' - ограничивает применение бонусов к доминаторскому оборудованию только келлероидной серией;
	'Terron' - ограничивает применение бонусов к доминаторскому оборудованию только терроноидной серией;
	   Примечание: Ограничительные указатели серий допустимо комбинировать, например как 'Owner=Maloc,Blazer,Terron'.
	'NonKling' - особый указатель, запрещающий установку данного бонуса в любое доминаторское оборудование (как автоматическими скриптовыми функциями, так и вручную игроком);
  Важно: Как бы вы не составляли набор, если в нём отсутствует указатель 'NonKling', доминаторская раса будет неизбежно присутствовать в его составе! Например, строка 'Owner=Maloc' или 'Owner=None' будет фактически расценена игрой как 'Owner=Maloc,Kling' и 'Owner=None,Kling' соответственно. Ограничить же применение бонуса только к доминаторскому оборудованию можно, добавив параметр 'Owner=ewfksdf', где само значение невалидного указателя значения не имеет (с тем же успехом можно писать и 'Owner=Kling'). Если же составить параметр как 'Owner=NonKling', то такой бонус будет запрещён к установке вообще везде.
  Примечание: Строка 'Kling' валидным параметром не является и не проверяется игрой. Вместо неё можно вписывать любой набор букв с точно таким же результатом.
RacialRestriction - блокирует применение бонусов данного ММ/акрина на представителей иных рас, кроме тех, что указаны в параметре Owner этого же бонуса (использовать такие предметы смогут любые расы, но вот получать от них бонусы будут не все):
	1 - разрешить применение данных бонусов только для представителей определённых рас;
BlockMM - запрещает устанавливать микромодуль в предмет с данным акрином (только основным акрином, из спецакрина данный запрет работать не будет):
	1 - установка микромодуля в данное оборудования/корпус запрещена;
BlockImp - запрещает улучшать оборудование/корпус с данным акрином (в том числе в модах EvoSB и ExpTC, из спецакрина этот запрет работать не будет):
	1 - улучшение оборудования/корпуса запрещено;
NamePrefix - параметр только для микромодулей, подменяет имя базовой приставки 'Микромодуль' на любое другое, указанное в строке:
	1 - новое имя приставки;
HullGraphSize - параметр для акрина корпуса в Lang, который меняет визуальный размер этого корпуса (стандартный размер 100, размер флагмана 200);
Fragility - меняет модификатор износа предмета, но имеет обратную зависимость. Fragility=70 (100/70) будет означать замедление скорости износа (предмет получит прочность в 142% от исходной), а Fragility=120 (100/120) - ускорение скорости износа (83% прочности от исходной). При установке бонуса с Fragility в корпус, будет меняться его восприимчивость к урону;
FragilityEnergy - бонус/штраф к восприимчивости к энергетическому урону (только для корпуса);
FragilityMissile - бонус/штраф к восприимчивости к осколочному урону (только для корпуса);
FragilitySplinter - бонус/штраф к восприимчивости к ракетному урону (только для корпуса);
  Примечание: Специализированные Fragility по типам урона записываются в бонус аналогично общему. Если в бонусе для корпуса прописан общий Fragility, то он будет применён сразу на все три типа восприимчивости к урону корпуса. Если в бонусе прописан только специализированный(е) Fragility, то он будет применён только для соответствующего типа сопротивляемости. Если же в бонусе прописан и общий и специализированный Fragility, то для типов урона без указанного специализированного Fragility будет применён общий, а для тех, для которых специализированный указан, специализированный Fragility.
WeaponMods - параметр для добавления дополнительных эффектов в дамагсет оружия через бонусы (ММ или акрины), накладываемые на это орудие (добавлять в виде строки, через запятые и без пробелов):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели;
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм, эффект Третона);
  'Shock' (64) - вешает на цель эффект ионизации;
  'Acid' (128) - ослабляет броню цели;
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели, эффект Лирекрона);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);
Примечание: Замедления 'Decelerate', 'DecelerateA' и 'DecelerateAEx' полностью идентичны друг другу, однако при совместном использовании кратно увеличивают замедляющий эффект. К примеру, Вжик в режиме совместимости использует одновременно 'DecelerateA' и 'DecelerateAEx', что увеличивает его замедляющий эффект ровно в два раза.
  'Undefendable' (2048) - применяет к цели урон, считающийся отражённым Поляризатором (наносимый урон игнорирует броню и ГЗП);
  'NonLethal' (4096) - применяет эффект, как от непосредственного воздействия ионизации (наносит урон корпусу, но полностью уничтожить корабль не может)
  'ScanBonus' (8192) - повышает урон оружия на 15% (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BonusToDamaged' (16384) - повышает урон по повреждённой цели вплоть до 33% (если у цели остался 1 HP) в зависимости от степени повреждения цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
    Примечание: kdamage := kdamage * (1 + 0.33 * (1 - FHull.FHitPoints / FHull.FSize));
  'MoreDrop' (32768) - повышает шанс дропа оборудования при уничтожении цели, аналогично ЛВВ (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'DropCargo' (65536) - добавляет 5% шанс дропа товара из трюма при нанесении урона цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'ReduceEngine' (131072) - наносит повреждения двигателю цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockWeapon' (262144) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки оружия цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockDroid' (524288) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки дроида цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
    Примечание: Обратите внимание, что если вы вешаете данные эффекты с требованиями к сканеру на урон наносимый из функции (например, DealDamageToShip), то при отсутствии конкретного корабля/станции наносящего урон, условие к сканеру и радиусу радара также выполнено не будет, а, следовательно, эффект на цель не подействует.
  'NoDelta' (1048576) - отключает разброс урона (оружие с данным эффектом всегда наносит максимальный урон, эффект Эсодафера);

Кастомные параметры для бонусов:
UniqueMM - параметр, обозначающий, что данный бонус является микромодулем, хотя и имеет тэг Special, необходим исключительно для маркировки уникальных микромодулей:
	1 - данный бонус является уникальным микромодулем и может быть получен лишь один раз за всю партию;
	2 - данный бонус является особым микромодулем, но может быть получен неограниченное количество раз за партию (полезно для маркировки особых ММ, которые не должны попадать в стандартную выдачу ЦР);
LockedAcryn - запрещает накладывать/снимать бонус с оборудования в моде ExpScienceRanks:
	1 - запрещено снимать;
	2 - запрещено накладывать;
	3 - запрещено накладывать и снимать;
ScriptItemIgnore - параметр, снимающий ограничение на извлечение ММ и улучшение (в модах EvoSB и ExpTC) скриптового предмета. По умолчанию из скриптовых предметов нельзя вынимать ММ / улучшать их, дабы исключить возможность их утери, но данный параметр такое ограничение снимает (в теории можно использовать и для других аналогичных проверок, подразумевающих возможную утерю/изменение предмета):
	1 - данный скриптовый предмет может быть безбоязненно уничтожен/изменён скриптом;
BMSpawnCondition - параметр только для микромодулей, задаёт условие, при котором данный ММ сможет появиться в магазине ЧР, если задать как BMSpawnCondition=0, то данный ММ на ЧР появляться не будет (для мода ExpBlackMarket):
	1 - обязательное условие для появления данного ММ в магазине ЧР (по умолчанию в магазине ЧР может появиться любой ММ в любое время);
NotRemovable - параметр только для микромодулей, запрещает извлечение ММ в моде EvoSB:
	1 - данный микромодуль невозможно извлечь (с помощью этого тэга можно создавать модули-затычки);
NonSearchable - блокирует занесение этого бонуса в список доступных для автопоиска в моде ExpAutoSearch:
	1 - бонус не будет отображаться в списке поиска (имеет смысл блокировать особые акрины, которые в любом случае никак не могут попасть в магазин);
	2 - акрин, имитирующий отсутствие акрина (предмет с ним будет считаться модом ExpAutoSearch как предмет без акрина вовсе);
NonRepairable - блокирует возможность ремонта оборудования/корпуса с данным бонусом на всех базах в моде ExpRepair:
	1 - ремонт запрещён;
NoBridge - параметр только для акринов на корпуса, запрещает добавлять на корпус с данным акрином мостик из мода ExpPilotBridge:
	1 - мостик на корпус с данным акрином добавляться не будет;
BioEquip - параметр, помечающий данное оборудование как биологическое (например, биогенные дроиды), что полезно для блокировки некоторых бонусов:
	1 - оборудование является биологическим объектом;
AcrynSerie - имя, подходящее сразу всей линейке оборудования, имеющего акрины нескольких уровней (I, II, III и т.д.) При установке данного параметра, оборудование будет считаться многоуровневым, что желательно для нормальной работы мода ExpScienceRanks;
SerieLevelN - где N означает номер уровня данного акрина (в разделе бонуса указывать как SerieLevel1, SerieLevel2 и т.д.) SerieLevelN напрямую связан с параметром AcrynSerie. В этом параметре должно быть указано имя раздела Lang, в котором записывается данный бонус.
  Пример: SerieLevel1=374 - соответствует бонусу "Миоплазменный двигатель I";
AcrynLevel - указатель на конкретный уровень акрина в его серии;
LevelsCount - число, обозначающее общее количество уровней данного акрина (2, 3, 4 и т.д.) Все три последних параметра требуются для нормальной работы механики акринации в моде ExpScienceRanks;
  Примечание: Параметр добавляется в общий раздел бонуса, пример: LockedAcryn=3
ForNPCTypes - параметр для индикации типов NPC, которым подходит акриновый корпус с данным параметром (используется в моде ShuRangersAcryns), пример: ForNPCTypes=Ranger,RangerExplorer,RangerPirateExplorer (обозначает акрин для всех стандартных типов рейнджеров);
ForCharacterTypes - параметр для обозначения, каким типам характеров рейнджеров NPC подходит данный корпус (имеет смысл использовать только в связке с ForNPCTypes):
	'Warrior' - корпус подходит для рейнджеров воинов;
	'Trader' - корпус подходит для рейнджеров торговцев;
	'Pirate' - корпус подходит для рейнджеров ренегатов;
  Примечание: Допустимо указывать сразу несколько типов. По умолчанию (при отсутствии параметра) будет считаться, что корпус подходит сразу для всех типов.
ImitatedHullType - тэг для акринов на корпуса, отмечающий, какой оригинальный тип корпуса имитирует данный акрин (если нужна имитация), что имеет значение в запросах автопоиска из мода ExpAutoSearch (можно указать сразу несколько подходящих типов через запятую без пробелов):
	'Ranger' - корпус рейнджера;
	'Warrior' - корпус военного;
	'Pirate' - корпус пирата;
	'Transport' - корпус транспорта;
	'Liner' - корпус лайнера;
	'Diplomat' - корпус дипломата;
	'Flagman' - корпус флагмана;
ImitatedEquipType - параметр, необходимый для подмены предмета в момент его деакринации в моде ExpScienceRanks, а также для изменения вывода поиска в моде ExpAutoSearch. Позволяет указать тип необходимого оружия/оборудования на которое должен быть заменён деакринируемый предмет:
	1 - тип оборудования/оружия строкой вида t_Engine, t_Weapon4 и т.д.;
ActualEquipType - параметр, необходимый для подмены предмета в момент его акринации в моде ExpScienceRanks, а также для изменения вывода поиска в моде ExpAutoSearch (обязательно должен быть поставлен в пару к ImitatedEquipType). Позволяет указать тип необходимого оружия/оборудования на которое должен быть заменён акринируемый предмет:
	1 - тип оборудования/оружия строкой вида t_Engine, t_Weapon4 и т.д.;
  Примечание: Для кастомного оружия типа t_CustomWeapon необходимо через запятую указать имя конкретного типа, пример: ActualEquipType=t_CustomWeapon,MissileLauncherTorpedo


Кастомные функции из мода UtilityFunctionsPack (для использования их в своём скрипте, нужно сперва подключить библиотеку к конкретному скрипту через Main, а для использования в интерфейсном, Act или Use коде, необходимо использовать функцию ImportAll, либо ImportedFunction):
ParsCountFromString - считает и возвращает общее число параметров в строке через указанные разделители (если строка пуста, вернёт 0):
	1 - строка;
	2 - разделитель;
  Пример: Запрос ParsCountFromString('A --B --C ', '--') вернёт 3, а запрос ParsCountFromString('A', '--') вернёт 1.
GetParFromString - разбивает строку через разделители и возвращает отрезок под указанным номером (при выходе номера за диапазон вернёт ''):
	1 - строка;
	2 - разделитель;
	3 - номер отрезка, который необходимо вернуть, начиная с 0;
	4 - маркер очистки пробелов и табуляций в возвращаемой строке:
	   0 - не убирать пробелы и табуляции;
	   1 - убирать пробелы и табуляции только в начале и в конце строки;
	   2 - убирать пробелы и табуляции из всей строки (в т.ч. из середины);
  Пример: Запрос GetParFromString('A --B --C ', '--', 1, 1) вернёт 'B'. При передаче отрицательного номера параметра, минус автоматически отбрасывается.
SetParFromString - меняет параметр в строке с разделителями и возвращает пересобранную строку:
	1 - строка;
	2 - разделитель;
	3 - номер отрезка, который необходимо заменить, начиная с 0;
	4 - новое значение параметра (отрезок);
  Пример: Запрос SetParFromString('A,B,C', ',', 1, 'D') вернёт 'A,D,C'. Если номер отрезка больше общего количества параметров в строке, то переданный параметр будет добавлен в конец. Если в строке вовсе отсутствуют указанные разделители, то переданный параметр будет добавлен в начало (если указан номер 0), либо в конец (если указано что-то кроме 0) строки.
TrimNumbers - удаляет все числовые символы из строки:
	1 - строка;
RoundTo - округляет любое указанное число к любому другому указанному числу (включая дробные):
	1 - округляемое число;
	2 - к какому числу округлять;
	3 - как именно выполнить округление:
	  -1 - к меньшему;
	   0 - обычное округление (не банковское);
	   1 - к большему;
	   2 - банковское округление;
	   3 - к ближайшему нечётному при среднем значении (короче как банковское, но наоборот);
Exponent - возводит число X в степень Y (допускаются дробные):
	1 - число X;
	2 - число Y;
DistCoords - считает и возвращает расстояние между двумя точками по их координатам:
	1 - координата X первой точки;
	2 - координата Y первой точки;
	3 - координата X второй точки;
	4 - координата Y второй точки;
PortionInDiapason - переводит указанное значение из одного диапазона в другой:
	1 - текущее значение (число);
	2 - начало диапазона, в котором находится текущее значение;
	3 - конец диапазона, в котором находится текущее значение;
	4 - начало диапазона, в который нужно перевести значение;
	5 - конец диапазона, в который нужно перевести значение;
  Пример: PortionInDiapason(3, 1, 10, 1, 20); переведёт 3 из диапазона 1-10 в диапазон 1-20 и в итоге вернёт нам 6. А в случае, если текущее значение выйдет за рамки первого диапазона (например, равно 11), вернёт максимальную или минимальную величину второго диапазона (то есть 20, если текущее значение равно 11).
CustomArtCostCalc - функция для определения случайной стоимости кастомного артефакта по заданной формуле с учётом текущей сложности и ГТУ:
	1 - базовое значение (рекомендуемый диапазон от 1000 (очень дешёвый арт) до 3000 (очень дорогой арт));
	2 - уровень сложности настройки разброса цен, GalaxyDiffLevels(1);
	3 - галактический ТУ, GalaxyTechLevel();
CustomArtSizeCalc - функция для определения случайного веса кастомного артефакта по заданной формуле с учётом текущей сложности игры:
	1 - минимальный вес (для сложности в 50%);
	2 - уровень сложности настройки оборудования, GalaxyDiffLevels(4);
  Примечание: Обе эти функции не могут вернуть значение ниже 1.
IsShiftCtrlPressed - без аргументов, проверяет, нажаты ли сейчас обе клавиши Shift+Ctrl и возвращает 1, если нажаты, и 0, если нет;
SendStringToClipboard - записывает (удаляя содержимое) указанную строку в системный буфер обмена:
	1 - строка;
  Примечание: Казалось бы, функция не особо полезная, однако если сделать вот так: SendStringToClipboard(GenerateCodeStringFromBlock('ActCodeBlocksList.CodeName')), то можно легко получить в буфер исполняемую строку, в которой можно без проблем найти символ под любым номером, а по нему уже с лёгкостью отследить любой ненавистный Exception Compiler. Error=0,N. Очень намучился с поиском таких ошибок, а оказалось, что искать их всё-таки не сложно.
GetStringFromClipboard - без аргументов, возвращает строку из системного буфера обмена (если в буфере не оказалось строки, то вернёт '');
SetModsCFGValue - записывает указанный параметр и его значение (если параметр с таким именем в конфиге уже есть, то просто изменит его значение) в указанный txt-файл, который расположен в основной папке пользовательских документов (возвращает старое значение изменяемого параметра, либо '', если параметр пуст, либо отсутствует):
	1 - путь и название txt-файла, начиная из корня папки "Мои документы", например: 'SpaceRangersHD\ModsCFG.txt';
	2 - название параметра строкой (Важно: Не используйте в имени параметра символы '=' и '\n'!);
	3 - значение параметра строкой;
GetModsCFGValue - возвращает значение определённого параметра (в виде строки) из указанного txt-файла:
	1 - путь и название txt-файла из корня папки "Мои документы", например: 'SpaceRangersHD\ModsCFG.txt';
	2 - название параметра строкой;


Вызов скрипта и всё с этим связанное:
GRun - без аргументов, запускает текущий скрипт (работает только из глобал-кода скрипта);
ScriptRun - запускает скрипт с конкретным именем (возвращает 1 при успешном запуске):
	1 - система запуска;
	2 - планета запуска;
	3 - имя скрипта строкой;
GCntRun - возвращает количество запусков скрипта за текущую игровую партию:
	1 - имя скрипта строкой (удобно подставлять переменную GScriptName);
GLastTurnRun - возвращает ход, когда скрипт был запущен в последний раз (если скрипт ещё не запускался, вернёт 0):
	1 - имя скрипта строкой (удобно подставлять переменную GScriptName);
  Опционально:
	2 - новое значение (по умолчанию возвращает 0), которое будет возвращать данная функция в случае, если указанный скрипт ещё не запускался;
IsScriptActive - проверяет, существует и активен ли указанный скрипт:
	1 - имя скрипта строкой;
GAllCntRun - возвращает общее количество активных скриптов;
	Без аргументов - вернёт общее количество всех активных скриптов;
  Опционально:
	1 - номер типа скрипта (прописывается при объявлении скрипта в Main), вернёт количество активных скриптов с данным классом;
GScriptName - глобальная переменная, в которую записывается имя исполняемого в данный момент скрипта;
GRunFrom - глобальная переменная для определения состояний местонахождения игрока. Используется для запуска глобального кода во всех скриптах (а точнее принимает определённое значение при каждом срабатывании глобального кода) и может быть использована для точного определения времени запуска. Возможные значения переменной:
	0 - выставляется после совершения посадки игроком;
	1 - выставляется перед взлётом игрока;
	2 - выставляется после начала прыжка (на входе игрока в гипер);
	3 - выставляется перед завершением прыжка (на выходе игрока из гипера);
  Примечание: Подставляйте эту переменную с проверкой определённого состояния в условие перед стартом скрипта, если вы хотите, чтобы ваш скрипт стартовал в строго определённое время.


Сектор:
ConName - возвращает имя сектора:
	1 - сектор;
StarToCon - возвращает сектор системы:
	1 - система;
ConNear - проверяет находятся ли сектора, перечисленные начиная со второго аргумента,
рядом с сектором, указанным в первом аргументе:
	1 - целевой сектор;
	2, 3, 4... - сектора для проверки;
ConStars - возвращает общее количество систем в секторе:
	1 - сектор;
ConStar - возвращает определённую систему сектора:
	1 - сектор;
	2 - номер системы в списке систем этого сектора;
GalaxySectors - возвращает общее количество секторов в Галактике или конкретный сектор из списка по его номеру (начиная с 0):
	Без аргументов - вернёт общее количество секторов в Галактике;
  Опционально:
	1 - номер сектора (всегда равен Id сектора минус 1);
SectorVisible - проверяет, есть ли у игрока карты указанного сектора, или открывает его:
	1 - сектор;
  Опционально:
	2 - если значение != 0 то открыть сектор, если открывается пиратский сектор, то также восстанавливает ранее скрытые границы;


Система:
StarName - возвращает имя системы:
	1 - система (тип данных str);
GalaxyStars - без аргументов, возвращает общее количество систем в Галактике;
GalaxyStar - возвращает определённую систему по её номеру (начиная с 0):
	1 - номер системы в списке систем Галактики (всегда равен Id системы минус 1);
StarAngleBetween - угол, образованный тремя системами;
StarAngle - угол, определяющий направление от одной системы, к другой;
Dist2Star - возвращает реальное расстояние между двумя системами (для получения числа парсек необходимо применить формулу: round(sqrt(Dist2Star(star1, star2)))):
	1 - первая система;
	2 - вторая система;
StarOwner - возвращает или устанавливает текущего владельца системы:
	1 - система;
  Опционально:
	2 - установить нового владельца:
	  0 - Коалиция;
	  1 - доминаторы;
	  2 - пираты;
  Примечание: Для полноценной смены владельца системы вручную, нужно также поменять и владельца всех её населённых планет.
StarCustomFaction - возвращает или устанавливает текущего кастомного владельца системы в виде строки (например, 'Klissan'):
	1 - система;
  Опционально:
	2 - какое имя фракции установить;
StarBattle - проверяет, идёт ли в системе бой:
	1 - система;
StarSeries - возвращает или устанавливает серию доминаторов, владеющую системой (или владевшую ей ранее):
	1 - система;
  Опционально:
	2 - серия доминаторов:
	   0 - Блазер;
	   1 - Келлер;
	   2 - Террон;
StarNearbyStars - возвращает систему на определённом удалении от исходной:
	1 - исходная система;
	2 - номер по удалённости для возврата другой системы (на нулевом номере находится сама исходная система);
  Примечание: Очень удобно использовать для перебора ближайших к игроку систем.
StarNearbyStarsDist - то же самое, но возвращает не саму звезду, а расстояние до неё в парсеках;
DistToNearestEnemySystem - возвращает расстояние от системы до ближайшей доминаторской системы:
	1 - система;
StarEnemyThreatLevel - возвращает текущий уровень угрозы, нависший над системой:
	1 - система:
	  Уровни угрозы:
	    0 - система под контролем Коалиции или пиратов, угрозы нет;
	    1 - система под контролем Коалиции или пиратов, но в гипере к ней уже направляются доминаторы или враждебная кастомная раса;
	    2 - система под контролем Коалиции или пиратов, и в ней идёт бой (кого и с кем не имеет значения);
		3 - система находится под контролем доминаторов или враждебной кастомной расы (будет всегда возвращать 3, пока систему не отобьют Коалиция или пираты);
  Опционально:
	2 - если стоит маркер 1, то добавить в условие проверки ещё и пиратов в качестве враждебной расы:
	  Уровни угрозы:
	    0 - система под контролем Коалиции, угрозы нет;
	    1 - система под контролем Коалиции, но в гипере к ней уже направляются доминаторы, враждебная кастомная раса или пираты;
	    2 - система под контролем Коалиции, и в ней идёт бой (кого и с кем не имеет значения);
		3 - система находится под контролем доминаторов, враждебной кастомной расы или пиратов (будет всегда возвращать 3, пока систему не отобьют Коалиция или пираты);
StarFonImage - установка фона системы:
	1 - ссылка на систему;
	2 - номер нового фона (брать из CacheData раздел BGO, указывать только номер);
StarSetGraph - установка новой визуальной оболочки звезды:
	1 - звезда;
	2 - путь к новой звезде в Main.dat по пути 'Data.SE.Star. ...';
  Примечание: Оригинальная графика остаётся прежней, но поверх неё догружается дополнительная анимация (нужно подтверждение).


Планеты:
PlanetToStar - возвращает систему планеты:
	1 - планета;
AddPlanetNews - добавляет новую галановость в инфоцентре:
	1 - текст галановости;
  Опционально:
	2 - тип добавляемой новости числом, список существующих оригинальных типов ниже (по умолчанию выбирается 0);
  Примечание: Можно задавать свои кастомные типы под номерами с 46 по 255.
PlanetNews - без аргументов, возвращает общее число текущих галановостей в инфоцентре;
  Примечание: Для проверки свежих новостей желательно делать перебор от конца к началу, если только вам, по каким-то причинам, не нужно проверить все текущие новости в инфоцентре.
PlanetNewsDate - возвращает дату галановости:
	1 - номер галановости;
PlanetNewsType - возвращает тип галановости числом:
	1 - номер галановости, возможные типы:
	    0 (GalaxyNews) - неопознанная кастомная новость, добавленная через AddPlanetNews();
	    1 (RevoltAnarchy) - на какой-то планете установилась анархия;
		2 (RevoltDictatorship) - на какой-то планете установилась диктатура;
		3 (RevoltMonarchy) - на какой-то планете установилась монархия;
		4 (RevoltRepublic) - на какой-то планете установилась республика;
		5 (RevoltDemocracy) - на какой-то планете установилась демократия;
		6 (MineralDeposit) - на какой-то планете имеются большие запасы дешёвых минералов;
		7 (NeedMineral) - на какой-то планете наблюдается острая нужда в минералах;
		8 (ManyArms) - на какой-то планете имеются большие запасы дешёвого оружия (товаров);
		9 (NeedArms) - на какой-то планете наблюдается острая нужда в оружии (товаров);
	   10 (ManyTechnics) - на какой-то планете имеются большие запасы дешёвой техники (товаров);
	   11 (ManyFood) - на какой-то планете имеются большие запасы дешёвых продуктов (одновременно в этом же типе новости может наблюдаться ещё и нехватка техники);
	   12 (NeedFood) - на какой-то планете наблюдается острая нужда в продуктах (одновременно в этом же типе новости может наблюдаться ещё и нехватка медикаментов);
	   13 (ManyMedicine) - на какой-то планете имеются большие запасы дешёвых медикаментов;
	   14 (ManyLuxury) - на какой-то планете имеются большие запасы дешёвой роскоши;
	   15 (NeedLuxury) - на какой-то планете наблюдается острая нужда в роскоши;
	   16 (ManyAlcohol) - на какой-то планете имеются большие запасы дешёвого алкоголя;
	   17 (NeedAlcohol) - на какой-то планете наблюдается острая нужда в алкоголе;
	   18 (StarTransport) - в какой-то системе промышляет слишком много транспортников;
	   19 (StarPiratesMany) - в какой-то системе промышляет слишком много пиратов;
	   20 (StarPiratesSome) - в какой-то системе промышляет некоторое количество пиратов;
	   21 (StarPiratesNone) - в какой-то системе были истреблены все пираты;
	   22 (StarRangers) - в какой-то системе промышляет слишком много рейнджеров;
	   23 (StarBestRanger) - в какую-то систему нагрянул рейнджер, числящийся лучшим воином, торговцем или пиратом;
	   24 (StarKlingAttack) - на какую-то систему напали доминаторы;
	   25 (StarKlingLost) - нападение доминаторов на какую-то систему было успешно отражено;
	   26 (GroupWarriorLiberator) - военные готовят операцию по освобождению системы (без участия ВБ);
	   27 (StarPiratesAttack) - на какую-то систему напали пираты;
	   28 (StarPiratesLost) - нападение пиратов на какую-то систему было успешно отражено;
	   29 (StarNormalsCaptureKlings) - Коалиция отбила систему у доминаторов;
	   30 (StarNormalsCapturePirates) - Коалиция отбила систему у пиратов;
	   31 (StarPiratesCaptureKlings) - пираты отбили систему у доминаторов;
	   32 (StarPiratesCaptureNormals) - пираты отбили систему у Коалиции;
	   33 (StarKlingsCaptureNormals) - доминаторы отбили систему у Коалиции;
	   34 (StarKlingsCapturePirates) - доминаторы отбили систему у пиратов;
	   35 (CoalitionDefeated) - Коалиция была полностью разгромлена;
	   36 (NewBlackHole) - где-то открылась новая "чёрная дыра" (червоточина);
	   37 (EminentWarrior) - новость о присвоении какому-то рейнджеру статуса "отличившийся воин";
	   38 (EminentTrader) - новость о присвоении какому-то рейнджеру статуса "выдающийся делец";
	   39 (EminentPirate) - новость о присвоении какому-то рейнджеру статуса "злейший пират";
	   40 (RangerImprisoned) - какой-то рейнджер загремел в тюрьму;
	   41 (NewStation) - была построена новая станция;
	   42 (Investment) - игрок пожертвовал/профинансировал деньги нуждающимся рейнджерам, пиратам, семьям или ещё куда-нибудь;
	   43 (ProgramResearched) - завершилось исследование одной из ключевых антидоминаторских разработок;
	   44 (SpecialShip) - был построен один из особых корпусов из оригинальной игры (Перезагрузки) - Скала, Болид или Убийца;
	   45 (WBJumpPlanned) - какая-то военная база готовит операцию по освобождению системы;
PlanetNewsText - возвращает или меняет текст указанной галановости:
	1 - номер галановости (начиная с 0);
  Опционально:
	2 - новый текст;
  Примечание: Изменение текста галановости не меняет её тип.
GetRelationPlanet - возвращает отношение планеты к кораблю:
	1 - планета;
	2 - корабль;
PlanetName - возвращает имя планеты:
	1 - планета (тип данных str);
IdToPlanet - возвращает планету по её Id:
	1 - Id планеты;
PlanetGetGraph - возвращает путь к элементу планеты в игровом Main.dat, применять в связке с функцией GetMainData:
	1 - планета;
PlanetSetGraph - по идее может менять фон планеты и принимать значения:
	1 - планета;
	2 - новый фон планеты в Main.dat ('Data.SE.Planet'), либо номер данного фона;
FindPlanet - ищет планету в системе по заданным характеристикам:
	1 - система;
	2 - фильтр расы строкой (можно указывать несколько значений через запятую без пробелов, а если фильтр не нужен, просто оставить пустым ''):
	  'NotMaloc' - не малокская;
	  'NotPeleng' - не пеленгская;
	  'NotPeople' - не человеческая;
	  'NotFei' - не фэянская;
	  'NotGaal' - не гаальская;
	  'NotKling' - не доминаторская;
	  'NotPirateClan' - не пиратская;
	  'NotNone' - не незаселённая;
	3 - первая относительная граница расположения планеты внутри системы, где 0 - центр системы, а 100 - самый её край;
	4 - вторая относительная граница расположения планеты внутри системы;
	  Примечание: При указании третьего и четвёртого аргумента как '0,100', поиск будет выбирать любые существующие в системе планеты, а при указании этих же аргументов как, например, '33,66', будут подбираться лишь планеты со средним удалением от звезды, и т.д.
NearCivilPlanet - возвращает ближайшую к кораблю/станции обитаемую планету в системе, где он находится:
	1 - корабль/станция;
StarPlanets - возвращает количество планет в системе, или конкретную планету в ней:
	1 - система (вернёт количество);
  Опционально:
	2 - номер планеты в списке планет системы (вернёт планету);
GotoGov - принудительно переводит игрока на форму правительства ('Gov' для заселённых планет и 'RuinsTalk' для станций) и устанавливает запрет на её покидание:
	Без аргументов - проверить, установлен ли запрет на покидание правительства;
  Опционально:
	1 - установить/снять запрет:
	   0 - отпустить игрока;
	   1 - разово перевести игрока в правительство (сработает только если игрок уже не находится там);
	   2 - перевести в правительство (сработает только если игрок уже не находится там) и установить запрет на его покидание;
PlanetOwner - возвращает текущую расу-владельца планеты или устанавливает её:
	1 - планета;
  Опционально:
	2 - какого владельца назначить:
	   0 или (Maloc) - малоки (Коалиция);
	   1 или (Peleng) - пеленги (Коалиция);
	   2 или (People) - люди (Коалиция);
	   3 или (Fei) - фэяне (Коалиция);
	   4 или (Gaal) - гаальцы (Коалиция);
	   5 или (Kling) - доминаторы (Доминаторы);	  
	   6 или (None) - незаселённая;
	   7 или (PirateClan) - пиратский клан (Пираты);
PlanetRace - возвращает или устанавливает коренную расу планеты:
	1 - планета;
  Опционально:
	2 - какую расу установить:
	   0 (Maloc) - малоки;
	   1 (Peleng) - пеленги;
	   2 (People) - люди;
	   3 (Fei) - феяне;
	   4 (Gaal) - гаальцы;
PlanetGov - возвращает или устанавливает форму правления на планете:
	1 - планета;
  Опционально:
	2 - какую форму правления установить:
	   0 - анархия;
	   1 - диктатура;
	   2 - монархия;
	   3 - республика;
	   4 - демократия (на самом деле это больше политический строй, а не форма правления - добавлен в перечень форм правления по ошибке);
PlanetEco - возвращает или устанавливает тип экономики планеты:
	1 - планета;
  Опционально:
	2 - какой тип установить, типы экономики:
	   0 - аграрная;
	   1 - смешанная;
	   2 - индустриальная;
PlanetPirateClan - без аргументов, возвращает Роджерию;
GetShipHomePlanet - возвращает родную планету корабля:
	1 - корабль;
PlanetTerrain - возвращает и устанавливает исследуемые территории незаселённой планеты:
	1 - планета;
	2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
	3 - какую площадь указанной местности установить планете;
PlanetTerrainExplored - возвращает или устанавливает уже исследованные территории незаселённой планеты:
	1 - планета;
	2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
	3 - какую часть территории указанной местности сделать исследованной;
PlanetOrbitRadius - возвращает или устанавливает радиус орбиты планеты:
	1 - планета;
  Опционально:
	2 - новый радиус;
PlanetSize - возвращает или устанавливает размер планеты:
	1 - планета;
  Опционально:
	2 - новый размер;
CreatePlanet - создаёт новую планету:
	1 - система;
PlanetPopulation - возвращает или устанавливает популяцию планеты:
	1 - планета;
  Опционально:
	2 - какую численность населения установить;
PlanetOrbitalVelocity - возвращает или устанавливает направление вращения планеты:
	1 - планета;
  Опционально:
	2 - направление вращения:
	   0 - по часовой стрелке;
	   1 - против часовой;
PlanetWarriors - возвращает число военных кораблей, приписанных планете (даже если они в данный момент находятся на вылете):
	1 - планета;
  Опционально:
	2 - конкретный корабль из списка;
  Примечание: Пираты, созданные через BuyWarrior на пиратских планетах, данной функцией не учитываются.
FindPlanetByAdvancement - возвращает планету по степени её технического развития (может быть полезно, например, для спавна кораблей):
	1 - степень развития (от 1 до 100);
  Опционально:
	2 - владелец планеты (PlanetOwner);
PlanetCurInvention - возвращает или устанавливает текущий изучаемый планетой проект: 
	1 - планета;
	2 - тип проекта (числом);
  Опционально:
	3 какой проект установить;
PlanetCurInventionPoints - возвращает или устанавливает уровень исследования текущего проекта планеты:
	1 - планета;
	2 - тип проекта (числом);
  Опционально:
	3 - какой уровень исследования текущего проекта установить (от 0 до 100);
  Примечание: По достижении 100% изучения текущего проекта, его ТУ на данной планете повышается на единицу, после чего планета выбирает себе новый проект для изучения.
PlanetInventionLevel - возвращает или устанавливает текущий технический уровень определённого проекта планеты:
	1 - планета;
	2 - тип проекта (числом);
  Опционально:
	3 - какой технический уровень проекта установить (от 1 до 8);
  Типы проектов:
	0 (HullAlloy) - ТУ корпусов;
	1 (FuelTanksType) - ТУ топливных баков;
    2 (EngineSpeed) - ТУ двигателей;
	3 (RadarRadius) - ТУ радаров;
    4 (ScanerType) - ТУ сканеров;
	5 (RepairRobotType) - ТУ дроидов;
    6 (CargoHookType) - ТУ захватов;
	7 (TechLevel) - общий ТУ планеты, влияющий на ГТУ и на доступность изучения различных типов орудий (для начала изучения той или иной пушки, ТУ планеты должен быть сперва приравнен к ТУ этой пушки);
    8 (Weapon1) - ТУ промышленного лазера;
	9 (Weapon2) - ТУ осколочного орудия;
	10 (Weapon3) - ТУ лезки;
	11 (Weapon4) - ТУ ракетомёта;
	12 (Weapon5) - ТУ третона;
	13 (Weapon6) - ТУ волнового фазера;
	14 (Weapon7) - ТУ потокового бластера;
	15 (Weapon8) - ТУ электронного резака;
	16 (Weapon9) - ТУ мультирезонатора;
	17 (Weapon10) - ТУ атомного визиона;
	18 (Weapon11) - ТУ дезинтегратора;
	19 (Weapon12) - ТУ турбогравира;
PlanetBoostInventions - разово увеличивает скорость развития проектов на планете:
	1 - планета;
	2 - сколько дневных норм исследования проектов накинуть;
  Примечание: Каждый день планета получает определённое количество очков к исследованию своего проекта. При захвате системы доминаторами, у планеты появляется 30% шанс не получить очков исследований за текущий день, а при захвате системы пиратами этот же шанс составляет 15%. Функция PlanetBoostInventions позволяет условно промотать время исследований на N дней вперёд, но при этом градация получения очков исследования за день для планеты не изменится.


Станции:
StarRuins - возвращает количество станций в системе, либо конкретную станцию из этого списка:
	1 - система (вернёт количество станций в системе);
  Опционально:
	2 - если число, то вернёт станцию с указанным номером из списка, а если строка, то вернёт станцию указанного типа (либо 0, если такая станция отсутствует);
  Оригинальные типы станций:
	'RC' - ЦР;
	'WB' - ВБ;
	'SB' - НБ;
	'BK' - БЦ;
	'MC' - МЦ;
	'PB' - ПБ;
	'CB' - доминион;
  Примечание: Аналогично может сделать возврат кастомной станции с кастомным строковым типом, однако цель обязательно должна быть станцией, а не кораблём. Если станция с кастомным строковым типом имеет цифровой тип оригинальной станции (например, t_PB с типом 'BM'), то такая станция будет расценена функцией как кастомная и по запросу базы оригинального типа она возвращена не будет (то есть по StarRuins(star, 'PB') станция t_PB с 'BM' не вернётся).
RuinsChangeType - изменяет основной тип станции (ShipTypeN):
	1 - база;
	2 - новый тип станции (числом или строкой);
  Примечание: Данная функция позволяет сменить не строковый, но основной числовой тип базы, например t_RC на t_CB. Допускается указывать новый тип не числом, а строкой вида 'CB', 'RC' и т.д. в пределах восьми основных типов станций.
BuildRuins - создать базу (возвращает созданную):
	1 - система;
	2 - тип базы:
	   t_RC (6) - центр рейнджеров;
	   t_PB (7) - пиратская база;
	   t_WB (8) - военная база;
	   t_SB (9) - научная база;
	   t_BK (10) - бизнес-центр;
	   t_MC (11) - медицинский центр;
	   t_CB (12) - доминион;
BuildCustomRuins - создать кастомную базу (возвращает созданную):
	1 - система;
	2 - кастомный тип строкой;
	3 - чьей считать данную базу (тип Standing):
  Типы Standing:
	0 - Kling - (доминатор) считается доминатором без серии, а потому всеми другими доминаторами (да и вообще всеми) воспринимается враждебно;
	1 - None - (ничейная) полностью безразлична к происходящему в системе, аналогична транклюкатору без хозяина;
	2 - CoalMilitary - (военные) аналогично ВБ, ЦР и военным кораблям (может захватывать системы для Коалиции);
	3 - CoalActive - (военные-нейтралы) почти тоже, что и простые военные, но с пиратами отношения чуть получше, аналогична НБ и БЦ (может захватывать системы для Коалиции);
	4 - CoalPassive - (гражданские) аналогично транспортам в пиратских системах, не вызывает агрессии пиратов, пока не начнёт атаковать сама;
	5 - Neutral - (нейтралы) соответствует МЦ, перепрограммированному Блазеру и кораблям в тюрьме, игнорирует коалиционные и пиратские тёрки, но к доминаторам враждебна;
	6 - PiratePassive - (вольные пираты) соответствует обычным ПБ и простым пиратам, терпимо относящимся к Коалиции;
	7 - PirateActive - (пираты-нейтралы) соответствует атакующим пиратам (может захватывать системы для клана);
	8 - PirateMilitary - (клановые пираты) соответствует пиратским доминионам и запрещает посадку коалиционных кораблей;
	9 - Custom - будет враждебна всему, что не имеет той же кастомной фракции и абсолютно всему, если кастомная фракция у станции не установлена;
  Примечание: Добавление кастомной (t_UB) станции в кастомную фракцию (функция ShipCustomFaction) автоматически переведёт её в категорию tst_Custom, которая сохранится, даже если впоследствии кастомная фракция будет снята. Данное ограничение не распространяется на станции с оригинальными типами (t_SB, t_PB и т.д.).
  При добавлении к кастомному типу станции приставки '_licensed' (пример, 'MB_licensed'), станция получит возможность ремонтировать артефакты и нестандартное оборудование (равно как и залетающие NPC смогут ремонтировать их на ней).


Корабль (также данные функции работают для станций):
ShipStar - возвращает систему, в которой находится указанный корабль (у каждого корабля имеется указатель на свою текущую систему):
	1 - корабль;
GetOwner - возвращает основную расу корабля (не расу пилота, но, как правило, они совпадают):
	1 - корабль;
GiveReward - выдаёт кораблю случайную медаль по её типу;
	1 - корабль;
	2 - кем выдана (раса);
	3 - тип медали числом;
CountReward - возвращает общее количество медалей корабля или количество медалей определённого типа:
	1 - корабль;
  Опционально:
	2 - тип медали числом (за что выдана);
	  Типы медалей:
	    0 (ForLiberationSystem) - за освобождение системы или за победу над боссами (просто потому что);
	    1 (ForAccomplishment) - за выполнение задания, освобождение системы или за победу над боссами;
	    2 (ForSecretMission) - за выполнение задания;
	    3 (ForCowardice) - за провал задания;
	    4 (ForPerfidy) - различные позорные метки;
	    5 (ForPlanetBattle) - за победу в планетарном бою;
CountRewardByNom - возвращает общее количество медалей корабля или количество медалей под определённым номером в Lang:
	1 - корабль;
  Опционально:
	2 - номер медали в Lang;
GiveRewardByNom - выдаёт кораблю определённую медаль по её номеру в Lang:
	1 - корабль;
	2 - номер медали;
DeleteRewardByNom - удаляет у корабля определённую медаль по её номеру в Lang и возвращает число удалённых медалей:
	1 - корабль;
	2 - номер медали;
  Опционально:
	3 - сколько медалей с данным номером удалить (по умолчанию удалит 1);
DropItem - заставляет корабль выбросить указанный (или случайный) предмет:
	1 - корабль;
	2 - предмет (либо тип предмета, в таком случае будет выброшен случайный предмет указанного типа);
  Опционально:
	3 - откуда выбросить предмет (если для дропа был указан конкретный предмет, а не тип, то будет работать как 4-й аргумент):
	   0 - из трюма;
	   1 - экипированный;
	4 - скриптовый объект, в который будет автоматически занесён выброшенный предмет;
ShipPicksItem - возвращает/выставляет кораблю маркер на подбор предмета в космосе, либо запрещает его подбор:
	1 - корабль;
	2 - предмет;
  Опционально:
	3 - какой маркер установить:
	  -1 - запретить подбор данного предмета;
	   0 - снять все маркеры;
	   1 - добавить предмет в список на подбор;
  Примечание: Все маркеры будут автоматически сброшены, если корабль сядет на планету/станцию или покинет систему. Также можно добавлять в список на подбор/запрет предметы, которые уже находятся на борту другого корабля. В таком случае они будут подобраны ботами, если по какой-либо причине окажутся дропнутыми в космос (владелец сам дропнул предмет, либо его корабль был уничтожен).
DeleteEquipment - удаляет указанное установленное в слот оборудование с корабля:
	1 - корабль;
	2 - тип оборудования;
  Примечание: Не может удалять кастомное оружие и артефакты, а для удаления оригинального оружия необходимо указывать его конкретный тип.
ShipTypeN - возвращает основной числовой тип корабля (можно подставлять переменные типа t_Pirate, t_PB):
	1 - корабль;
	   0 (t_Kling) - доминатор;
	   1 (t_Ranger) - рейнджер;
	   2 (t_Transport) - гражданский (не только транспорт);
	   3 (t_Pirate) - пират (в т.ч. и клановый);
	   4 (t_Warrior) - военный;
	   5 (t_Tranclucator) - транклюкатор;
	   6 (t_RC) - центр рейнджеров;
	   7 (t_PB) - пиратская база;
	   8 (t_WB) - военная база;
	   9 (t_SB) - научная база;
	   10 (t_BK) - бизнес-центр;
	   11 (t_MC) - медицинский центр;
	   12 (t_CB) - доминион;
	   13 (t_UB) - кастомная база (создаётся функцией BuildCustomRuins);
  Примечание: Числовые типы кораблей являются оригинальными основными типами для большого количества кастомных типов судов. Они не поддерживают добавления кастомных типов и служат сугубо внутренним игровым функциям. Определять по ним корабли можно лишь в очень широких диапазонах. Для более точного определения типа корабля, используйте кастомные строчные типы и функцию ShipType.
ShipType - возвращает строковое имя типа корабля (дипломат, рейнджер, доминатор и т.д.):
	1 - корабль;
	2 - сменить строковое имя типа корабля на другое:
  Оригинальные имена типов (модами можно добавить свои):
	'Ranger' - рейнджер;
	'FemRanger' - спецагентка;
	'Pirate' - пират;
	'Transport' - транспорт;
	'Liner' - лайнер;
	'Diplomat' - дипломат;
	'Warrior' - военный или флагман;
	'Tranclucator' - робот;
	'Kling' - доминатор;
  Оригинальные типы станций:
	'RC' - центр рейнджеров;
	'RCSmall' - ЦР;
	'SB' - научная база;
	'SBSmall' - НБ;
	'WB' - военная база;
	'WBSmall' - ВБ;
	'MC' - медицинский центр;
	'MCSmall' - МЦ;
	'BK' - бизнес-центр;
	'BKSmall' - БЦ;
	'PB' - пиратская база;
	'PBSmall' - ПБ;
	'CB' - доминион;
	'CBSmall' - ДМ;
    Примечание: Типы станций с приставкой Small используются в некоторых окнах для подстановки сокращённых названий (например, при улучшении станции игроком). Проверять станции на такие типы в скрипте не нужно, они используются только в Lang для указания сокращённого имени.
  Кастомные типы кораблей:
	'Militiaman1' - ополченец, первый тип (ExpPilotBridge);
	'Militiaman2' - ополченец, второй тип (ExpPilotBridge);
	'Militiaman3' - ополченец, третий тип (ExpPilotBridge);
	'Rebel' - повстанец (ExpPilotBridge и ShuRebellion);
	'PirateRunner' - пират-загонщик (ExpPilotBridge);
	'AbandonedShip' - покинутый корабль, остающийся после запуска спасательной шлюпки (фактически лайнер, ExpTC);
	'RangerPirate' - рейнджер изменник (ExpTraitors);
	'RangerPiratePlayer' - тип игрока, когда он переходит на сторону пиратов (ExpTraitors);
	'RangerExplorer' - рейнджер с фиксированным именем характера "Исследователь" (ExpExplorers);
	'RangerPirateExplorer' - рейнджер-изменник с фиксированным именем характера "Авантюрист" (ExpExplorers);
	'Smuggler' - рядовой контрабандист (ShuSmugglers), а также тип одного скриптового контрабандиста для события получения доступа к ЧР (ExpBlackMarket);
	'KillerAsteroid' - огромный астероид, угрожающий планете (ExpPhysGun);
	'Dreadnought' - дредноут (EvoArmada);
	'PirateCorvette' - пиратский корвет (EvoArmada);
	'PirateFrigate' - пиратский фрегат (EvoArmada);
	'PirateGalleon' - пиратский галеон (EvoArmada);
	'EliteWarrior' - элитный военный с акриновым корпусом (ShuWarriors);
	'Merc' - наёмник (ShuMercs);
	'PlayerMerc' - наёмник из организации игрока (ShuMercs);
	'Freelancer' - фрилансер (ShuMercs);
	'RedLeader' - варлорд Бордюрг Ебрын (ShuMercs);
	'AtlantLeader' - лидер Кайло Норт (ShuMercs);
	'FeiLeader' - гендир Элайма Фэй (ShuMercs);
	'DomTrank' - доминаторский транклюкатор (ShuDomiks);
	'Superdominator' - супердоминатор (ShuDomiks и ShuMiniBoss);
	'DomRuins' - верфь, а точнее эквентор, имитирующий станцию (ShuDomiks);
	'KellerClone' - клон Келлера (ShuDomiks);
	'Pillager' - пиратская баржа (ShuMiniBoss);
	'Klissan' - клисанский корабль, когда он пират? (ShuKlissan);
	'Klissan1' - клисан эгемон (ShuKlissan);
	'Klissan2' - клисан нондус (ShuKlissan);
	'Klissan3' - клисан катаури (ShuKlissan);
	'Klissan4' - клисан рогит (ShuKlissan);
	'Klissan5' - клисан мутенок (ShuKlissan);
	'None' - неизвестный корабль (ShuKlissan);
	'Badass' - изменник (ShuKlissan);
	'Khan' - хан (ShuPirates);
	'Thug' - головорез (ShuPirates);
  Кастомные типы станций:
	'TC' - технологический центр (номерной тип 13 - кастомка, ExpTC);
	'TCSmall' - ТЦ;
	'SSB' - подпространственная база (номерной тип 11 - МЦ, ExpSSB);
	'SSBSmall' - ППБ;
	'BM' - чёрный рынок (номерной тип 7 - ПБ, ExpBlackMarket);
	'BMSmall' - ЧР;
	'MB' - центр наёмников (номерной тип 13 - кастомка, ShuMercs);
	'MBSmall' - ЦН;
	'PlayerMB' - штаб наёмников игрока (номерной тип 13 - кастомка, ShuMercs);
	'PlayerMBSmall' - ЦН;
	'PlayerMB_licensed' - штаб наёмников игрока, с лицензией на ремонт артефактов и прочих нестандартных штук (номерной тип 13 - кастомка, ShuMercs);
	'PlayerMBSmall_licensed' - ЦН;
	'Manaan' - свободный порт, а точнее центр наёмников после уничтожения всех главарей наёмников (номерной тип 13 - кастомка, ShuMercs);
	'ManaanSmall' - СП;
	'Inhibitor' - ингибитор (номерной тип 13 - кастомка, ShuDomiks);
	'InhibitorSmall' - Ингибитор;
	'KB' - нейролинк (номерной тип 13 - кастомка, ShuKlissan);
	'KBSmall' - НЛ;
	'Handler' - секретный объект Хандлер (номерной тип 13 - кастомка, ShuKlissan);
	'HandlerSmall' - СО;
	'Machpella' - Махпелла (номерной тип 13 - кастомка, ShuKlissan);
	'MachpellaSmall' - '';
    Примечание: При добавлении к кастомному типу станции приставки '_licensed' (пример, 'MB_licensed'), станция получит возможность ремонтировать артефакты и нестандартное оборудование (равно как и залетающие NPC смогут ремонтировать их на ней).
ShipSubType - возвращает или устанавливает подтип корабля:
	1 - корабль (вернёт текущий подтип);
  Опционально:
	2 - какой подтип установить:
	  Доминаторы:
		0 - босс (Блазер, Келлер или Террон);
		1 - эквентор;
		2 - ургант;
		3 - смерш;
		4 - менок;
		5 - штип;
		6 - бертор;
		7 - клиг;
	  Гражданские корабли (ShipTypeN = 2):
		0 - транспорт;
		1 - лайнер;
		2 - дипломат;
	  Военные:
		0 - обычный;
		1 - флагман;
	  Пираты:
		0 - вольный пират (не из клана);
		1, 2, 3 - виды клановых пиратов, отличающихся только предпочтениями в эквипе (для разнообразия);
ShipCustomFaction - возвращает/устанавливает/снимает кастомную фракцию для корабля (для получения кастомной фракции корабль обязательно должен находиться в скриптовой группе!):
	1 - корабль;
  Опционально:
	2 - имя кастомной фракции строкой ('' - снять кастомную фракцию);
  Примечание: Если имя кастомной фракции начинается с 'SubFaction' (например, 'SubFactionKlissan'), то корабли с такой фракцией не станут по умолчанию враждебными всем окружающим, но сохранят свою стандартную логику поведения. Также наличие обязательной скриптовой группы для кораблей с кастомной фракцией не обеспечивает им защиту от астероидов. Опционально имеется возможность накладывать маркер 'FixedStanding' в названии кастомной фракции для жёсткого закрепления за кораблём его текущего типа Standing (подробнее об этом читайте в описании функции ShipStanding()).
IdToShip - возвращает корабль по его Id:
	1 - Id корабля;
ShipName - возвращает не полное (без приставки типа) имя корабля (для возврата полного используйте Name):
	1 - корабль (пример - из "Лякуша Лошарик" вернёт "Лошарик");
  Примечание: Если ранее вы меняли имя корабля через SetName(), то вернёт уже изменённое, а не изначальное имя.
ShipPilotRace - возвращает/устанавливает расу пилота корабля:
	1 - корабль;
  Опционально:
	2 - какую расу установить:
	   0 (Maloc) - малоки;
	   1 (Peleng) - пеленги;
	   2 (People) - люди;
	   3 (Fei) - феяне;
	   4 (Gaal) - гаальцы;
ShipCanJump - проверяет, может ли корабль совершить прыжок (по умолчанию проверяет только по дальности двигателя) из одной системы в другую(ие) систему(ы):
	1 - корабль;
	2 - система, из которой нужно прыгать;
	3, 4, 5 и т.д. - следующие системы которые нужно проверить на возможность прыжка (фактически, проверяется маршрут), минимум одна система (3) должна быть указана, далее количество систем для проверки не ограничено. Помимо системы, следующим аргументом в очереди можно указать маркер 1, чтобы функция проверила возможность прыжка не только по двигателю, но и по топливу для всего выстроенного маршрута;
ShipInStar - проверяет не находится ли корабль в определённой системе:
	1 - корабль;
	2 - система;
ShipInPlanet - проверяет не находится ли корабль на планете:
	1 - корабль;
	2 - планета;
ShipFind - ищет в системе, в которой находится игрок, корабль определённого типа:
	1 - числовой тип корабля;
ShipDestroy - уничтожает определённый корабль или принудительно отменяет его уничтожение:
	1 - корабль;
	2 - уничтожить/отменить уничтожение (1 или 0);
Player - без аргументов, возвращает корабль игрока;
CountTurn - возвращает количество ходов, которое потребуется кораблю, чтобы достигнуть определённого объекта:
	1 - корабль;
	2 - объект (возможные типы объектов: скриптовое место, планета, корабль/станция);
ShipTurnBeforeEndOrder - аналог CountTurn, но без второго аргумента, просто считает сколько будет выполняться текущий приказ корабля:
	1 - корабль;
ShipGetBad - возвращает текущий объект враждебности корабля:
	1 - корабль (проверять враждебность только по отношению Relation для игрока некорректно, т.к. даже при враждебном поведении отношение корабля может быть выше 10);
ShipSetBad - назначить кораблю/станции текущего врага:
	1 - корабль;
	2 - враг (другой корабль или станция);
ShipInGameEvent - проверяет, не участвует ли военный корабль или ВБ в операции по освобождению системы (помешать этому из скрипта никак нельзя):
	1 - военный корабль или военная база;
ShipInNormalSpace - проверяет, что корабль в обычном космосе (не в гиперпространстве, не в АБ, не на планете и т.д.):
	1 - корабль;
ShipInHole - проверяет не находится ли корабль в ЧД:
	1 - корабль;
  Примечание: Фактически представляет собой две последовательные проверки: ShipInHyperSpace(ship) и ShipOrder(ship) == 4 (приказ на прыжок в ЧД), так что может возвращать 'True' параллельно с функцией ShipInHyperSpace.
ShipIsTakeoff - проверяет не взлетает ли корабль с планеты/станции:
	1 - корабль;
StarShips - возвращает количество кораблей и станций (!) в системе (но иногда не учитывает военные корабли на планетах), или конкретный корабль в ней:
	1 - система (вернёт количество);
  Опционально:
	2 - номер корабля в списке кораблей и станций (!) системы (вернёт корабль);
GetShipPlanet - возвращает планету, на которой в текущий момент находится корабль (если корабль не на планете вернёт 0):
	1 - корабль;
GetShipRuins - возвращает станцию, на которой в текущий момент находится корабль (если корабль не на станции вернёт 0):
	1 - корабль;
  Примечание: Если игрок находится на экране мостика и при этом сидит на планете или станции, для возврата соответствующей планеты или станции необходимо применить функцию возврата повторно, пример: GetShipRuins(GetShipRuins(Player())) или GetShipPlanet(GetShipRuins(Player())).
GetTalkShip - без аргументов, во время разговора в космосе возвращает корабль собеседника (во всех остальных случаях вернёт 0);
ShipInHyperSpace - проверяет, не находится ли корабль в гиперпространстве:
	1 - корабль;
OrderJump - заставляет корабль совершить прыжок в другую систему игнорируя возможности двигателя и бака:
	1 - корабль;
	2 - система назначения;
  Опционально:
	3 - приоритет приказа (нескриптовые корабли всё равно могут проигнорить, но по ерунде отвлекаться не будут);
ShipDestination - переносит корабль в другую систему сразу после его взлёта со станции, (функция, воссоздающая портальный прыжок с пиратских доминионов, выставлять только пока корабль находится на станции):
	1 - корабль (с одним аргументом вернёт текущую систему назначения);
  Опционально:
	2 - установить систему назначения (пропуск хода станет невозможен);
OrderLanding - заставляет корабль приземлиться:
	1 - корабль;
	2 - объект для посадки (планета или станция);
  Опционально:
	3 - приоритет приказа;
OrderTakeOff - отдать кораблю приказ на взлёт:
	1 - корабль;
OrderLock - блокировать/разблокировать возможность отдавать любые приказы (кроме скриптовых) для конкретного корабля:
	1 - корабль;
  Опционально:
	2 - блокировать/разблокировать отдачу приказов: 1/0;
  Примечание: В том числе блокирует логику, выставляемую кораблям стейтами, так что если вам необходимо поместить корабль в стейт, но при этом не использовать логику данного стейта (включая стейты с None), и выставлять приказы только вручную, то OrderLock() будет обязательным условием такого контроля.
OrderNone - отменяет текущий приказ и боевые цели корабля:
	1 - корабль;
OrderMove - приказ кораблю двигаться к указанным координатам:
	1 - корабль;
	2 - X координата, либо название переменной (без кавычек) скриптового места, если приказ вызывается из конкретного скрипта;
	3 - Y координата;
OrderTeleport - приказ кораблю/станции телепортироваться в указанную систему в указанные координаты:
	1 - корабль или станция;
	2 - целевая система;
	3 - X координата в целевой системе;
	4 - Y координата в целевой системе;
  Опционально:
	5 - приоритет приказа (в данном случае бесполезно);
	6 - длительность нахождения корабля/станции в гипере в днях (допустимо выставлять 0 для мгновенного переноса);
OrderFollowShip - приказ кораблю следовать за другим кораблём:
	1 - корабль;
	2 - целевой корабль;
	3 - тип следования:
	   0 - простое следование;
	   1 - выход на дистанцию выстрела;
	   2 - выход на дистанцию выстрела самого дальнобойного орудия (не используется в оригинальной игре);
  Опционально:
	4 - приоритет приказа;
OrderJumpHole - приказ кораблю залететь в ЧД:
	1 - корабль;
	2 - ЧД;
  Опционально:
	3 - приоритет приказа;
ShipOrder - возвращает или устанавливает текущий приказ для корабля:
	1 - корабль;
  Опционально:
	2 - какой приказ установить числом, либо 'X' или 'Y' строкой для возвращения координаты текущего приказа:
	  Список приказов:
	   -1 - автобой (только для игрока);
		0 - без приказа;
		1 - движение;
		2 - посадка;
		3 - прыжок;
		4 - прыжок в ЧД;
		5 - взлёт;
		6 - следование (обычное, либо приближение на расстояние выстрела);
		7 - телепортация;
	3 - если вторым аргументом стоит 'X' или 'Y', то установить новое значение соответствующей координаты;
  Примечание: Координаты приказа имеются только у приказов движения, прыжка, и также прыжка в ЧД.
ShipOrderData1 - первая переменная, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка:
	1 - корабль;
  Опционально:
	2 - задать новую длительность;
	  Примечание: Если у корабля установлен приказ "следование", то у ShipOrderData1 будут три значения:
	     0 - t_FollowNear (простое следование);
		 1 - t_FollowMin (на расстоянии выстрела);
		 2 - t_FollowMax (на расстоянии выстрела самой дальнобойной пушки (по умолчанию в игре не используется));
ShipOrderData2 - вторая переменная, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка (для ЧД-прыжков здесь выставляются особые маркеры):
	1 - корабль;
  Опционально:
	2 - задать новую длительность;
	  Примечание: Общая длительность прыжка хранится в двух переменных типа dword и определяется игрой по следующей формуле: ShipOrderData1 + ShipOrderData2 * 65536. При этом максимально допустимое значение длительности будет достигнуто, если одновременно установить кораблю ShipOrderData1(ship, 65535) и ShipOrderData2(ship, 32767) (не больше, иначе dword переполнится!). При установлении длительности прыжка в функции самого приказа (например, OrderTeleport), переданное значение длительности будет автоматически разбито по двум ShipOrderData, что необходимо учитывать, если в дальнейшем вы захотите изменить длительность этими функциями.
	  При залёте в ЧД значение второй переменной ShipOrderData2 используется под маркеры, а потому максимальную длительность конкретно ЧД-прыжка можно запомнить только в одной переменной ShipOrderData1(ship, 65535).
	    Маркеры, записываемые в ShipOrderData2 при ЧД-прыжках:
	      Для простых кораблей:
		    0 - корабль влетел в ЧД со стороны входа;
		    1 - корабль влетел в ЧД со стороны выхода;
		  Для Келлера:
		    Маркеры, каким-то образом определяющие траекторию вылета Келлера из ЧД;
		  Для всех:
		    65535 - корабль производит вылет из ЧД (ShipOrderData1 при этом должен быть задан на 0);
		  Примечание: При вылете из ЧД объект приказа на саму ЧД (ShipOrderObj) у корабля уже обнулён, а потому, если выставить ShipOrderData1(ship, 0) и ShipOrderData2(ship, 65535), задать кораблю нужные координаты, отдать приказ на ЧД-прыжок (ShipOrderObj должен быть 0) и произвести MakeShipEnterStar, с указанием нужной системы, можно заставить корабль совершить взлёт из любой желаемой точки системы. К сожалению, данный метод будет работать только из акткода, на OnStep 1 и выше, и не факт, что сработает для корабля игрока, нужны тесты.
		  Пример верной расстановки функций:
			MakeShipEnterStar(ship, to_star, from_star, 0);
			ShipSetCoords(ship, 0, 0);
			ShipOrder(ship, 4);
			ShipOrderObj(ship, 0);
			ShipOrderData1(ship, 0);
			ShipOrderData2(ship, 65535);
ShipOrderObj - возвращает или изменяет объект действия текущего приказа корабля (если корабль ведёт автобой, то объектом будет его цель, если совершает прыжок, то целевая система, если залетает/находится в ЧД, то ЧД и т.д.):
	1 - корабль;
  Опционально:
	2 - на какой объект заменить объект действия корабля;
MakeShipEnterStar - форсирует вход корабля в систему, как будто он совершил полноценный прыжок:
	1 - корабль;
	2 - система, в которую совершается прыжок;
	3 - система, из которой совершается прыжок (определяет точку выхода из гипера);
	4 - время нахождения корабля в гипере перед выходом;
AutoBattle - функция активации автобоя для игрока:
	1 - корабль с которым игрок должен вести автобой или 0 - отмена автобоя (допустимо вести автобой с самим собой);
ShipAddDropItem - заставить корабль дропнуть некоторый предмет при гибели (в трюме предмет не отображается, место не занимает):
	1 - корабль;
	2 - предмет;
ChanceToWin - возвращает (в виде int от 0 до 100) шанс победы одного корабля над другим:
	1 - один корабль;
	2 - другой корабль;
  Опционально:
	3 - опциональный флаг (любое число выше 0), чтобы функция вернула расчёт не в процентах, а в оригинальном виде с типом float, где все значения от 4 целых и выше уже будут считаться игрой 100% шансом на победу;
	Примечание: Клиги будут таранить игрока только при получении ChanceToWin < 0.2, а иначе будут просто атаковать его как обычные корабли.
IsChameleon - проверяет, применён ли хамелеон (не камуфляж, а именно "хамелеон", то есть визуальная смена внешнего вида корпуса) к кораблю в настоящий момент:
	1 - корабль;
Chameleon - меняет визуальный облик корабля:
	1 - корабль или база (если это единственный аргумент, то сбрасывает шкурку на базовый вид для текущего корпуса или акрина);
  Опционально:
	2 - путь в main.dat/Data/SE к нужной шкурке (например, строка вида 'Ship.Gaal.Transport' поменяет шкурку на гаальский транспорт) или строка 'GraphName' для возврата полного пути к уже установленной на корабле шкурке;
	3 - если значение больше 0, то выполнится автоматический перезаход на форму StarMap для моментальной визуальной смены шкурки корпуса. Имеет смысл применять данный маркер только если игрок находится на форме StarMap и имеет прямой визуальный контакт на корабль, меняющий шкурку. Во всех остальных случаях просто игнорируйте этот аргумент.
  Примечание: Если вы повесили на корпус корабля акрин и хотите автоматически обновить его облик, команды Chameleon(ship) для этого вполне достаточно.
PlayerChameleonCharges - проверяет или устанавливает количество доступных активаций камуфляжа у игрока:
	1 - серия;
  Опционально:
	2 - сколько активаций задать;
PlayerChameleonDetected - проверяет, устанавливает и снимает детект доминаторами камуфляжа игрока:
	1 - серия камуфляжа;
  Опционально:
	2 - включить/отключить детект;
PlayerChameleonCurType - возвращает/устанавливает активный доминаторский камуфляж на корабле игрока:
	Без аргументов - возвращает текущий камуфляж (-1 - камуфляж неактивен);
  Опционально:
	1 - установить, либо снять камуфляж:
      -1 - снять камуфляж;
	   0 - установить камуфляж блазероида;
	   1 - установить камуфляж келлероида;
	   2 - установить камуфляж терроноида;
  Примечание: Сама по себе данная функция "хамелеон" не накладывает, а просто устанавливает игроку камуфляжный режим. То есть без вызова дополнительной функции Chameleon() внешний вид игрока не изменится, но доминаторы всё равно будут считать его за своего.
PlayerLogicChameleon - особая скриптовая маскировка, позволяющая активировать функцию, аналогичную игровому камуфляжу, но с новыми дополнительными возможностями (внешний вид корабля доминатора не накладывается, а коалиционные и пиратские корабли не считают игрока доминатором):
	1 - серия доминаторов, без второго аргумента просто вернёт статус спецкамуфляжа:
	   0 - блазероиды;
	   1 - келлероиды;
	   2 - терроноиды;
  Опционально:
	2 - какой статус спецкамуфляжа для указанной серии доминаторов установить;
	  Возможные статусы:
		0 - камуфляжа нет (отключает спецкамуфляж);
		1 - доминаторы не атакуют, пока не заметят обман (базовый тип камуфляжа);
		2 - доминаторы не атакуют игрока совсем, но и игрок также не может их атаковать;
  Примечание: Если бой уже начался, то запрет атаки в обе стороны включить не выйдет, т.к. игрок всё равно сможет защищаться. Диалоги с другими кораблями при включении спецкамуфляжа никак не меняются (кроме, возможно, вариаций диалогов домиков). Боссы при статусе спецкамуфляжа 1 или 2 (при условии, что игрок не был обнаружен) не запускают скриптовый диалог, а выдают стандартную камуфляжную реплику, как при обычном камуфляже, которую можно перебить оверрайдом.
ShipChangeStar - меняет текущую систему привязки корабля, что необходимо делать вручную только при нестандартном перемещении кораблей из кода (также важно для корректного возврата функции ShipStar()):
	1 - корабль;
	2 - новая система привязки;
ShipRefit - обновляет оборудование на корабле (заставляет корабль провести реинвентаризацию из своего источника/магазина), если он находится на планете или станции (иначе не сделает ничего):
	1 - корабль;
  Опционально:
	2 - минимальный размер корпуса, который нужно установить кораблю (автоматически поднимет и число HP);
	3 - минимальная сумма денег, которую нужно установить кораблю;
ShipStatusEffect - проверяет и изменяет мощность эффектов, наложенных на корабль в текущий момент (0 - эффекта нет):
	1 - корабль;
	2 - тип эффекта:
	   0 (steShock) - эффект ионизации;
	   1 (steAcid) - эффект ослабления брони (коррозия);
	   2 (steMagnetic) - эффект ЭМ-помех;
	   3 (steWeaponBlock) - эффект блокировки орудий;
	   4 (steDroidBlock) - эффект блокировки дроида;
	   5 (steBWBuff) - эффект усиления от флагмана;
	   6 (steBWRepairDebuff) - эффект ослабления последовательных ремонтов от флагмана (если корабль чиниться от флагмана, либо сам флагман применяет на себя особый ремонт, с каждым разом эффективность ремонта будет становиться всё слабее и слабее);
  Опционально:
	3 - на какое значение изменить мощность эффекта, также напрямую влияющую на продолжительность этого эффекта (суммируется с уже существующим значением, может быть отрицательным);
	4 - корабль/станция, которая будет считаться наложившей эффект (будет применено, только если мощность эффекта была увеличена, по сравнению с предыдущим значением);


Группа кораблей:
SetRelationGroup - устанавливает отношение скриптовой группы кораблей к скриптовой группе кораблей рейнджеров:
	1 - группа кораблей, которым задаём отношение;
	2 - группа рейнджеров;
	3 - какой уровень отношения установить (0-4);
SetRelationPlanet - устанавливает отношение планеты к скриптовой группе кораблей рейнджеров:
	1 - группа рейнджеров;
	2 - планета;
	3 - какой уровень отношения установить (0-4);
	  Уровни отношения:
	    0 (ReWar) - враждебное отношение, фактическое значение 5;
	    1 (ReBad) - плохое отношение, фактическое значение 20;
	    2 (ReNormal) - нормальное отношение, фактическое значение 45;
	    3 (ReGood) - хорошее отношение, фактическое значение 70;
	    4 (ReBest) - отличное отношение, фактическое значение 90;
ShipGroup - возвращает номер скриптовой группы корабля (имеет смысл вызывать только из того скрипта, в котором находится корабль):
	1 - корабль (если корабль не в группе, вернёт -1);
  Примечание: Название группы - это переменная с номером, так что можно сравнивать возврат данной функции непосредственно с названием переменной конкретной группы. При этом в каждом скрипте нумерация скриптовых групп своя, так что проверять соответствие группы корабля номеру группы из другого скрипта не имеет смысла.
GroupToShip - возвращает первый корабль в выбранной группе текущего скрипта:
	1 - название группы;
GroupCount - считает количество кораблей в определённой скриптовой группе:
	1 - название группы;
GroupShip - возвращает конкретный корабль из скриптовой группы:
	1 - название группы;
	2 - номер корабля в скриптовой группе (начиная с 0);
GroupIn - проверяет не находится ли скриптовая группа в определённом месте (необходимо присутствие в одном месте сразу всех кораблей группы):
	1 - название группы;
	2 - место, возможные типы:
	   - Конкретная система;
	   - Конкретная планета;
	   - Конкретная станция или корабль (да, можно сажать корабли на корабли);
	   - Конкретное скриптовое место;
CountIn - считает количество кораблей скриптовой группы в определённом месте:
    1 - название группы (без второго аргумента вернёт общее количество кораблей в группе);
  Опционально:
	2 - место, в котором будет производиться подсчёт:
	   - Конкретная система;
	   - Конкретная планета;
	   - Конкретное скриптовое место;
	3 - флаг (если != 0) о пропуске подсчёта кораблей группы, в данный момент находящихся в гипере (ShipInHyperSpace()), актуально для подсчёта кораблей группы в конкретной системе;
NearestGroup - проверяет какая из перечисленных скриптовых групп ближе к определённому кораблю:
	1 - корабль;
	2 - минимальная дистанция для проверки, 3, 4, 5 и т.д. - номера групп для проверки;
GroupSetBad - назначить всем кораблям группы текущего врага:
	1 - название группы;
	2 - корабль врага;
GroupIs - проверяет не является ли группа корабля указанной(ыми) группой(ами):
	1 - корабль;
	2, 3, 4 и т.д - номера групп (подставлять переменную группы) для проверки;


Создание кораблей:
BuyRanger - спавнит рейнджера:
	1 - планета для спавна;
  Опционально:
	2 - множитель стартового капитала (в процентах);
BuyPirate - создаёт пирата:
	1 - планета для спавна корабля;
  Опционально:
	2 - множитель стартового капитала (в процентах);
  При спавне пирата на Роджерии (PlanetPirateClan()), его раса пилота (и оборудования) НЕ будет выбрана случайным образом, т.к. кто-то в 2017 году попросил специально сломать эту удобнейшую возможность при спавне пиратов из скрипта. Наслаждайтесь.
BuyWarrior - спавнит военный корабль или кланового пирата-защитника (зависит от овнера планеты):
	1 - планета для спавна;
  Опционально:
	2 - множитель стартового капитала (в процентах);
  При спавне пирата-защитника на Роджерии (PlanetPirateClan()), его раса пилота (и оборудования) будет выбрана случайным образом.
BuyBigWarrior - спавнит флагман:
	1 - планета для спавна;
  Опционально:
	2 - множитель стартового капитала (в процентах);
BuyTransport - создаёт гражданское судно (не только транспорт):
	1 - планета для спавна корабля;
  Опционально:
	2 - тип гражданского:
	   0 - транспорт;
	   1 - лайнер;
	   2 - дипломат;
	3 - множитель стартового капитала (в процентах);
BuyTranclucator - спавнит транклюкатора:
	1 - планета для спавна;
  Опционально:
	2 - сила транклюкатора;
BuyDomik - спавнит доминатора, устаревший алгоритм:
	1 - планета для спавна;
BuyDomikExtremal - спавнит доминатора, стандартный алгоритм:
	1 - планета для спавна;
  Опционально:
	2 - подтип ShipSubType() доминатора:
	   1 - эквентор;
	   2 - ургант;
	   3 - смерш;
	   4 - менок;
	   5 - штип;
	   6 - бертор;
	   7 - клиг;
TransferShip - перемещает (не телепортирует, а просто мгновенно переносит) корабль/станцию на заданный объект:
	1 - корабль/станция;
	2 - объект, куда нужно переместить корабль, возможные типы объектов:
	   - система (появится в новой системе по своим текущим координатам);
	   - планета;
	   - станция;
GalaxyShipId - без аргументов, возвращает Id, которое будет присвоено следующему родившемуся кораблю;


Игрок и другие рейнджеры:
IsPlayer - проверяет, не является ли корабль игроком (аналогично можно проверить как if(ship == Player()), но IsPlayer() оптимальнее):
	1 - корабль;
StatusPlayer - без аргументов, возвращает текущий статус характера игрока (устаревшая функция):
  Типы статусов:
	1 - торговец;
	0 - воин;
   -1 - пират;
RangerStatus - возвращает текущий статус характера любого рейнджера (включая игрока):
	1 - корабль рейнджера;
	  Типы возвращаемых статусов:
	    0 - торговец;
	    1 - пират;
        2 - воин;
	2 - проверка, не вынесен ли данный рейнджер на доску почёта в указанной категории (подставить строку):
	   'EminentWarrior' - отличившийся воин;
	   'EminentTrader' - выдающийся делец;
	   'EminentPirate' - злейший пират;
ShipStrengthInBestRanger - возвращает относительную силу корабля по сравнению с лучшим рейнджером:
	1 - корабль;
ShipStrengthInAverageRanger - возвращает относительную силу корабля по сравнению со средним рейнджером:
	1 - корабль;
ShipJoinsClan - корабль вступает в пиратский клан:
	1 - корабль;
ShipInPirateClan - проверяет, состоит ли корабль в пиратском клане, а для игрока - вступал ли он в клан в этой партии вообще:
	1 - корабль;
ShipOnSidePirateClan - проверяет, состоит ли корабль в пиратском клане в настоящий момент (также можно проверить с помощью ShipOwner(ship) == 7):
	1 - корабль;
ShipRank - возвращает текущее военное звание корабля числом:
	1 - корабль;
	  Звания:
	    0 - Новичок;
	    1 - Кадет;
	    2 - Пилот;
	    3 - Капитан;
	    4 - Истребитель;
	    5 - Ас (Пилот);
	    6 - Командор;
	    7 - Адмирал;
GetShipPirateRank - возвращает текущее пиратское звание корабля числом:
	1 - корабль;
	  Звания:
	    0 - Салага;
	    1 - Юнга;
	    2 - Рейдер;
	    3 - Шкипер;
	    4 - Головорез;
	    5 - Атаман;
	    6 - Хан;
	    7 - Барон;
ShipRankPoints - возвращает или устанавливает текущее количество очков коалиционного (военного) рейтинга:
	1 - корабль;
  Опционально:
	2 - какое количество очков установить;
ShipNextRankPoints - возвращает количество очков коалиционного рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько ему нужно всего):
	1 - корабль;
ShipRaiseRank - повышает текущее коалиционное звание корабля на плюс одно (сработает только если у корабля достаточно очков):
	1 - корабль;
ShipPirateRankPoints - возвращает или устанавливает текущее количество очков пиратского рейтинга:
	1 - корабль;
  Опционально:
	2 - какое количество очков установить;
ShipNextPirateRankPoints - возвращает количество очков пиратского рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько нужно всего):
	1 - корабль;
RaisePirateRank - повышает текущее пиратское звание корабля на плюс одно (сработает только если у корабля достаточно очков):
	1 - корабль;
ShipSkill - возвращает или устанавливает значение определённого навыка корабля:
	1 - корабль;
	2 - тип навыка:
	  Навыки для подстановки вторым аргументом (можно подставлять числом или строкой):
		'Accuracy' (0) - точность;
		'Mobility' (1) - манёвренность;
		'Technical' (2) - техника;
		'Trader' (3) - торговля;
		'Charm' (4) - обаяние;
		'Leadership' (5) - лидерство;
	  Только для запросов значения (подставлять только строкой):
		'AccuracyCur' - точность с учётом всех бонусов/штрафов;
		'MobilityCur' - манёвренность с учётом всех бонусов/штрафов;
		'TechnicalCur' - техника с учётом всех бонусов/штрафов;
		'TraderCur' - торговля с учётом всех бонусов/штрафов;
		'CharmCur' - обаяние с учётом всех бонусов/штрафов;
		'LeadershipCur' - лидерство с учётом всех бонусов/штрафов;
  Опционально:
	3 - какой уровень навыка установить;
  Примечание: При попытке установить уровень навыка выше 6, будет автоматически установлен уровень 6.
ShipFace - возвращает или устанавливает кораблю портрет (может быть -1):
	1 - корабль;
  Опционально:
	2 - номер портрета в списке числом, либо 'New', для принудительной реинициализации (в том числе уже инициализированного портрета), либо 'Path', чтобы вернуть путь портрета (также автоматически его инициализирует перед возвратом);
  Примечание: Если номер портрета установлен как -1, значит, портрет корабля ещё не инициализирован. Инициализация портрета произойдёт в момент, когда игрок первый раз его увидит, то есть первый раз просканирует, либо заговорит с кораблём.
ShipFreeExp - возвращает или устанавливает количество нераспределённого опыта корабля:
	1 - корабль;
  Опционально:
	2 - какое количество установить;
GetShipExpByType - возвращает количество заработанного опыта определённого типа:
	1 - корабль;
	2 - тип опыта:
	  0 - сумма всех типов (вообще всех);
	  1 - убийство доминаторов;
	  2 - убийство пиратов;
	  3 - прочие убийства;
	  4 - торговля;
ShipStatus - возвращает или устанавливает статус характера рейнджера (от 0 до 100):
	1 - корабль;
	2 - тип статуса;
  Опционально:
	3 - изменить данный статус (от 0 до 100) типы статусов:
	   0 - торговец;
	   1 - пират;
	   2 - воин;
RelationToRanger - возвращает или устанавливает отношение объекта к рейнджеру:
	1 - объект (корабль, станция или планета);
	2 - корабль рейнджера;
  Опционально:
	3 - какое отношение установить (от 0 до 100):
	   80-100 - отличное;
	   60-79 - хорошее;
	   30-59 - нормальное;
	   10-29 - плохое;
	   0-9 - враждебное;
  Примечание: Военные корабли не имеют своего собственного отношения к кораблям, так что выставлять им его бесполезно. Их отношение к кораблю наследуется от их родной планеты. Также не имеют своего отношения и все пиратские планеты (вернее имеют, но не используют до освобождения от пиратов), а потому наследуют его от Роджерии (для смены отношения всех пиратских планет, отношение нужно менять у Роджерии).
ConChangeRelationToRanger - меняет отношение к рейнджеру на всех планетах указанного сектора:
	1 - сектор;
	2 - корабль рейнджера;
	3 - на сколько изменить текущее отношение к рейнджеру (+20, -45 и т.д.);
  Примечание: Изменение отношения сработает только для коалиционных планет (если только не применить эту функцию для Тортугаца/Нифигаца), поскольку пиратские планеты наследуют отношение от Роджерии. Имейте в виду, что изменение отношения для пиратских планет все равно сработает, но увидеть это изменение игрок сможет только после их освобождения от пиратов.
GalaxyRangers - возвращает общее количество рейнджеров в Галактике, или конкретного рейнджера из их числа:
	Без аргументов - вернёт общее количество;
  Опционально:
	1 - номер рейнджера в списке (вернёт конкретного рейнджера);
ExtremalTakeOff - без аргументов, форсирует взлёт корабля игрока и сразу запускает следующий ход;
TruceBetweenShips - корабли мирятся:
	1 - первый корабль;
	2 - второй корабль;
ShipSetPartner - назначает кораблю напарника:
	1 - корабль-наёмник;
	2 - корабль-наниматель;
	3 - длительность контракта в днях (для разрыва деловых отношений просто подставить 0 во 2 и 3 аргументы);
ShipPartners - возвращает количество рейнджеров-партнёров у корабля, или конкретный корабль из этого списка:
	1 - корабль нанимателя (возвращает количество);
  Опционально:
	2 - номер партнёра в списке (возвращает корабль партнёра);
PlayerPirates - возвращает количество пиратов-партнёров у игрока:
	Без аргументов - возвращает количество пиратов-партнёров;
  Опционально:
	1 - номер партнёра в списке (возвращает корабль партнёра);
ShipIsPartner - проверяет, не находится ли корабль в подчинении у другого, возвращая корабль нанимателя, либо 0:
	1 - корабль;
  Примечание: Автоматический (!) наём партнёров и становление партнёром другого корабля не работает для скриптовых кораблей с несвободным поведением (любой стейт, кроме Free), а также для кораблей с наличием скриптового блока приказов OrderLock().
ShipInFear - проверяет, не находится ли корабль в данный момент в состоянии испуга:
	1 - корабль;
PirateType - возвращает подтип пирата:
	1 - корабль пирата:
	   0 - обычный не клановый (вольный) или странствующий клановый пират;
	 Далее идут подтипы клановых воинов, отличающихся лишь предпочтениями в эквипе и поведении:
	   1 - пират-танк (самый бронированный пират, принимает на себя урон);
	   2 - пират-снайпер (предпочитает дальнобойный пушки и держится на расстоянии);
	   3 - пират-шустрик (использует небольшой корпус ради скорости и предпочитает пушки с большим количеством накладываемых дебафов);
  Примечание: Сменить подтип пирата можно с помощью функции ShipSubType.
ShipCalcParam - заставляет корабль принудительно пересчитать все свои параметры (имеет смысл добавлять, например, после искусственного обвеса бота и перед запуском ShipFreeSpace, т.к. до обработки трюма корабля тёрн-кодом, он сам ещё пока не в курсе, что получил обвес):
	1 - корабль;
ShipFreeSpace - возвращает свободное место в трюме корабля (в том числе с отрицательным значением, если имеется перевес):
	1 - корабль;
ShipFreeFlight - разово запускает собственную классовую логику корабля (логика скриптового стейта в расчёт не принимается), позволяя ему выбрать свой план действий:
	1 - корабль;
  Примечание: Полезно, если ранее мы вмешались в его приказы, а сейчас нужно вновь вернуть корабль к самостоятельным действиям или просто узнать, что бы в текущей ситуации захотел сделать он сам. Также автоматически расставляет прицелы всех орудий корабля, поэтому последовательный запуск из стейткода ShipFreeFlight() и OrderNone() (любой приказ, в принципе), позволит вам получить корабль, автоматически стреляющий по мимо-астероидам и врагам, но выполняющий при этом все ваши приказы.
RangerPlaceInRating - место рейнджера в рейтинге рейнджеров:
	1 - рейнджер;
RangerExcludedFromRating - проверяет/изменяет статус рейнджера в едином списке рейнджеров:
	1 - рейнджер;
  Опционально:
	2 - добавить/исключить (0/1) рейнджера из единого рейтинга;


Доминаторы:
Blazer - без аргументов, возвращает Блазера (если он жив, иначе 0);
Keller - без аргументов, возвращает Келлера (если он жив, иначе 0);
Terron - без аргументов, возвращает Террона (если он жив, иначе 0);
HaveProgramm - проверяет есть ли у игрока определённая программа:
	1 - номер программы;
GetProgramm - возвращает количество программ определённого типа у игрока:
	1 - номер программы;
SetProgramm - устанавливает количество программ определённого типа у игрока:
	1 - номер программы;
	2 - количество;
DomikProgramm - применяет к кораблю доминатора указанную антидоминаторскую программу (программа будет активирована в тот же день):
	1 - корабль доминатора;
	2 - номер программы;
DomikProgrammDate - устанавливает длительность действия текущей активной программы на доминаторе (сперва необходимо применить к нему одну из программ):
	1 - корабль доминатора;
	2 - до какого числа должна действовать текущая активная программа;
	  Номера программ:
	    0 - progKellerCall - iКеллер;
	    1 - progLogicalNegation - Противодействие;
	    2 - progDematerial - Дематериализатор;
	    3 - progEnergotron - Энерготрон;
	    4 - progSabCrack - Сабмодем;
	    5 - progIntercom - Интерком;
	    6 - progShipwreck - Аварийный сигнал (не сработает при установке функцией DomikProgramm);
	    7 - progWeaponBlocking - W-Кодер;
	    8 - progInsanity - Гатрикс матрица;
	    9 - progShock - Шоккер-5300;
	    10 - progSelfDestruction - Абсолютное оружие (не сработает при установке функцией DomikProgramm, но имеет эффект идентичный ShipDestroy);
	    11 - progDisconnection - Системное отключение (бессрочная программа, доминатор выключается навсегда);
NoComeKlingToStar - проверяет, устанавливает или снимает запрет доминаторам атаковать конкретную систему (также блокирует всякую возможность захвата системы любой стороной!):
	1 - система;
  Опционально:
	2 - если значение больше 0, то запретить атаковать систему;
ShipDestroyType - уничтожает всех блазероидов в Галактике, создана специально для скрипта Блазера, чтобы быстро уничтожить все его корабли при использовании антидоминаторской программы:
	1 - маркер об уничтожении, должен быть равен 1;
  Примечание: Если вызвать данную функцию без аргумента, либо установить иное значение кроме единицы, то она выполнит перебор всех блазероидов в Галактике, но при этом не сделает с ними ничего. Потому что логика.
PlayerMayTakeSubCrack - без аргументов, проверяет, может ли игрок в данный момент купить сабмодем на ПБ;
SubCrackCost - без аргументов, возвращает текущую стоимость сабмодема;
TerronWeaponLock - без аргументов, отключает всё оружие Террона (результат срабатывания Сабмодема);
TerronGrowLock - без аргументов, отключает спавн новых доминаторов Террону;
TerronLandingLock - без аргументов, позволяет совершить посадку на Террона для проведения планетарного боя;
TerronToStar - без аргументов, отправляет Террона преобразовывать звезду;
KellerLeave - без аргументов, отправляет Келлера к клиссанам;
KellerNewResearch - без аргументов, Келлер сотрудничает с пиратами в новых исследованиях:
	1 - Id системы для исследований;
KellerKill - без аргументов, уничтожает Келлера в АБ;
BlazerLanding - приземляет Блазера для сотрудничества с Коалицией:
	1 - Id планеты;
BlazerSelfDestruction - без аргументов, Блазер самоуничтожается;
DomiksDefeated - проверяет, не побеждены ли доминаторы:
	Без аргументов - общая проверка, побеждены ли все доминаторы (0/1);
  Опционально:
	1 - вернёт тип победы над конкретным боссом:
		0 - Блазер:
		   0 - не побеждён;
		   1 - уничтожен в бою;
		   2 - самоуничтожился;
		   3 - сотрудничает с Коалицией;
		1 - Келлер:
		   0 - не побеждён;
		   1 - уничтожен программой или как-либо ещё в космосе;
		   2 - улетел к клисанам;
		   3 - изучает пиратов;
		2 - Террон:
		   0 - не побеждён;
		   1 - уничтожен в бою;
		   2 - преобразовывает звезду;
		   3 - побеждён в наземном бою;
CoalitionDefeated - проверяет, не была ли побеждена Коалиция, или изменяет этот статус:
	Без аргументов - вернёт текущий статус;
  Опционально:
	1 - какой статус установить (0 - Коалиция не побеждена, 1 - побеждена);
  Примечание: Пока жив хотя бы игрок с Коалиционным овнером, Коалиция не считается полностью уничтоженной, даже если систем у неё совсем не осталось.


Сообщения и тексты:
NewsAdd - добавляет новость (идентична функции Ether(0, '', 'text')):
	1 - текст новости;
MsgAdd - добавляет на панель заметок сообщение о переговорах между игроком и одним из кораблей указанной скриптовой группы:
	1 - текст сообщения;
	2 - номер группы, также проверяет, успешно ли выполнена операция, условия успеха:
	- В указанной группе есть корабль;
	- Корабль в той же системе, что игрок;
	- Игрок не в гиперпространстве;
Ether - добавляет сообщение определённого типа на панель уведомлений:
	1 - тип сообщения, подставлять числом:
	   0  - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
	   1  - mp_Ether, переговоры других кораблей между собой;
	   2  - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
	   3  - mp_Quest, задание в процессе (не удаляется игроком);
	   4  - mp_QuestOk, задание выполнено;
	   5  - mp_QuestCancel, задание провалено;
	   6  - mp_Tips, подсказка, как в обучении;
	   7  - mp_User, информация, которую игрок решил сохранить;
	   8  - mp_ShipMinus, что-то на корабле поломалось;
	   9  - mp_Storage, список вещей вне корабля (не удаляется игроком);
	   10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (имеют чуть другой оттенок);
	2 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
	3 - текст сообщения;
  Опционально:
	4, 5, 6 - корабли, станции или планеты, на которые будет происходить центровка камеры при клике на Ether;
  Примечание: Если передать 4, 5 или 6 аргументами 0, то Ether не будет обновлён, т.к. код не знает что в таком случае ему делать. Также не будут обновлены другие Ether, кроме квестовых (3), если цель в 4, 5 или 6 аргументах находится в другой системе.
CustomEther - добавляет сообщение определённого типа на панель заметок с изменённым изображением сообщения,
	1 - название кастомного изображения из папки 'Bm.MsgPlayer.';
	2 - тип сообщения, подставлять числом:
	   0  - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
	   1  - mp_Ether, переговоры других кораблей между собой;
	   2  - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
	   3  - mp_Quest, задание в процессе (не удаляется игроком);
	   4  - mp_QuestOk, задание выполнено;
	   5  - mp_QuestCancel, задание провалено;
	   6  - mp_Tips, подсказка, как в обучении;
	   7  - mp_User, информация, которую игрок решил сохранить;
	   8  - mp_ShipMinus, что-то на корабле поломалось;
	   9  - mp_Storage, список вещей вне корабля (не удаляется игроком);
	   10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (имеют чуть другой оттенок);
	3 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
	4 - текст сообщения;
  Опционально:
	5, 6, 7 - корабли, на которые будет происходить центровка при клике на Ether;
  Примечание: Если передать 4, 5 или 6 аргументами 0, то Ether не будет обновлён, т.к. код не знает что в таком случае ему делать. Также не будут обновлены другие Ether, кроме квестовых (3), если цель в 4, 5 или 6 аргументах находится в другой системе, либо же на планете, станции или в гипере.
EtherDelete - удаляет Ether по его идентификатору:
	1 - идентификатор строкой;
EtherIdAdd - добавляет в скрипт новый уникальный идентификатор сообщения:
	1 - идентификатор;
EtherIdDelete - удаляет из скрипта уникальный идентификатор:
	1 - идентификатор;
EtherState - возвращает тип сообщения по его идентификатору:
	1 - идентификатор уведомления (если сообщение с таким идентификатором отсутствует, вернёт -1):
	   0  - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
	   1  - mp_Ether, переговоры других кораблей между собой;
	   2  - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
	   3  - mp_Quest, задание в процессе (не удаляется игроком);
	   4  - mp_QuestOk, задание выполнено;
	   5  - mp_QuestCancel, задание провалено;
	   6  - mp_Tips, подсказка, как в обучении;
	   7  - mp_User, информация, которую игрок решил сохранить;
	   8  - mp_ShipMinus, что-то на корабле поломалось;
	   9  - mp_Storage, список вещей вне корабля (не удаляется игроком);
	   10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (имеют чуть другой оттенок);
Dialog - запустить разговор с игроком (работает только в космосе), для начала разговора необходимо указать как минимум корабль вызывающего игрока NPC:
	1 - корабль, который должен начать разговор с игроком (можно вызывать, в том числе, из акткода), либо название диалога (без кавычек, т.к. переменная, сработает только при вызове из конкретного скрипта);
  Опционально:
	2, 3, 4 ... - список потенциальных кораблей-собеседников с игроком, если первым аргументом был указан диалог;
  Примечание: Если вам необходимо инициировать диалог из акткода, используйте для указателя на конкретный диалог в скрипте глобальную переменную или данные предмета/инфошки. При таком варианте, в скрипте диалог нужно ловить как обычный диалог с кораблём в космосе, но с проверкой значения соответствующей переменной/данных.
SkipGreeting - без аргументов, отключает текст стандартного приветствия для скриптовых диалогов на базах/планетах/кораблях;
  Примечание: Полезно, если вам необходимо добавить туда свой собственный текст, например через AddDialogInject() или AddDialogOverride().
Tips - зеленые эзеры-подсказки (?);
TipsState - состояние подсказки, игра запоминает, какая уже выдавалась, какая - ещё нет (?);
DeleteTags - удаляет все тэги из строки, например тэги цветов:
	1 - исходная строка;
DChange - используется для перевода диалога на определённую реплику собеседника:
	1 - номер реплики собеседника DialogMsg (идентично прямому указателю стрелки на нужную реплику);
  Примечание: При использовании данной функции в коде, сразу после неё обычно подставляется оператор exit, чтобы прервать дальнейшее исполнение кода после смены реплики.
DText - отображает текст в текущем пустом диалоговом окне (вызывается из кода реплики DialogMsg):
	1 - текст;
DAddText - добавляет дополнительный текст в уже заполненное диалоговое окно (вызывается из кода реплики DialogMsg только после DText):
	1 - текст;
DAdd - добавляет ответ по его номеру в скриптовом диалоге:
	1 - номер ответа DialogAnswer (идентично прямому указателю стрелки на нужный ответ);
AddDialogInject - добавляет новые варианты ответа в стандартный стартовый диалог, добавляет в приветственную реплику собеседника нужный текст, удаляет из приветственной реплики собеседника весь стандартный (не трогая текста других инжектов) текст:
	1 - название диалога (в виде строки), который запустится при выборе данного ответа (можно добавлять диалог из другого скрипта*);
	2 - текст, который будет добавлен к приветственной реплике собеседника (если текст не нужен, просто оставьте здесь пустую строку '');
	3 - текст добавляемого варианта ответа;
	4 - приоритет (чем больше число, тем выше диалог в списке относительно других инжектов, стандартные ответы из игры приоритета не имеют вовсе);
  Опционально:
	5 - флаг (если больше 0), очищающий весь стандартный (игровой) приветственный текст;
	6 - значение, которое будет присвоено глобальной внутренней переменной GAnswerData (имеет тип dword);
InjectAnswer - добавляет ответ к скриптовому (!!!Сперва необходим AddDialogInject или диалоговый объект!!!) диалогу:
	1 - название диалога (в виде строки), который запустится при выборе данного ответа (можно добавлять диалог из другого скрипта*);
	2 - текст ответа;
	3 - значение, которое будет присвоено глобальной внутренней переменной GAnswerData (используется для передачи нужных значений или для определения, какой ответ был выбран, имеет тип dword);
  Функциональные диалоговые тэги для поля Name в ответах:
	block - блокирует указанный ответ, автоматически перекрашивая его в серый цвет;
	snap - при клике по указанному ответу, положение вертикального скролла в диалоге не изменится (полезно при создании меню опций, когда выбор ответа не переключает диалог);
	planet - ответ автоматически переводит игрока из диалога с планетарным правительством на общий экран планеты (исполняет прикреплённый код);
	shop - ответ автоматически переводит игрока в магазин оборудования, если он есть (исполняет прикреплённый код);
	goods - ответ автоматически переводит игрока в магазин товаров, если он есть (исполняет прикреплённый код);
	hangar - ответ автоматически переводит игрока в ангар, если он есть (исполняет прикреплённый код);
	takeoff - ответ инициирует взлёт корабля (исполняет прикреплённый код);
	restart - делает рестарт текущего диалога (исполняет прикреплённый код);
	exit - выходит из текущего диалога (исполняет прикреплённый код);
	fastexit - выходит из текущего диалога (не исполняет прикреплённый после себя код и добавляет крестик для быстрого закрытия скриптовых диалогов в космосе);
	  Примечание: В диалогах планет и станций fastexit не работает.
	<Object=adr,23,17,0> - при подстановке такого тэга в текст ответа, на его месте появится кнопка для центровки камеры на корабль-цель (актуально для диалогов в космосе), где:
	   adr - адрес корабля в памяти;
	   23,17,0 - прочие параметры отрисовки кнопки, как именно работают - неизвестно;
AddDialogOverride - заменяет стандартную стартовую реплику собеседника в диалоге на скриптовый диалог:
	1 - название диалога (в виде строки), которым будет заменён стандартный (можно добавлять диалог из другого скрипта*);
	2 - приоритет (имеет значение, если к стартовой реплике применяется сразу несколько таких операций, чтобы выбрать, какая конкретно будет выполнена);
  *Примечание: При подстановке имени диалога в функциях AddDialogInject(), InjectAnswer() и AddDialogOverride(), допустимо использовать строку вида 'Имя_скрипта:Имя_диалога' для подстановки в нужное место диалога из любого желаемого скрипта. Без указания имени скрипта будет выбран диалог из текущего.
DAnswer - функция добавления ответа, по умолчанию используемая компилятором в RScript:
	1 - текст добавляемого ответа;
  Примечание: Допускается добавлять к тексту ответа флаги типа restart, exit, hangar и т.д. Флаги добавляются прямо в текст, но с разделителем в виде ~ то есть запись ответа с флагом должна выглядеть примерно вот так DAnswer('restart~' + "Текст ответа"). Использовать данную функцию для добавления НЕ завершающих диалог реплик (то есть всех кроме restart и exit) неудобно, т.к. придётся вручную указывать номер следующего объекта, на который должен переводить ответ.
  DAnswer('main') - данная конструкция используется для создания стандартной "выходной" реплики в космическом диалоге. То есть сбросит диалог в самое начало, сохранив при этом последний текст ответа собеседника (подставлять в "Op" сразу после "выходной" реплики);
AddDialogBlock - ищет в вариантах ответа ответ с определённым текстом и на выбор удаляет или блокирует его:
	1 - текст ответа для поиска;
	2 - что сделать:
	   0 - вариант станет обычным (кликабильным);
	   1 - вариант станет серого цвета и будет некликабильным;
	   2 - вариант пропадёт;
  Примечание: Добавлять данный блок необходимо ДО подстановки блокируемого ответа, а не после.
TalkByAI - без аргументов, проверка, что диалог с игроком инициировал NPC (1 - да, 0 - нет);
  Примечание: Если вы "искусственно" инициируете разговор NPC с игроком посредством функции Dialog(NPC) (например, через акткод), то проверка TalkByAI будет возвращать 0.
GetTalkType - без аргументов, возвращает тип диалога с NPC (при вызове, исходящем от самого NPC) в космосе, варианты:
	0 - TalkMoney - корабль требует деньги;
	1 - TalkGoods - корабль требует груз;
	2 - TalkTruce - корабль предлагает перемирие;
	3 - TalkAttack - корабль предлагает совместную атаку;
	4 - TalkBreakPartner - партнёр разрывает контракт из-за плохого отношения к игроку или недостаточного рейтинга (в случае пиратов);
	5 - TalkPartnerTheEnd - вышел срок контракта;
	6 - TalkPartnerRiot - партнёр разрывает контракт, если по какой-то причине ведёт бой с другим партнёром игрока;
MessageBox - вызывает сообщение с кнопкой (как, например, при включении форсажа) может быть вызвана из диалога, стэйт кода или OnUseCode:
	1 - текст сообщения;
  Опционально:
	2 - флаг внешнего вида;
MessageBoxYesNo - вызывает сообщение с выбором да/нет (при выборе да возвращает 1, при нет 0):
	1 - текст сообщения;
  Опционально:
	2 - сет внешнего вида;
  Функции вывода сообщений могут визуально меняться в зависимости от суммы установленных флагов, ниже приведены значения, которые нужно суммировать во второй аргумент для получения той или иной комбинации визуального интерфейса сообщения (задать сет):
	1 - Ok - кнопка ОК (с галочкой);
	2 - Cancel - кнопка отмены (с крестиком);
	4 - IconInfo - бэкграунд с информационным сообщением (i) (как в большинстве месседжей);
	8 - IconWarning - бэкграунд с предупреждающим сообщением (!) (как на планетах с плохим отношением);
	16 - IconQuestion - бэкграунд с вопросительным сообщением (?) (как в стандартных месседжах вида YesNo);
	32 - IconError - бэкграунд с сообщением об ошибке (x) (как при попытке передвинуть корабль с нулевой скоростью);
	64 - AlignLeft - выравнивание текста по левому краю;
  По умолчанию (без флагов) выводятся стандартный информационный месседж с кнопкой отмены и стандартный вопросительный меседж YesNo с вопросительным сообщением.
CountBox - вызывает интерфейс с ползунком и выбором да/нет (как при выбросе товаров в космос или покупке\продаже товаров, при "Нет" возвращает 0, при "Да" - значение ползунка):
	1 - строка пути к изображению в CacheData.dat (например строка вида 'Bm.Items.2Minerals' добавит в интерфейс изображение минералов);
	2 - текст, отображаемый над счётчиком;
	3 - минимальное значение;
  Опционально:
	4 - максимальное значение;
	5 - цена за единицу, если !=0, то появится ещё и счётчик стоимости;
	6 - шаг изменения величины, по умолчанию 1 (опционально, но в любом случае не работает (видимо, пережиток из КР1, где шаг был кратен 5));
	7 - максимальное значение единиц, после которого блокируется утвердительный выбор;
	8 - максимальное значение единиц, после которого счётчик единиц становится красным;
	9 - максимальное значение кредитов, после которого счётчик кредитов становится красным;
	10 - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
NumberBox - аналогичен CountBox, однако все числовые аргументы и возвращаемое значение теперь dword вместо int, а отображаемый счётчик значения центрирован. Также кнопки увеличения и уменьшения значения счётчика NumberBox имеют свойство увеличивать и понижать скорость накрутки счётчика в зависимости от продолжительности нажатия:
	1 - путь к иконке, например: 'Bm.Items.2Minerals';
	2 - текст, отображаемый над счётчиком;
	3 - минимальное значение;
	4 - максимальное значение;
  Опционально:
	5 - максимальное разрешенное для выбора значение (при превышении утвердительный ответ блокируется и счётчик становится красным);
	6 - кастомная картинка полоски, на которой распологается счётчик (при добавлении этого аргумента, счётчик теряет центровку и принимает вид обычного счётчика из CountBox), оставлять пустой строкой '', если замена не требуется;
	7 - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
TextBox - вызывает интерфейс для ввода текста, возвращает строку с введённым текстом:
	1 - текст над полем ввода;
  Опционально:
	2 - предзаданный текст в поле ввода;
	3 - максимальное количество символов для ввода (по умолчанию 30, но можно установить и больше);
ListBox - вызывает блок со списком ответов, созданного из элементов указанного массива (будет брать значение элементов в виде str). После выбора конкретного варианта и нажатия "Да", возвращает индекс соответствующего элемента массива, а если был выбран ответ "Нет", то вернёт -1:
	1 - текст заголовка панели;
	2 - массив со строками, из которого будет сформирован список (начиная с элемента под индексом 0), либо первый вариант списка строкой;
  Опционально:
    3, 4, 5 и т.д. - прочие элементы списка в виде строк в случае, если 2 аргумент - не массив;


Функции для общей работы с различными объектами:
SetName - назначает имя кораблю или объекту:
	1 - корабль, планета, система или предмет;
	2 - строка нового имени;
Name - возвращает имя объекта:
	1 - объект:
	  - система;
	  - сектор;
	  - планета;
	  - корабль (вернёт полное имя);
	  - предмет (вернёт имя без приписок всяких бонусов);
ShortName - аналог Name, в случае если объект - корабль/станция, возвращает короткое имя (без приставки имени типа):
	1 - объект;
Id - возвращает Id любого объекта, имеющего Id:
	1 - объект;
ChangeGlobalRelationsShips - изменяет глобальное отношение кораблей к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта:
	1 - корабль рейнджера;
	2 - 0 (глобальное отношение) или некоторый объект (сектор, система, планета). В зависимости от указанного объекта ограничивает область применения;
	3 - тип изменения:
	   0 - снизить до определенного значения (не изменится, если уже ниже значения);
	   1 - повысить до определенного значения (аналогично);
	   2 - прибавить определенное значение;
	   3 - вычесть определенное значение;
	4 - само значение;
	5 - сет номерных типов кораблей:
	   1 - рейнджер;
	   2 - военный (военные корабли не хранят отношений к рейнджерам, так что в этом параметре нет смысла);
	   4 - пират;
	   8 - транспорт;
	   16 - лайнер;
	   32 - дипломат;
	6 - сет рас тех планет, общее отношение которых нужно вернуть (пример - общее отношение всех планет малоков и гаальцев будет равно 17):
	   1 - глобальное отношение всех малокских планет;
	   2 - глобальное отношение всех пеленгских планет;
	   4 - глобальное отношение всех человеческих планет;
	   8 - глобальное отношение всех фэянских планет;
	   16 - глобальное отношение всех гаальских планет;
	   31 - глобальное отношение планет всех рас Коалиции (1+2+4+8+16);
	   128 - глобальное отношение всех пиратских планет;
	   159 - глобальное отношение вообще всех заселённых свободных планет (1+2+4+8+16+128);
ChangeGlobalRelationsPlanets - изменяет глобальное отношение планет к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта:
	1 - корабль рейнджера;
	2 - 0 (глобальное отношение) или некоторый объект;
	3 - тип изменения:
	   0 - снизить до определенного значения;
	   1 - повысить до определенного значения;
	   2 - прибавить определенное значение;
	   3 - вычесть определенное значение;
	4 - само значение;
	5 - сет рас;
  Примечание: При переполнении 3-го параметра при повышении отношений (если > 100), фактическое отношение будет "нормальным", однако чтобы сделать "хорошее" или "отличное", его придется не повышать, а понижать.
GlobalRelationsShips - возвращает глобальное отношение кораблей к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта:
	1 - корабль рейнджера;
	2 - 0 (глобальное отношение) или некоторый объект;
	3 - сет номерных типов кораблей;
	4 - сет рас;
GlobalRelationsPlanets - возвращает глобальное отношение планет к рейнджеру, либо общее отношение в секторе, либо отношение у какого-то конкретного объекта:
	1 - корабль рейнджера;
	2 - 0 (глобальное отношение) или некоторый объект;
	3 - сет рас тех планет, общее отношение которых нужно вернуть (пример - общее отношение всех планет малоков и гаальцев будет равно 17):
	  1 - глобальное отношение всех малокских планет;
	  2 - глобальное отношение всех пеленгских планет;
	  4 - глобальное отношение всех человеческих планет;
	  8 - глобальное отношение всех фэянских планет;
	  16 - глобальное отношение всех гаальских планет;
	  31 - глобальное отношение планет всех рас Коалиции (1+2+4+8+16);
	  128 - глобальное отношение всех пиратских планет;
	  159 - глобальное отношение вообще всех заселённых свободных планет (1+2+4+8+16+128);
Dist - возвращает расстояние между двумя объектами в системе:
	1 - первый объект;
	2 - второй объект;
	  Возможные типы объектов:
	    - корабль/станция;
	    - ракета;
	    - астероид;
	    - предмет в космосе;
	    - планета;
		- звезда (указывается система и любой другой объект в её пределах, вернёт расстояние до самой звезды в центре);
	    - система (если оба указанных объекта системы, то вернёт дистанцию, а не парсеки);
	    - скриптовое место;
StarMissiles - возвращает количество ракет в системе, или конкретную ракету в ней:
	1 - система (вернёт количество);
  Опционально:
	2 - номер ракеты в списке ракет системы (вернёт ракету);
StarAsteroids - возвращает количество астероидов в системе, или конкретный астероид в ней:
	1 - система (вернёт количество);
  Опционально:
	2 - номер астероида в списке астероидов системы (вернёт указанный астероид);
CoordX - возвращает/устанавливает значение X координаты для указанного объекта:
	1 - объект, возможные типы:
	  - корабль/станция;
	  - ракета;
	  - астероид;
	  - предмет в космосе;
	  - планета;
	  - система (координаты звезды на галакарте);
	  - скриптовое место;
  Опционально:
	2 - новое значение X координаты;
CoordY - возвращает/устанавливает значение Y координаты для указанного объекта:
	1 - объект, возможные типы:
	  - корабль/станция;
	  - ракета;
	  - астероид;
	  - предмет в космосе;
	  - планета;
	  - система (координаты звезды на галакарте);
	  - скриптовое место;
  Опционально:
	2 - новое значение Y координаты;
ShipSetCoords - установить координаты корабля/станции (фактически может работать как мгновенный телепорт внутри системы):
	1 - корабль;
	2 - координата X;
	3 - координата Y;
  Примечание: Аналогично можно менять координаты и другим объектам, включая системы на галакарте (не точно), но для этого нужно пользоваться отдельными функциями CoordX и CoordY. Если изменить координаты корабля, находящегося на планете или станции, то в космос он не перенесётся, однако координаты местонахождения в системе изменит.
Angle - возвращает угол между двумя объектами по часовой стрелке, где юг, это нулевой угол (для перевода в обратную точку отсчёта необходима функция) в виде int:
	1 - первый объект;
	2 - второй объект;
  Примечание: Функция перевода возврата данной функции в обратную точку отсчёта:
	function DabToNormal(dword angle)
	{
		result = abs(angle - 180);
	}
ShipAngle - возвращает/устанавливает угол направления носа корабля по часовой стрелке (где север, это нулевой угол) в виде float (передавать можно и int):
	1 - корабль (или станция, если на неё установлена hai анимация);
  Опционально:
	2 - новый угол поворота в градусах (направит корабль в другую сторону);
ObjectType - возвращает тип указанного объекта:
	1 - объект:
	   0 - объект неопределим, либо функции был передан 0;
	   1 - звезда;
	   2 - ЧД;
	   3 - планета;
	   4 - станция;
	   5 - корабль;
	   6 - предмет;
	   7 - ракета;
	   8 - астероид;
AsteroidRespawn - респавнит (фактически, уничтожает без взрыва) указанный астероид:
	1 - астероид;
  Примечание: У каждой системы на всю игру имеется ограниченный набор астероидов. При уничтожении астероиды снова респавнятся на границе своей системы, не меняя визуальный скин до конца партии.
AsteroidMinerals - возвращает или устанавливает количество минералов в астероиде (возможный диапазон в одном астероиде 20-99):
	1 - астероид (вернёт значение);
  Опционально:
	2 - какое количество минералов установить (вернёт количество до изменения);
AsteroidGraph - возвращает или устанавливает внешний вид астероида:
	1 - астероид;
  Опционально:
	2 - путь к новой анимации астероида в Main.dat ('Data.SE');


Скриптовые объекты (скриптовые предметы):
	Примечание: Создаются в RScript, посредством объекта Item. Предмет в скриптовом объекте использовать намного удобнее, кроме того он получает полную защиту от авторасстрела NPC в космосе и не может быть по собственному желанию дропнут ими из трюма. В каждый скриптовый объект одновременно можно занести лишь один предмет.
ItemExist - проверяет, существует ли предмет в скриптовом объекте:
	1 - скриптовый объект (название без кавычек, т.к. это переменная);
ItemIn - проверяет, не находится ли предмет в скриптовом объекте в определённом месте:
	1 - скриптовый объект;
	2 - место:
	   - Конкретная система (предмет болтается в качестве лута в определённой системе);
	   - Конкретный корабль (предмет в трюме у определённого корабля);
	   - Конкретная планета (предмет находится на планете);
LinkItemToScript - занести предмет в скриптовый объект:
	1 - предмет;
	2 - скриптовый объект;
ReleaseItemFromScript - удалить предмет из скриптового объекта:
	1 - скриптовый объект;
ItemInScript - проверяет не занесён ли предмет в скриптовый объект:
	1 - предмет;
ScriptItemData - возвращает/устанавливает числовые данные для скриптового объекта (не для предмета в нём!):
	1 - скриптовый объект или предмет в нём;
	2 - номер переменной (1-3) для записи типа int (Data1, Data2, Data3);
  Опционально:
	3 - какое значение переменной установить;
ScriptItemTextData - возвращает/устанавливает текстовые данные для скриптового объекта (не для предмета в нём!):
	1 - скриптовый объект или предмет в нём;
	2 - номер переменной (1-3) для записи типа str (TextData1, TextData2, TextData3);
  Опционально:
	3 - какое значение переменной установить;
  Важно: (!!!) Скрипт автоматически не очищает данные скриптового объекта после релиза/удаления предмета, находящегося в нём. Так что в случае чего чистить все эти переменные необходимо вручную!
  Примечание: Значения данных переменных будут автоматически подставляться в описание скриптового предмета при наличии в нём тэгов <Data1>, <TextData1> и т.д. Это также работает и применительно к описаниям скриптового оборудования, однако добавить в него соответствующие тэги возможно только с помощью акринов.
ScriptItemToItem - возвращает непосредственно предмет, занесённый в скриптовый объект:
	1 - скриптовый объект;
DropScriptItem - заставляет корабль выбросить за борт предмет в скриптовом объекте:
	1 - корабль;
	2 - скриптовый объект или предмет в нём;
CanSellItem - проверяет/включает/отключает возможность продажи предмета в скриптовом объекте (по умолчанию продавать нельзя):
	1 - скриптовый объект или предмет в нём;
  Опционально:
	2 - установить/снять разрешение для продажи 0/1;
ItemOnActCode - возвращает строку OnActCode скриптового объекта (!!!) или устанавливает её (при установке старая строка акткода удаляется):
	1 - скриптовый объект или предмет в нём;
  Опционально:
	2 - строка с кодом, для установки объекту в качестве OnActCode (из данного акткода можно будет видеть и менять значения переменных в соответствующем скрипте);
ItemOnUseCode - возвращает строку OnUseCode скриптового объекта (!!!) или устанавливает её (при установке старая строка юзкода удаляется):
	1 - скриптовый объект или предмет в нём;
  Опционально:
	2 - строка с кодом, для установки объекту в качестве OnUseCode (из данного юзкода можно будет видеть и менять значения переменных в соответствующем скрипте);
 Примечание: Если строка берётся из раздела в Lang, то перед назначением предмету она должна быть предварительно сформирована функцией GenerateCodeStringFromBlock.


Предметы:
IdToItem - возвращает предмет по его Id (в том числе предмет, который находится в хранилище):
	1 - Id предмета;
ItemDestroy - уничтожает предмет в космосе:
	1 - предмет;
	2 - тип взрыва:
	   0 - не взрывать (отменяет уничтожение);
	   1 - обычный взрыв;
	   2 - взрыв как у бочки с горючим (урон по области есть, но дистанция от эпицентра взрыва никак не учитывается), также данный взрыв не сработает, если в предмет до взрыва попадёт ракета или торпеда;
	 Примечание: При выставлении второго аргумента в значение 2, взрыв "бочки" получит фиксированный урон в 800 единиц, а если значение будет выше, то взрыв получит урон, равный полученному в аргументе значению.
  Примечание: Помеченный на уничтожение предмет автоматически блокируется для подбора всеми NPC (но не игроком), так что, выставляя этот маркер на время, можно блокировать нежелательную "кражу" предмета ботами.
ItemCount - возвращает количество предметов указанного типа на корабле:
	1 - корабль;
	2 - тип предмета;
UselessItemCreate - создаёт Useless предмет и сразу же заносит его в скрипт (применяется только из кода скрипта):
	1 - системное название предмета строкой (список находится в 'Lang.dat/UselessItems');
	2 - название скриптового объекта, в который нужно поместить данный предмет;
	3 - скриптовое место, в котором появится данный предмет;
CreateQuestItem - создаёт UselessItem (ошмёток, квестовые предметы и прочие юзлесы):
	1 - системное название предмета строкой (список находится в 'Lang.dat/UselessItems');
  Опционально:
	2 - раса-производитель (по умолчанию устанавливается доминаторская);
UselessItemText - возвращает/устанавливает описание для UselessItem:
	1 - предмет;
  Опционально:
	2 - какое описание установить;
UselessItemData - возвращает/устанавливает значение внутренней int перемененной Useless предмета:
	1 - предмет;
	2 - номер переменной (от 1 до 3);
  Опционально:
	3 - какое значение переменной установить (при подстановке тэга вида <Data1> в описание данного предмета, игра автоматически подставляет в то место значение соответствующей переменной);
ShipItems - возвращает общее количество, или конкретный предмет из трюма:
	1 - корабль;
  Опционально:
	2 - номер предмета в списке предметов корабля (учтите, что под номером 0 всегда находится и всегда должен находиться корпус корабля);
ItemType - возвращает тип предмета:
	1 - предмет (список всех типов в конце документа);
ItemName - возвращает общее название предмета, например для любого двигателя вернёт строку 'Двигатель':
	1 - предмет;
ItemFullName - возвращает полное имя предмета, в том числе с установленным ММ:
	1 - предмет;
ItemSize - вернёт текущий размер предмета или задаст его:
	1 - предмет (вернёт размер);
  Опционально:
	2 - какой размер установить (вернёт размер до изменения);
ContainerFuel - возвращает/устанавливает количество топлива в баке/цистерне:
	1 - бак/цистерна;
  Опционально:
	2 - какое количество топлива установить;
ItemCharge - возвращает/устанавливает заряд для предметов с зарядом, например, для трансфакторных маяков:
	1 - предмет;
	2 - заряд, который необходимо установить;
ItemOwner - вернёт производителя предмета или установит его:
	1 - предмет (вернёт производителя);
  Опционально:
	2 - какого производителя установить (вернёт производителя до изменения):
	  0 или Maloc - малокский производитель;
	  1 или Peleng - пеленгский производитель;
	  2 или People - человеческий производитель;
	  3 или Fei - фэянский производитель;
	  4 или Gaal - гаальский производитель;
	  5 или Kling - доминаторский производитель;	  
	  6 или None - неизвестный производитель;
	  7 или PirateClan - пиратский производитель;
ItemSubrace - возвращает или устанавливает доминаторскую серию предмета:
	1 - предмет (вернёт серию);
  Опционально:
	2 - какую серию установить (вернёт серию до изменения):
	  0 - Блазер;
	  1 - Келлер;
	  2 - Террон;
  Примечание: На данный момент единственная функция для определения доминаторской серии корабля. Серия доминатора определяется по серии его корпуса.
EqCustomFaction - возвращает или устанавливает кастомную фракцию для любого предмета:
	1 - предмет;
  Опционально:
	2 - системное название фракции, которую надо установить предмету (иконка фракции будет взята из Data.Race.Emblem.2your_faction_name в мейне, аналогично её нужно будет прописать и для кэша, формат Png);
  Примечание: Если кастомная фракция была наложена на предмет с неизвестной расой, то все его базовые свойства (вроде совместимости с артефактами, ММ и акринами) будут отключены. Во всех остальных случаях (любая базовая раса кроме неизвестной), свойства предмета с кастомной фракцией отключены не будут. Также в параметр Owner у ММ и акринов можно прописывать название кастомной фракции, с предметами которой данный бонус станет совместим вне зависимости от базовой расы предмета.
ItemCost - вернёт текущую цену предмета или установит её:
	1 - предмет (вернёт стоимость);
  Опционально:
	2 - какую цену установить (вернёт стоимость до изменения);
ItemIsInUse - проверяет, надет ли предмет на корабль/станцию, либо надевает его:
	1 - предмет;
  Опционально:
	2 - корабль (вернёт номер слота в котором установлен предмет, что актуально для оружия (1-5) и артефактов (1-4), а для всех прочих предметов будет всегда  возвращать 1);
	3 - 0/1 снять/надеть указанный предмет;
	4 - номер слота, в который нужно экипировать предмет (актуально для оружия (1-5) и артефактов (1-4), также можно (но не обязательно) подставлять 1 для всех прочих типов предметов);
  Примечание: Надевать можно не только оборудование, но и, например, UselessItem, который пропадёт из трюма, но останется висеть на корабле в "невидимом" состоянии. Таким образом можно полностью скрывать присутствие на корабле определённых вещей. Правда, для сокрытия счетчика занятого в трюме места придётся также прибегнуть к несколько большим ухищрениям с подменой самого счетчика на кастомный Label.
ItemIsInSet - проверит используется ли предмет в любом из сетов:
	1 - предмет;
  Опционально:
	2 - к какому сету прикрепить предмет;
PlayerEqSet - возвращает текущий активный сет:
	Без аргументов - вернёт номер активного сета;
  Опционально:
	1 - номер конкретного сета для получения информации по нему:
	   0 - если такого сета ещё нет;
	   1 - если сет есть, но он не активен;
	   2 - если сет есть, и именно он сейчас активен;
HullType - возвращает или устанавливает тип указанного корпуса:
	1 - сам корпус или корабль его использующий;
  Опционально:
	2 - какой тип установить:
	   0 - корпус рейнджера;
	   1 - корпус военного;
	   2 - корпус пирата;
	   3 - корпус транспорта;
	   4 - корпус лайнера;
	   5 - корпус дипломата;
	 Вероятно, приведут к крашу (не приведут, если сразу после создания наложить на них акрин):
	   6 - корпус доминатора (все резисты всегда по 100%, что может быть полезно при создании своего акринового корпуса);
	   7 - корпус транклюкатора;
	   8 - корпус станции;
	   9 - корпус с любым акрином (внутренний тип, автоматически подставляется любому стандартному корпусу при его акринации);
	   10 - корпус флагмана (а этот к крашу не приведёт, однако в оригинальной игре таким корпусам не хватает "складских" пикч);
CreateHull - создаёт стандартный корпус и возвращает на него ссылку:
	1 - тип корпуса;
	2 - размер;
	3 - ТУ;
	4 - раса-производитель;
  Опционально:
	5 - номер серии (без серии: -1);
	6 - флаг (0/1) о том, что корпус нужно считать клановым (появится символ клановой эмблемы с цветом расы-производителя);
SeriesCount - без аргументов, возвращает общее число доступных корпусных серий;
FindSeriesByName - поиск номера серии по её имени:
	1 - имя нужной серии;
HullSeries - возвращает (при неудаче -1) или устанавливает серию корпуса:
	1 - корпус;
  Опционально:
	2 - номер серии, которую нужно установить (-1 - снять серию);
SeriesNumInCfg - возвращает раздел Lang, в котором прописана определённая серия:
	1 - номер серии (при несуществующем номере серии вернёт '');
CreateEquipment - создаёт оборудование/оружие (только оригинальное) или цистерну (но не корпус!), и возвращает указатель:
	1 - тип оборудования/оружия (полный перечень в конце списка);
	2 - размер оборудования;
	3 - технологический уровень (или текущее количество топлива для цистерны, если создаёте цистерну);
	4 - раса-производитель;
CreateEquipmentWithSpecial - создаёт оборудование/оружие (только оригинальное) с указанным акрином, при этом тип создаваемого оборудования будет автоматически взят из раздела акрина в Lang (если акрин может висеть на нескольких типах оборудования, выбирается случайный тип из этого списка):
	1 - номер бонуса (при подстановке бонуса, рассчитанного только для кастомных орудий, вернёт 0);
	2 - размер оборудования;
	3 - технологический уровень;
	4 - раса-производитель;
  Примечание: Данная функция используется для упрощения создания оборудования с произвольным акрином, без необходимости перебирать типы пригодного для акринации оборудования функцией MayAddBonusToEq.
GetEquipmentStats - возвращает определённый параметр предмета:
	1 - предмет;
	2 - параметр:
	   Доступные для запроса параметры:
		 Корпус:
		    0 - броня;
		    1 - количество открытых слотов под оружие;
		    2 - количество открытых слотов под артефакты;
		    3 - имеется ли слот радара;
		    4 - имеется ли слот сканера;
		    5 - имеется ли слот дроида;
		    6 - имеется ли слот захвата;
		    7 - имеется ли слот ГЗП;
		    8 - имеется ли форсаж (слоты возвращаются с учётом всех применённых к корпусу бонусов и его серии);
		 Оружие:
		    0 - максимальный урон;
		    1 - минимальный урон;
		    2 - дальность;
		    3 - базовый тип урона (0 - энергетический, 1 - осколочный, 2 - ракетный);
		    4 - количество выстрелов за ход;
		    5 - количество залпов (например, ракет) в выстреле;
		    6 - полный дамагсет с учётом всех бонусов;
		 Двигатель:
		    0 - скорость;
			1 - дальность прыжка;
		 Топливный бак:
		    0 - ёмкость;
			1 - текущее количество топлива;
		 Радар:
		    0 - дальность;
		 Сканер:
		    0 - мощность;
		 Дроид:
		    0 - эффективность ремонта;
		 Захват:
		    0 - размер захватываемых объектов;
			1 - дальность захвата;
			2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
			3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
		 Генератор защитного поля (ГЗП):
		    0 - процент поглощения урона;
		 Исследовательский зонд:
		    0 - вода;
		    1 - равнина;
		    2 - горы;
		    3 - надёжность (Fragility) зонда в виде float;
		 Цистерна:
		    0 - ёмкость;
			1 - текущее количество топлива;
		  Примечание: При указании в запросе номера параметра, которого у предмета нет (к примеру, запросить 1 для радара), будет возвращён 0. Также имейте в виду, что указанные в карточке N + X значения параметра при установленном ММ, данная функция вернёт уже в просуммированном виде. Для корректного выделения значения параметра, полученного от ММ, ММ перед проверкой необходимо будет извлечь.
	Альтернативный вид запроса GetEquipmentStats - запрос статов предмета в виде готовой строки с целью подстановки куда-либо. При передаче данной функции строки в качестве второго аргумента, все перечисленные ниже тэги в передаваемой строке, будут заменены на соответствующие параметры. Возвратом функции в таком случае будет являться переданная строка с автоматически произведённой заменой всех указанных тэгов:
		 Корпус:
		   '<FragilityE>' - восприимчивость к энергетическому урону;
		   '<FragilityS>' - восприимчивость к осколочному урону;
		   '<FragilityM>' - восприимчивость к ракетному урону;
		   '<HitProtect>' - броня;
		 Оружие:
		   '<MaxDamage><Bonus>' - максимальный урон (<Bonus> добавляет значения бонусов от ММ и акринов и подставляется отдельно от основного тэга только для урона);
		   '<MinDamage>' - минимальный урон (тэг <Bonus> может быть также подставлен и сюда, но зачем?);
		   '<Radius>' - дальность;
		   '<CntAttacks>' - количество выстрелов за ход;
		   '<CntShots>' - количество залпов (например, ракет) в выстреле;
		   '<Count>' - текущее число зарядов в оружии;
		   '<MaxCount>' - максимальное число зарядов в оружии;
		 Двигатель:
		   '<Speed>' - скорость;
		   '<Parsec>' - дальность прыжка;
		 Топливный бак:
		   '<Capacity>' - ёмкость;
		 Радар:
		   '<Radius>' - дальность;
		 Сканер:
		   '<Percent>' - мощность;
		 Дроид:
		   '<RecoverHitPoints>' - эффективность ремонта;
		 Захват:
		   '<PickUpSize>' - размер захватываемых объектов;
		   '<Radius>' - дальность захвата;
		   '<SpeedMin>' - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
		   '<SpeedMax>' - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
		 Генератор защитного поля (ГЗП):
		   '<Percent>' - процент поглощения урона;
SetEquipmentStats - по аналогии с GetEquipmentStats, устанавливает значения параметрам предмета:
	1 - предмет;
	2 - новое значение;
	3 - параметр (!!!Обратите внимание, что очерёдность аргументов здесь дебильная!!!):
	  Доступные для изменения параметры:
		 Корпус:
		    0 - броня;
		 Оружие:
		    0 - максимальный урон;
		    1 - минимальный урон;
		    2 - дальность;
		 Двигатель:
		    0 - скорость;
			1 - дальность прыжка;
		 Топливный бак:
		    0 - ёмкость;
			1 - текущее количество топлива;
		 Радар:
		    0 - дальность;
		 Сканер:
		    0 - мощность;
		 Дроид:
		    0 - эффективность ремонта;
		 Захват:
		    0 - размер захватываемых объектов;
			1 - дальность;
			2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
			3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
		 Генератор защитного поля (ГЗП):
		    0 - процент поглощения урона;
		 Исследовательский зонд:
		    0 - вода;
			1 - равнина;
			2 - горы;
			3 - надёжность (Fragility) зонда в виде float;
		 Цистерна:
		    0 - ёмкость;
			1 - текущее количество топлива;
		  Примечание: При указании в запросе номера параметра, которого у предмета нет/не доступен для изменения (к примеру, попытаться установить 3 для оружия), параметр изменён не будет.
	Примечание: Если значение параметра не равно базовым статам для текущего ТУ данного типа предмета (с учётом вставленных ММ), то такой предмет будет считаться улучшенным.
EquipmentImageName - возвращает или изменяет системное имя (из Lang), а попутно и картинку предмета, работает с предметами или кораблём транклюкатора, для кастомных артефактов меняет тип артефакта:
	1 - предмет;
  Опционально:
	2 - новое системное имя;
DropItemInSystem - выбрасывает (не обязательно из трюма или из хранилища) предмет в космосе в определённой системе по определённым координатам:
	1 - система;
	2 - предмет;
	3 - начальная X координата (точка появления предмета, откуда он начнёт движение);
	4 - начальная Y координата;
	5 - конечная X координата (точка завершения движения предмета, место, где он остановится);
	6 - конечная Y координата;
StopMovingItem - останавливает движущийся по системе предмет:
	1 - система;
	2 - предмет (желательно использовать сразу после DropItemInSystem (если последняя не была задействована из акткода), чтобы предмет появился в своих конечных координатах сразу, а не с началом расчёта хода);
StarItems - возвращает количество лута в системе, или конкретный предмет из списка лута:
	1 - система;
  Опционально:
	2 - номер предмета из списка лута;
StorageItems - возвращает количество предметов на складе (общего для всех планет и баз в Галактике) или конкретный предмет:
	Без аргумента - возвращает количество предметов;
  Опционально:
	1 - номер предмета в списке (возвращает предмет);
StorageItemLocation - возвращает местоположение предмета на складе (планету или базу):
	1 - номер предмета в списке предметов склада;
ShopItems - возвращает количество предметов в магазине оборудования или конкретный предмет из этого списка:
	1 - магазин (планета или станция);
  Опционально:
	2 - номер предмета в списке;
PlanetItems - возвращает количество предметов на поверхности планеты или конкретный предмет из этого списка:
	1 - планета (возвращает количество);
  Опционально:
	2 - номер предмета в списке (возвращает предмет);
CreateZond - создаёт зонд и возвращает на него ссылку:
	1 - ТУ (в оригинале от 0 до 5, в моде EvoSB до 7);
	2 - раса-производитель;
  Опционально:
	3 - скорость исследования воды;
	4 - скорость исследования равнин;
	5 - скорость исследования гор;
  По умолчанию берёт базовые характеристики из Lang с 20% шансом на +1 к одной случайной (20% вода, 20% равнины и 20% горы), и с 40% шансом не выдать доп. стат вовсе.
  В оригинале, обновление продающегося на станции зонда может происходить хоть каждый день с шансом 1 к 17.
ExistingZonds - без аргумента возвращает общее количество зондов у игрока:
	1 - возвращает зонд по номеру (начиная с 0), если он в данный момент работает на планете, а все нерабочие зонды всегда будут в конце "списка" с возвратом 0;
	2 - маркер (если больше 0), для возврата планеты, на которой сейчас работает зонд (если он работает);
CreateCustomCountableItem - создаёт кастомный сыпучий (разделяемый) предмет:
	1 - системное имя предмета из Lang строкой;
	2 - количество (используемые номера картинок сыпучего предмета):
	   0 - при размере стака до 999 единиц;
	   1 - при размере стака от 1000 до 1999 единиц;
	   2 - при размере стака от 2000 до 3999 единиц;
	   3 - при размере стака от 4000 до 7999 единиц;
	   4 - при размере стака от 8000 единиц и выше;
  Опционально:
	3 - анимация в космосе, если предмет будет добавляться непосредственно туда;
AddItemToShop - добавляет предмет в магазин:
	1 - магазин (планета или станция);
	2 - предмет (по умолчанию работает только для оборудования, но можно добавить графических ресурсов для отображения в магазине любого другого предмета):
	  Принцип определения фона под предметом (с изображением уровней) работает следующим образом. Игра проверяет тип предмета, и составляет строку вида '2SlotCargoHook_4' - где последняя цифра - это ТУ оборудования, либо, например, '2ArtRadar' для любых предметов, у которых уровней нет. Если по данному имени игра найдёт графику в папке FormShop2, то подставит соответствующий фон, иначе подставит стандартный фон с уровнем для любого оборудования, и фон по имени '2SlotArtefact' для любого артефакта (в т.ч. любого кастомного). Для всех прочих предметов по умолчанию будет взят фон '2SlotLevel0'.
	Список возможных названий фона:
	  '2SlotFood' - еда;
	  '2SlotMedicine' - медикаменты;
	  '2SlotTechnics' - техника;
	  '2SlotLuxury' - роскошь;
	  '2SlotMinerals' - минералы;
	  '2SlotAlcohol' - алкоголь;
	  '2SlotArms' - оружие;
	  '2SlotNarcotics' - наркотики;
     Примечание: Попытка добавить товары в магазин оборудования, скорее всего, приведёт к крашу.
      '2SlotHull_N' - корпус с номером уровня;
	  '2SlotFuelTanks_N' - топливный бак с номером уровня;
	  '2SlotEngine_N' - двигатель с номером уровня;
	  '2SlotRadar_N' - радар с номером уровня;
	  '2SlotScaner_N' - сканер с номером уровня;
	  '2SlotRepairRobot_N' - дроид с номером уровня;
      '2SlotCargoHook_N' - захват с номером уровня;
	  '2SlotDefGenerator_N' - ГЗП с номером уровня;
	  '2SlotWeapon_N' - любое оружие (в т.ч. кастомное) с номером уровня;
      '2SlotArtHull', '2SlotArtFuel', '2SlotArtSpeed', '2SlotArtPower', '2SlotArtRadar', '2SlotArtScaner', '2SlotArtDroid', '2SlotArtNano', '2SlotArtHook', '2SlotArtDef', '2SlotArtAnalyzer', '2SlotArtMiniExpl', '2SlotArtAntigrav', '2SlotArtTransmitter', '2SlotArtBomb', '2SlotArtTranclucator', '2SlotArtDefToEnergy', '2SlotArtEnergyPulse', '2SlotArtEnergyDef', '2SlotArtSplinter', '2SlotArtDecelerate', '2SlotArtMissileDef', '2SlotArtForsage', '2SlotArtWeaponToSpeed', '2SlotArtGiperJump', '2SlotArtBlackHole', '2SlotArtDefToArms1', '2SlotArtDefToArms2', '2SlotArtArtefactor', '2SlotArtBio', '2SlotArtPDTurret', '2SlotArtFastRacks' - индивидуальные типы оригинальных артефактов, расшифровка имён внизу списка функций;
	  '2SlotArtefact' - любой кастомный артефакт, либо оригинальный артефакт без индивидуального фона;
	  '2SlotUselessItem' - любой квестовый (не имеющий базовых свойств) предмет;
      '2SlotUselessCountableItem' - квестовый сыпучий (разделяемый);
	    Примечание: Для всех предметов, имеющий системное имя типа в Lang (артефакты, юзлесы и т.д.), возможно добавление индивидуальной иконки фона по её имени (пример: '2SlotYourArtName'), которая будет считаться приоритетной по отношению к иконке общего типа данного предмета.
	  '2SlotNod_1' - ММ третьего уровня;
	  '2SlotNod_2' - ММ второго уровня;
	  '2SlotNod_3' - ММ первого уровня;
	  '2SlotYourGraphName_1' - ММ третьего уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
	  '2SlotYourGraphName_2' - ММ второго уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
	  '2SlotYourGraphName_3' - ММ первого уровня с кастомной графикой (параметр KindGraph) 'YourGraphName';
      '2SlotProtoplasm' - ноды;
	  '2SlotCistern' - цистерна;
	  '2SlotSatellite' - зонд;
	  '2SlotTreasureMap' - карта сокровищ;
GetItemFromShop - изымает предмет из магазина (возвращает указатель на изъятый предмет):
	1 - магазин (планета или база);
	2 - сам предмет или номер предмета в списке предметов магазина;
AddItemToShip - добавляет предмет в трюм корабля:
	1 - корабль;
	2 - предмет;
FindItemInShip - ищет определённый предмет/артефакт на корабле, и при успехе возвращает его номер (при неудаче вернёт -1) в списке предметов/артефактов корабля:
	1 - корабль;
	2 - предмет;
GetItemFromShip - изымает предмет из трюма корабля (возвращает указатель на изъятый предмет):
	1 - корабль;
	2 - сам предмет или номер предмета в списке предметов корабля;
GetArtFromShip - аналогично GetItemFromShip, но изымает артефакт из трюма корабля, т.к. все артефакты хранятся на корабле отдельным списком (возвращает указатель на изъятый артефакт):
	1 - корабль;
	2 - сам артефакт или номер артефакта в списке артефактов корабля;
AddItemToPlanet - добавляет предмет на поверхность незаселённой планеты (может добавить и на заселённую, однако смысла в этом нет):
	1 - планета;
	2 - предмет;
  Примечание: При добавлении предмета на ещё не полностью исследованную (либо на полностью неисследованную) незаселённую планету он будет автоматически спрятан где-то в неисследованных территориях. При добавлении же предмета на полностью исследованную незаселенную планету, она обнулит свой статус и вновь станет полностью неисследованной, а предмет будет спрятан на ней как обычно.
GetItemFromPlanet - изымает предмет с поверхности планеты (возвращает указатель на изъятый предмет):
	1 - планета;
	2 - номер предмета в списке предметов планеты;
GetItemFromStar - изымает предмет, валяющийся в качестве лута в открытом космосе в определённой системе (возвращает указатель на изъятый предмет):
	1 - система;
	2 - сам предмет или номер предмета в списке предметов системы;
AddItemToStorage - добавляет предмет на склад:
	1 - склад (планета или станция);
	2 - предмет;
FindItemInStorage - возвращает номер предмета в списке предметов хранилища (вернёт -1, если предмета на складе нет):
	1 - предмет;
GetItemFromStorage - изымает предмет со склада (возвращает указатель на изъятый предмет):
	1 - номер предмета в списке склада игрока (склад игрока это единый массив, где каждому предмету дополнительно присвоено его конкретное местонахождение (планета или станция));
PutItemInVault - помещает предмет в невидимое хранилище:
	1 - строковая метка, которая будет обозначать переносимый в хранилище предмет (удобно указывать Id предмета, можно вместе с контрольным словом);
	2 - предмет (если предмет на складе или в трюме, необходимо сперва его извлечь);
  Примечание: Если по определённой строковой метке в хранилище уже лежит какой-то предмет, то при занесении нового старый предмет будет автоматически удалён.
GetItemFromVault - изымает предмет из невидимого хранилища (возвращает указатель на изъятый предмет):
	1 - строковая метка, обозначающая конкретный предмет в хранилище;
FreeItem - удаляет предмет из игры:
	1 - предмет;
  Важно: Нельзя удалить предмет сразу из трюма, с планеты, из космоса и т.д., для начала его нужно оттуда изъять, для чего существуют специальные вышеописанные функции типа Get.
FormShipCurItem - позволяет взаимодействовать с предметом, находящимся "в руке" (поднятом):
	Без аргументов - вернёт предмет в руке игрока;
  Опционально:
	1 - тип проверки или действия с предметом в руке:
	  0 или 'MoveType' - вернёт тип того, что находится в руке:
	     0 - ничего;
		 1 - сыпучий предмет (в т.ч. товары);
		 2 - простой предмет;
		 3 - артефакт;
	  1 или 'StackableType' - вернёт конкретный тип сыпучего предмета (для товара взятого из трюма предмет не существует, поэтому чекнуть можно только так);
	  2 или 'StackableCount' - вернёт количество сыпучего предмета, находящегося в руке;
	  3 или 'StackableCost' - вернёт цену сыпучего предмета, находящегося в руке;
	  4 или 'PutBack' - не вернёт ничего, но положит предмет из руки на место;
	  5 или 'Destroy' - не вернёт ничего, но уничтожит предмет в руке (уничтожить через FreeItem его в данный момент нельзя);
	  6 или 'Detach' - уберёт предмет из руки, но не вернёт его на корабль. Возвращает ссылку на убранный из руки предмет, если это возможно (например, товары в трюме не являются предметом);
ArrangeItems - заставляет корабль проинспектировать своё оборудование и предметы в трюме (к примеру, чтобы он сразу надел/продал/выбросил выданный ему предмет):
	1 - корабль;
CustomWeaponType - возвращает строковый тип кастомного оружия (для оригинальных типов орудий будет возвращать ''):
	1 - кастомное оружие в виде предмета;
CustomWeaponTypes - возвращает общее количество существующих в Галактике (объявленных) кастомных орудий:
	1 - номер орудия в списке, вернёт строковый кастомный тип;
GetCustomWeaponPrimaryDamageType - возвращает базовый тип урона для указанного типа кастомного или оригинального (!) оружия:
	1 - тип кастомного оружия (для получения типа урона оригинального оружия, необходимо подставлять сюда его числовой тип в виде int, а для кастомного - строчный в виде str);
	  Типы урона:
	    0 - энергетический;
	    1 - осколочный;
	    2 - ракетный;
GetCustomWeaponData - возвращает различные параметры для конкретного типа кастомного или оригинального (!) оружия:
  1 - тип оружия (для получения информации об оригинальном оружии, необходимо подставлять сюда его числовой тип в виде int, а для кастомного - строчный в виде str);
  2 - запрашиваемый параметр:
	'TechLevel' - технологический уровень оружия;
	'AverageSize' - средний размер;
	'AverageRadius' - средний радиус;
	'SecondaryDamageRadius' - радиус сплеша (актуально для орудий с типом выстрела Splash или Exploder);
	'MissileRadius' - ракетный радиус (у ракетных орудий максимальную дальность наведения орудия по умолчанию определяет именно он);
	'MaxDamage' - максимальный урон;
	'MinDamage' - минимальный урон;
	'kCost' - ценовой коэффициент (определяет стоимость);
	'ShotType' - тип выстрела:
	   'Normal' - обычная стрельба по одиночной цели;
	   'Splash' - попадание также наносит урон по области вокруг основной цели;
	   'Chain' - цепная атака, как у Волнового фазера;
	   'Exploder' - цепная реакция в случае уничтожения цели, как у Турбогравира;
	   'AreaDamage' - атака по области вокруг корабля, как у Вертикса;
	   'Rocket' - обычная ракета (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Rocket3);
	   'Missile' - ракета, имеющая сплеш (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Missile3);
	   'Torpedo' - обычная торпеда;
	'DamageType' - стандартный дамагсет для указанного типа оружия;
	'AttackCount' - число залпов за ход;
	'ShotCount' - число выстрелов/ракет в залпе (или количество целей, например, для волнового фазера);
	'Availability' - возвращает тип магазинов, в которых можно приобрести это оружие:
	   'Free' - оружие продаётся в любых магазинах (коалиционных или пиратских);
	   'CoalitionOnly' - только на планетах/станциях Коалиции;
	   'PirateOnly' - только на пиратских планетах/станциях;
	   'MalocOnly' - только на малокских планетах/станциях;
	   'PelengOnly' - только на пеленгских планетах/станциях;
	   'PeopleOnly' - только на человеческих планетах/станциях;
	   'FeiOnly' - только на фэянских планетах/станциях;
	   'GaalOnly' - только на гаальских планетах/станциях;
	   'NotSold' - это оружие нельзя купить в магазинах;
	   'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
GetCustomWeaponInfo - возвращает указатель на раздел со статами кастомной пушки:
	1 - имя типа кастомного оружия;
CreateCustomWeapon - создать кастомное оружие:
	1 - тип кастомного оружия;
	2 - размер;
	3 - технологический уровень;
	4 - раса-производитель;
InventNewCustomWeapon - создаёт новый тип оружия с указанным именем и прописывает его в сейве, возвращает указатель на него:
	1 - имя;
  Опционально:
	2 - тип базовой пушки с которой будут изначально скопированы статы (по умолчанию - пром. лазер);
SetCustomWeaponShotData - устанавливает тип выстрела кастомной пушки:
	1 - раздел кастомного оружия;
	2 - тип выстрела (строка: 'Normal', 'Splash', 'Exploder', 'AreaDamage', 'Torpedo', 'Missile', 'Rocket', 'Chain') если в залпе больше 1 выстрела, то можно увеличить число (например 'Rocket3' (не работает для торпед));
  Опционально:
	3 - скорость произведения выстрела (от 0 до 100, где 0 - скорость Ракетомёта и Лирекрона, а 100 - скорость Турбогравира);
	4 - средний радиус;
	5 - вторичный средний радиус (радиус сплеша);
	6 - сколько руды останется после выстрела по астероиду;
	7 - число выстрелов за ход;
  Примечание: Параметр скорости выстрела можно установить сколь угодно высоким, однако после наложения всех возможных бонусов, фактическая скорость выстрела будет всё равно рассчитана из диапазона 0-100. Значения скорости выше сотни имеет смысл устанавливать лишь для снижения отрицательных эффектов бонусов, влияющих на скорость.
SetCustomWeaponDamageData - устанавливает параметры урона кастомной пушки:
	1 - раздел кастомного оружия;
	2 - минимальный урон;
	3 - максимальный урон;
	4 - дамагсет в виде числа, либо строки, аналогичной оригинальному виду: 'Splinter,Acid,NoDelta' (без пробелов и с учётом регистра);
  Опционально:
	5 - первый аргумент float из списка, либо сразу целая строка вида: '1.00,1.10,1.15,1.20,1.25,1.30,1.35,1.40' без пробелов (все уровни указывать не обязательно);
	6, 7, 8, 9, 10, 11, 12 - прочие параметры mWeaponDamage в виде float (по одному аргументу на уровень, подставлять все 8 также не обязательно);
SetCustomMissileWeaponStats - устанавливает статы ракеты/торпеды для кастомного оружия ракетного типа:
	1 - раздел кастомного оружия;
	2 - радиус ракеты;
	3 - максимальная скорость;
	4 - минимальная скорость;
	5 - шанс на сбитие ракеты при выстреле по ней (от 0 до 100);
SetCustomWeaponPrimaryData - устанавливает данные о продаже кастомного оружия:
	1 - раздел кастомного оружия;
	2 - ГТУ разблокировки возможности использования/починки и начала появления пушки в магазинах (в магазинах планет начинает появляться по достижении самой планетой указанного в аргументе ТУ);
	3 - номер ванильного орудия, технологический уровень которого будет наследован для повышения ТУ данной кастомной пушки на планетах;
	  Примечание: А конкретно, насколько рано начнут повышаться ТУ кастомной пушки в магазинах.
	  У каждого оригинального оружия для этого имеется свой индивидуальный технический планетарный проект, который открывается для изучения планетой не раньше, чем открывается для покупки базовое орудие без повышенных уровней ТУ (A, B, C и т.д.). Далее, получив необходимый уровень ПТУ, планета может начать изучать проект определённого оружия, что в итоге приведёт к повышению технического уровня данного орудия при его продаже на конкретной планете. Поскольку у кастомного оружия индивидуального планетарного проекта нет, проект будет наследован ею от проекта указанной в данном аргументе оригинальной пушки и, следовательно, уровень ТУ кастомного орудия будет повышен на конкретной планете одновременно с уровнем родительской оригинальной пушки.
	4 - номер ванильного орудия, эффект которого будет наследован кастомной пушкой в АБ;
  Примечание: В третьем аргументе необходимо указывать оригинальный тип, т.к. планеты не могут изучать кастомное оружие и будут зависеть от этой привязки. Кастомная пушка будет повышать уровни в магазинах планет одновременно с повышением уровней родительского оружия.
SetCustomWeaponSizeAndCost - устанавливает цену и вес кастомной пушки (очерёдность аргументов не совпадает с названием!!!):
	1 - раздел кастомного оружия;
	2 - коэффициент стоимости (допустимы значения float);
	3 - средний вес;
SetCustomWeaponAvailability - устанавливает место продажи кастомной пушки:
	1 - раздел кастомного оружия;
	2 - строка:
	  'Free' - оружие продаётся в любых магазинах;
	  'CoalitionOnly' - только на планетах/станциях Коалиции;
	  'PirateOnly' - только на пиратских планетах/станциях;
	  'MalocOnly' - только на малокских планетах/станциях;
	  'PelengOnly' - только на пеленгских планетах/станциях;
	  'PeopleOnly' - только на человеческих планетах/станциях;
	  'FeiOnly' - только на фэянских планетах/станциях;
	  'GaalOnly' - только на гаальских планетах/станциях;
	  'NotSold' - это оружие нельзя купить в магазинах;
	  'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
SetCustomWeaponSE - устанавливает графические эффекты кастомного оружия:
	1 - раздел кастомного оружия;
	2 - анимация выстрела;
	3 - анимация сплэша;
	4 - анимация подрыва ракеты;
	5 - номер палитры для анимации выстрела;


Артефакты:
ShipArts - аналогично ShipItems, только для артефактов, т.к. они находятся на корабле отдельным списком, возвращает количество артов в трюме, или конкретный арт из трюма:
	1 - корабль (возвращает количество);
  Опционально:
	2 - номер арта в списке артов корабля (возвращает конкретный артефакт);
CreateArt - создаёт оригинальный артефакт:
	1 - тип артефакта;
	2 - раса-производитель;
CreateCustomArt - создаёт кастомный артефакт:
	1 - системное название кастомного артефакта (строкой);
	2 - размер;
	3 - цена;
	4 - раса-производитель;
CustomArtData - создаёт три поля для хранения переменных типа integer, с возможностью их подстановки в описание Data1, Data2, Data3:
	1 - артефакт;
	2 - номер поля (от 1 до 3);
  Опционально:
	3 - какое значение установить;
CustomArtTextData - три поля для хранения текстовой инфы кастомного арта <TextDataN>, где N - номер поля:
	1 - артефакт;
	2 - номер поля (от 1 до 3);
  Опционально:
	3 - какой текст установить;
ArtefactTypeInUse - возвращает количество экипированных на корабле и не сломанных артефактов определённого типа:
	1 - корабль;
	2 - тип артефакта или сам артефакт, тип которого нужно проверить (можно проверять кастомные типы);
  Примечание: При установленном Артефакторе, для "информационных" артефактов из трюма, вроде Биомира, эта функция также вернёт "true" во время событий t_OnEnteringForm и t_OnReEnteringForm, но не во время событий t_OnStep, что вообще нихера не удобно учитывать в коде, но просто примите как факт. Всякие Биомиры в трюме при установленном Артефакторе считаются рабочими только в тот момент, когда игрок захочет посмотреть свои статы. И, более того, с ТН на установку множества однотипных артефактов, при установке в слоты сразу двух Артефакторов, всякие Биомиры будут полноценно работать из трюма (увеличивать длительность действия стимуляторов) на постоянной основе, возвращая "true" даже во время t_OnStep.
ArtefactTypeBoosted - возвращает текущий статус совместимости (0/1) экипированных на корабле артефактов определённого типа:
	1 - корабль;
	2 - тип артефакта или артефакт, тип которого нужно проверить;
   Примечание: Под "совместимостью" понимается разблокировка дополнительных свойств артефакта, в случае наличия на корабле установленного "совместимого" с ним, то есть оборудования от неизвестного производителя (ItemOwner(item) == 6). Пример: Железные жупи и корпус неизвестной расы.


Ракеты/торпеды:
SpawnMissile - спавнит ракету в системе, и возвращает указатель на неё:
	1 - система;
	2 - цель ракеты;
	3 - место появления ракеты, координата X;
	4 - место появления ракеты, координата Y;
	5 - стартовый угол поворота ракеты;
	6 - минимальный урон;
	7 - максимальный урон;
	8 - скорость ракеты;
	9 - тип оружия, из которого якобы запускается ракета (номер типа или строка типа для кастомного оружия);
  Опционально:
	10 - номер ММ для оружия, из которого якобы запускалась ракета (если не нужен, подставить -1);
	11 - номер акрина для оружия, из которого якобы запускалась ракета (если не нужен, подставить -1);
  Примечание: Если подразумевается, что заспавленную ракету выпустил корабль, не забудьте прописать его ракете через MissileOwner(). В противном случае ракета просто детонирует об корабль, который якобы её и выпустил.
MissileStar - возвращает систему, в которой находится ракета:
	1 - ракета;
MissileType - возвращает тип оружия (только оригинального числом или t_CustomWeapon для кастомного оружия), из которого была выпущена данная ракета:
	1 - ракета;
CustomMissileType - возвращает тип кастомного оружия (строкой, для оригинальных орудий вернёт 'W01', 'W02' и т.д.), из которого была выпущена ракета:
	1 - ракета;
MissileOwner - возвращает или устанавливает выпустивший ракету корабль:
	1 - ракета;
  Опционально:
	2 - корабль, который будет считаться хозяином ракеты;
  Примечание: Не забывайте использовать эту функцию в случаях, когда ракета была добавлена в игру функций SpawnMissile(). В противном случае она просто детонирует об корабль, который якобы её и выпустил.
MissileTarget - возвращает или устанавливает цель ракеты:
	1 - ракета;
  Опционально:
	2 - установить новую цель;
MissileLive - возвращает/изменяет время полёта ракеты/торпеды, по умолчанию составляющее 1000 (5 дней):
	1 - ракета;
  Опционально:
	2 - на какое значение изменить время полёта ракеты/торпеды;
	   Пояснение: Изначальное время полёта ракеты составляет 0, а по достижению 1000, то есть 5 дней, ракета самоуничтожается. Функция MissileLive позволяет изменять это время, при этом значение, которое игрок устанавливает через функцию, будет отниматься от той самой 1000. Таким образом, если, например, задать MissileLive при запуске ракеты (событие t_OnMissileShot), то время полёта ракеты сместиться в минус и будет составлять 0-value, пример: при MissileLive(missile, 200) на старте ракеты, её начальное время полёта уже будет составлять как бы 1 день (-200), как раз тот день, в который ракета вылетает из установки, набирает скорость и врубает самонаведение. То есть при MissileLive(missile, 200) на старте, ракета вылетит из установки уже на максимальной скорости и моментально направится к цели. Учтите, что при данном подходе время реальной жизни ракеты после пуска также сократиться до 800 (4 дней).
	   Если же устанавливать MissileLive для уже вылетевшей ракеты, то значение будет отниматься из фактически проделанного её пути, пример: ракета пролетела 3 дня, её срок жизни составляет 600, а установка MissileLive(missile, 200) отнимет 200 из этого значения, по сути "омолодив" ракету на один день. Таким образом, можно продлять срок жизни нужной ракеты до бесконечности.
	   Примечание: Выставлять отрицательное значение в функции MissileLive также возможно, но тогда ракета будет получать буст ко времени вывода на цель. То есть просто будет лететь по прямой на минимальной скорости, ни на что не реагируя. Подробно эту возможность не тестировал. Также данную функцию можно использовать для мгновенного уничтожения ракеты, просто выставляя MissileLive(missile, 1000), либо больше.
MissileSpeed - возвращает/устанавливает текущую скорость ракеты:
	1 - ракета;
  Опционально:
	2 - какую скорость установить;
MissileAngle - возвращает/устанавливает угол направления носа ракеты по часовой стрелке (где север, это нулевой угол) в виде float (передавать можно и int):
	1 - ракета;
  Опционально:
	2 - новый угол поворота в градусах;
WeaponAmmunition - возвращает/устанавливает текущее количество зарядов в ракетном оружии:
	1 - оружие;
  Опционально:
	2 - установить новое значение;
WeaponMaxAmmunition - возвращает/устанавливает максимальное число зарядов в ракетном оружии:
	1 - оружие;
  Опционально:
	2 - какое максимальное число зарядов установить;
  Примечание: Для всех типов ракетного оружия рост максимального числа зарядов по ТУ идентичен и линеен: 25 + 5 * ТУ.
MissileMinDamage - возвращает/устанавливает минимальный урон ракеты:
	1 - ракета;
  Опционально:
	2 - установить новое значение;
MissileMaxDamage - возвращает/устанавливает максимальный урон ракеты:
	1 - ракета;
  Опционально:
	2 - установить новое значение;
MissileWeaponID - возвращает Id ракеты, который всегда равен Id выпустившего ракету орудия (ракеты, рождённые через SpawnMissile, имеют нулевой Id):
	1 - ракета;


Микромодули и акрины:
CreateMM - создаёт микромодуль в виде предмета и возвращает на него ссылку:
	1 - номер бонуса для создания ММ;
BonusCount - без аргументов, возвращает общее количество всех ММ и акринов в игре (а точнее всех загруженных в Галактику);
  Примечание: Оригинальные номера-названия разделов всех бонусов в Lang начинаются с '0' и заканчиваются '545' (в модах могут подставляться строкой, но в оригинале только цифры). "Нумерация" бонусов в Lang оригинальной игры имеет серьёзные пропуски (пропущены буквально сотни номеров). Бонусы микромодулей начинаются с 0 и завершаются на номере 306, плюс Акринатор (уникальный ММ с параметром Special=1) под номером 498. Бонусы оружейных модификаций начинаются с номера 500 и заканчиваются последним в списке бонусов номером 545.
FindBonusByName - ищет по названию и при успехе возвращает номер бонуса:
	1 - название бонуса (при неудаче вернёт -1);
FindBonusByCustomTag - ищет бонус по особому тэгу (параметр CustomTag в разделе бонуса в Lang) и при успехе возвращает его номер:
	1 - тэг бонуса строкой (при неудаче вернёт -1);
FindBonusByNameInCfg - ищет бонус по имени его раздела в Lang (все разделы оригинальных бонусов имеют сугубо числовые имена), что делает эту функцию крайне полезной при поиске бонусов из оригинальной игры, которые, в своём большинстве, не имеют кастомных тэгов:
	1 - имя раздела бонуса в Lang (при неудаче вернёт -1);
  Важно! Внутренняя игровая нумерация бонусов автоматически выстраивается при запуске игры из всех бонусов в разделе MicroModuls. Данная нумерация никак не привязана к названиям разделов конкретных бонусов, так что называть это разделы можно как угодно, лишь бы для разных бонусов они не повторялись.
BonusNumInCfg - возвращает имя раздела Lang, в котором прописана информация о конкретном бонусе строкой:
	1 - номер бонуса (при несуществующем номере бонуса вернёт '');
BonusPriority - возвращает приоритет бонуса (от 0 до 100):
	1 - номер бонуса;
	  Priority - параметр для акриновых бонусов от 0 до 100, определяющий, на каком ГТУ (а точнее на планетах с каким ПТУ) будет доступен для покупки данный акрин. Определяется по формуле 8 * N, где N - прописанный в Lang параметр Priority, умноженный на 0.01. Результат (например: 8 * 0.60 = 4.8) округляется всегда в большую сторону и означает точный ГТУ, с которого бонус станет доступным для наложения на предметы (в приведённом примере это будет 5 ГТУ).
    Примечание: Появление акринов по ПТУ аналогичным образом работает и для станции. При генерации акринов на станциях, те "подтягивают" в свой магазин акрины, случайным образом доступные для появления по ПТУ на разных обитаемых планетах своей системы.
  Отдельные (противоположные) значения данного параметра прописываются для микромодулей: 
	0-30 - микромодуль первого уровня (<color=255,0,0>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
	31-69 - микромодуль второго уровня (<color=255,240,100>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
	70-100 - микромодуль третьего уровня (<color=17,139,255>), цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
  Примечание: Также приоритет ММ определяет, на каких ГТУ данный модуль может появиться у случайных кораблей. Чем выше (ниже) приоритет, тем более высокий ГТУ будет необходим данному ММ для появления на кораблях NPC. Определённый диапазон (minP - maxP) подбора ММ для конкретного ГТУ считается по формуле: maxP = PortionInDiapason(GalaxyTechLevel(), 3, 7, 70, 0); minP = maxP + 40; Однако далее, если в указанном диапазоне обнаружился хотя бы один подходящий для конкретного типа оборудки модуль, будет произведено расширение искомого диапазона, после чего код сравнит подобранные с широкой выборки ММ уже по их индивидуальным статам и подберёт лучший.
BonusIsSpecial - проверяет, что бонус это акрин:
	1 - номер бонуса;
BonusName - возвращает название бонуса (параметр Name):
	1 - номер бонуса;
BonusText - возвращает полное описание указанного бонуса (параметр Text):
	1 - номер бонуса;
BonusCustomTag - возвращает тэг указанного бонуса (параметр CustomTag):
	1 - номер бонуса;
BonusValue - возвращает значение какого-то конкретного усиления/штрафа в бонусе:
	1 - номер бонуса;
	2 - значение какого усиления/штрафа вернуть (например, bonSpeed);
HullSpecial - возвращает/накладывает акрин на корпус (вернёт -1, если акрина нет):
	1 - сам корпус или использующий его корабль;
  Опционально:
	2 - какой акрин наложить (-1 - снять акрин);
	  Примечание: Данная функция лишь добавляет корпусу бонус, но не меняет его тип на акриновый. Следовательно, при наложении акрина данной функцией на не акриновый корпус его внешний вид изменён не будет. То же самое касается и функции EqSpecial. Для полноценного наложения акрина на корпус используйте функцию SpecialToEquipment.
SpecialToEquipment - накладывает или снимает акрин с оборудования с учётом модификаторов Cost и Size (если прописаны в бонусе):
	1 - номер бонуса (если -1, то снять акрин);
	2 - оборудование (при повторной акринации акринированного предмета, наложит модификаторы Cost и Size поверх уже изменённых статов);
ModuleToEquipment - аналогично SpecialToEquipment, только для установки/изъятия ММ, а также реально меняющая статы предмета согласно бонусу (нормальная установка ММ):
	1 - номер бонуса (если -1, то изъять ММ);
	2 - оборудование;
EqSpecial - возвращает (-1, если акрина нет), накладывает или снимает акрин с оборудования без учёта модификаторов на размер и стоимость:
	1 - оборудование;
  Опционально:
	2 - номер бонуса (если -1, то снять акрин);
EqModule - аналогично EqSpecial, только для проверки/установки/изъятия ММ. Не изменяет (!) никакие статы предмета, однако блокирует дальнейшие улучшения на НБ (игра будет думать, что статы были занижены относительно их базового значения):
	1 - оборудование, либо микромодуль в виде предмета;
  Опционально:
	2 - номер бонуса (если -1, то изъять ММ);
  Примечание: Если вам необходимо полностью заменить текст в карточке предмета с определённым акрином, то в разделе бонуса данного акрина необходимо использовать параметры TextReplace по числу оригинальных строчек Text данного предмета. В этом случае строчки с TextReplace автоматически заменят собой все оригинальные строчки Text. Также с помощью акрина имеется возможность добавить дополнительный текст в описание любого артефакта, для чего нужно просто добавить ему соответствующий акрин или спецакрин. Акрин не окажет на артефакт иного влияния, кроме замены текста.
ItemExtraSpecials - возвращает общее количество всех спецакринов на предмете или конкретный спецакрин:
	1 - предмет;
  Опционально:
	2 - номер спецакрина на предмете (вернёт спецакрин);
ItemExtraSpecialsCountByType - возвращает количество конкретных спецакринов на предмете:
	1 - предмет;
	2 - спецакрин, количество которых необходимо вернуть;
ItemExtraSpecialsAddByType - добавляет спецакрин на предмет:
	1 - предмет;
	2 - спецакрин;
  Опционально:
	3 - сколько указанных спецакринов добавить (по умолчанию будет добавлен 1);
ItemExtraSpecialsDeleteByType - удаляет спецакрин с предмета:
	1 - предмет;
	2 - спецакрин;
  Опционально:
	3 - сколько указанных спецакринов удалить (по умолчанию будет удалён 1);
  Примечание: Фактически спецакрины почти ничем не отличаются от обычных, кроме способа наложения на предмет и возможностью накладывать сразу множество спецакринов, вместо одного основного. Также спецакрины не применяют к предмету модификаторы Cost и Size и, в отличие от простых акринов, будучи наложены на орудие, не суммируют бонус к урону/дальности со статами пушки, а прибавят его как любой другой акрин (но всё равно только к той пушке, но которую были наложены). Количество одинаковых спецакринов на предмете хранится в виде числа, поэтому путём наложения нужного числа "пустых" спецакринов вы можете, фактически, записывать в любое оборудование числовую информацию. А для добавления дополнительного текста в карточку оборудования со спецакрином, в разделе бонуса этого спецакрина необходимо использовать параметры ExText, а не просто Text, как обычно. При добавлении на предмет более одного одинакового спецакрина, текст из параметра ExText в описании не дублируется.
MayAddBonusToEq - проверяет, можно ли установить бонус (акрин или ММ) на указанное оборудование (учитываются тип и раса-производитель оборудования):
	1 - номер бонуса;
	2 - оборудование;
BuildListOfMMByPriority - записывает в массив список номеров бонусов ММ (бонусы с тэгом Special=1 микромодулями не считаются) в указанном диапазоне значений их приоритета, после чего возвращает размер получившегося массива, по умолчанию не добавляет ММ с установленным параметром RacialRestriction:
	1 - массив (будет очищен автоматически);
	2 - стартовый приоритет модулей для добавления;
	3 - конечный приоритет модулей для добавления;
	  Примечание: От того как вы расставите аргументы, от 100 до 0 или от 0 до 100 будет зависеть последовательность занесения модулей в массив. От 100 до 0 будут заноситься модули от худших (3-го уровня) до лучших (1-го уровня), и наоборот.
  Опционально:
	4 - маркер (0/1) для разрешения добавления в массив модулей с RacialRestriction;
SwitchToMirrorImage - используется для плавной смены анимации корабля/станции прямо на глазах у игрока:
	1 - корабль/станция;
	2 - номер акрина, на анимацию которого необходимо переключится (также будет заменён и сам корпусной акрин);
  Примечание: Если одна Hai анимация (Gai не подходит) использована сразу в нескольких корпусных акринах, и при этом в каждом акрине указан свой отдельный отрезок этой анимации, то при смене акрина корабля/станции на другой акрин с той же анимацией с помощью данной функции будет произведён плавный переход кадров (сперва завершится предыдущая анимация, а затем начнёт воспроизводиться следующая, уже с нового акрина). Если же переключать акрин корабля/станции на акрин, имеющий какую-то другую анимацию, то переход кадров будет резким, без плавного завершения предыдущей анимации (просто сразу же начнёт воспроизводиться анимация с нового акрина).


Операции с товарами:
UpsurgeGoods - на планете начинается распродажа определённого товара (если указанный товар закончился, может автоматически подкинуть на склады ещё 200-300 единиц, пока продолжается распродажа), автоматически отменяет его дефицит, если он есть:
	1 - планета;
	2 - тип товара;
DecayGoods - на планете начинается дефицит определённого товара, автоматически отменяет его распродажу, если она есть:
	1 - планета;
	2 - тип товара;
GoodsRuinsForBuy - станция предлагает много определённого товара по дешёвке:
	1 - станция;
	2 - тип товара;
PlanetSetGoods - устанавливает количество определённого товара на планете:
	1 - планета;
	2 - тип товара;
	3 - какое количество установить;
GoodsAdd - добавляет некоторое количество определённого товара в магазин или в трюм корабля (возвращает общее количество товара после изменения):
	1 - планета, станция или корабль;
	2 - тип товара;
	3 - на сколько изменить количество товара в магазине (если подставить 0, то вернёт имеющееся количество без изменения);
GoodsCount - возвращает количество определённого товара в трюме корабля или станции:
	1 - корабль;
	2 - тип товара;
ShipGoods - аналог GoodsAdd, но изменяет количество товара исключительно в трюме корабля или станции (и при этом не возвращает ничего):
	1 - корабль;
	2 - тип товара;
	3 - на сколько изменить количество товара в трюме;
  Опционально:
	4 - какую стоимость установить данному товару (по умолчанию выставляет среднюю галактическую);
GoodsDrop - заставляет корабль выбросить товар (обратите внимание, что товар на корабле не существует в качестве предмета, поэтому выбросить его никакой другой функцией нельзя):
	1 - корабль (не работает с кораблём игрока);
	2 - тип товара;
	3 - сколько выбросить;
  Опционально:
	4 - скриптовый объект (выброшенный товар будет занесён в указанный скриптовый объект);
GoodsSellPrice - цена (за единицу товара), за которую планета продаёт определённый товар:
	1 - планета;
	2 - тип товара;
GoodsBuyPrice - цена (за единицу товара), за которую планета покупает определённый товар:
	1 - планета;
	2 - тип товара;
CreateGoods - создаёт товар:
	1 - тип товара;
	2 - количество товара;
  Опционально:
	3 - маркер (0/1), чтобы созданные предметы по умолчанию получили вид своего родного контейнера, а не ящика (например, если предмет добавляется сразу в космос);
ShipGoodsIllegalOnPlanet - проверяет легальность определённого товара на планете для конкретного корабля:
	1 - корабль;
	2 - тип товара;
	3 - планета;

Оборудование и корабль (характеристики и параметры):
BuildListOfNewShips - делает перебор Галактики и заполняет массив только кораблями и станциями, родившимися с определённого момента, а в случае, если таковых нет, оставит массиву один пустой элемент. Функция заполняет массив, начиная с элемента под нулевым номером, и в конце возвращает число записанных в массив кораблей (при отсутствии таковых вернёт 0):
	1 - массив для заполнения (будет очищен автоматически);
	2 - Id самого старого корабля, с которого начнётся занесение новых кораблей в массив;
  Опционально:
	3 - сет номерных типов кораблей (если 0 или отсутствует, то ищет всех, кроме транклюкаторов, т.к. искать последних для хардкода трудоёмко):
		t_Kling - 1
		t_Ranger - 2
		t_Transport - 4
		t_Pirate - 8
		t_Warrior - 16
		t_Tranclucator - 32
		t_RC - 64
		t_PB - 128
		t_WB - 256
		t_SB - 512
		t_BK - 1024
		t_MC - 2048
		t_CB - 4096
		t_UB - 8192
	4 - сет рас (если 0 или отсутствует, то ищет всех):
		Maloc - 1
		Peleng - 2
		People - 4
		Fei - 8
		Gaal - 16
		Kling - 32 (доминаторы)
		None - 64 (неизвестная раса)
		PirateClan - 128
	5 - добавлять 1 или нет 0 скриптовые корабли (корабли с OrderLock будут также считаться скриптовыми);
	6 - фильтр кастомных фракций вида: 'S1,S2,S3' в котором пустая строка '' будет считаться как фильтр на добавление кораблей без кастомной фракции (можно также составить фильтр вида ',S1,S2');
	7 - фильтр строковых типов кораблей (ShipType), работающий аналогично фильтру фракций: ',Ranger,Pirate,Klissan';
  Важно: При установке строкового фильтра, все оригинальные корабли будут проходить в нём под значением ''. То есть если вы не хотите исключать оригинальные типы кораблей, обязательно оставьте в вашем фильтре место под пустую строку: '', 'CustomType1,,CustomType2' или ',CustomType1,CustomType2'
ShipSpeed - возвращает текущую скорость корабля:
	1 - корабль;
ShipFuel - возвращает и устанавливает количество топлива в установленном топливном баке:
	1 - корабль;
  Опционально:
	2 - какое количество топлива установить, если количество топлива изменено, то вернёт количество до изменения;
ShipFuelLow - проверяет, не отсутствует ли на корабле топливный бак, или количество топлива в нём меньше максимального:
	1 - корабль;
	  Игровая формула расчёта стоимости топлива:
		За основу берётся текущий ход, а оригинальная формула имеет вид: Количество * PortionInDiapason(Galaxy.FTurn, 1000, 15000, 1, 10);
		Это означает, что для хода 1000 и ниже - стоимость единицы топлива составит 1 кредит, а для хода 15.000 и выше - 10 кредитов. Весь диапазон цены между данными значениями (от 1 до 10 кредитов) меняется линейно.
		Далее, на полученный округлённый результат, от стоимости общего количества пополняемого топлива, накладываются модификаторы. Модификатор расы накладывается, только если игрок заправляется на планете, а модификатор сложности накладывается в любом случае. Вне зависимости от результатов вычислений, одна единица топлива не может стоить дешевле 1 кредита. Округление итогового значения осуществляется, как обычно, функцией round(), в самом конце расчетов и после наложения всех возможных модификаторов.
	  Модификаторы от расы планеты:
		0 (малоки) - 0.7;
		1 (пеленги) - 0.9;
		2 (люди) - 1.0 (доминаторы и неизвестная раса бы имели тот же коэффициент, если бы продавали топливо);
		3 (фэяне) - 1.15;
		4 (гаальцы) - 1.30;
		7 (пираты) - 0.8;
	  Модификаторы от сложности настройки удачи GalaxyDiffLevels(7):
		 -30% на сложности 50%
		   0% на сложности 100%
		 +30% на сложности 150%
		 +60% на сложности 200%
		 +90% на сложности 250%
		+120% на сложности 300%
		+150% на сложности 350%
		+180% на сложности 400%
		+210% на сложности 450%
		+240% на сложности 500%
ShipCntWeapon - общее число экипированных на корабле орудий:
	1 - корабль;
ShipWeapon - возвращает экипированное на корабле орудие:
	1 - корабль;
	2 - номер орудия (1-5);
  Примечание: Номер орудия не соответствует нумерации орудийного слота, в котором оно установлено. Если вам необходима строгая предсказуемая нумерация от 1 до 5, используйте запросы вида: ShipEqInSlot(ship, t_Weapon1, weapon_slot_number). Конкретно функция ShipWeapon нумерует орудия на корабле хрен пойми в каком порядке (вероятно, использует общую нумерацию вещей в трюме), что не имеет значения для простого перебора всех орудий, но может стать проблемой, если вам нужно подставлять/определять орудие в конкретном слоте.
WeaponTarget - возвращает или устанавливает цель орудия:
	1 - орудие;
  Опционально:
	2 - какую цель установить;
ShipEqInSlot - возвращает установленное в слоте оборудование/оружие (при его отсутствии вернёт 0):
    1 - корабль;
    2 - тип слота:
	   t_Artefact - слот артефакта;
	   t_Hull - слот корпуса;
	   t_FuelTanks - слот топливного бака;
	   t_Engine - слот двигателя;
	   t_Radar - слот радара;
	   t_Scaner - слот сканера;
	   t_RepairRobot - слот дроида;
	   t_CargoHook - слот захвата;
	   t_DefGenerator - слот ГЗП;
	   t_Weapon1 - орудийный слот;
  Опционально:
    3 - номер слота (для оружия 1-5, для артефактов 1-4);
  Примечание: Не пользуйтесь прямой нумерацией при указании слотов/типов оборудования, т.к. при её смещении (в связи с обновлениями хардкода) в коде появится неочевидная ошибка. Вместо этого используйте общие переменные типа t_Engine.
EnginePower - возвращает текущий перегрев двигателя (от 0 до 100):
	1 - конкретный двигатель или использующий его корабль;
  Опционально:
	2 - какое значение перегрева установить;
ShipJump - возвращает расстояние максимального прыжка корабля (только по двигателю!) с учётом всех бонусов:
	1 - корабль;
ShipArmor - возвращает броню корабля с учётом всех бонусов:
	1 - корабль;
ShipProtectability - возвращает % блокировки урона ГЗП корабля с учётом всех бонусов:
	1 - корабль;
ShipDroidRepair - возвращает эффективность дроида корабля с учётом всех бонусов:
	1 - корабль;
ShipRadarRange - возвращает радиус радара корабля с учётом всех бонусов:
	1 - корабль;
ShipScanerPower - возвращает мощность сканера корабля с учётом всех бонусов:
	1 - корабль;
ShipHookPower - возвращает мощность захвата корабля с учётом всех бонусов:
	1 - корабль;
ShipHookRange - возвращает радиус захвата корабля с учётом всех бонусов:
	1 - корабль;
ShipAverageDamage - возвращает средний урон корабля по одной цели с учётом всех орудий и всех бонусов:
	1 - корабль;
  Опционально:
	2 - вывести лимитное значение:
	   0 - средний минимальный урон;
	   1 - средний максимальный урон;
ShipOwner - возвращает или устанавливает расу корабля (но не пилота):
	1 - корабль;
  Опционально:
	2 - какую расу установить:
	  0 или 'Maloc' - малок;
	  1 или 'Peleng' - пеленг;
	  2 или 'People' - человек;
	  3 или 'Fei' - фэянин;
	  4 или 'Gaal' - гаалец;
	  5 или 'Kling' - доминатор;	  
	  6 или 'None' - неизвестный;
	  7 или 'PirateClan' - клановый пират;
ShipStanding - возвращает/изменяет статус корабля или станции в противостоянии пиратов и Коалиции:
	1 - корабль;
  Опционально:
	2 - какой статус (Standing) выставить:
	   0 - Kling - (доминатор) считается доминатором, а потому всеми другими расами воспринимается враждебно;
	   1 - None - (ничейный) полностью безразличен к происходящему в системе, аналогичен транклюкатору без хозяина;
	   2 - CoalMilitary - (военные) аналогично ВБ, ЦР и военным кораблям (может захватывать системы для Коалиции);
	   3 - CoalActive - (военные-нейтралы) почти тоже, что и простые военные, но с пиратами отношения чуть получше, аналогично НБ и БЦ (может захватывать системы для Коалиции);
	   4 - CoalPassive - (гражданские) аналогично транспортам в пиратских системах, не вызывает агрессии пиратов, пока не начнёт атаковать сам;
	   5 - Neutral - (нейтралы) соответствует МЦ, перепрограммированному Блазеру и кораблям в тюрьме, игнорирует коалиционные и пиратские тёрки, но к доминаторам враждебен;
	   6 - PiratePassive - (вольные пираты) соответствует обычным ПБ и простым пиратам, терпимо относящимся к Коалиции;
	   7 - PirateActive - (пираты-нейтралы) соответствует атакующим пиратам (может захватывать системы для клана);
	   8 - PirateMilitary - (клановые пираты) соответствует пиратским доминионам и запрещает посадку коалиционных кораблей;
	   9 - Custom - будет враждебен всему, что не имеет той же кастомной фракции и абсолютно всему, если кастомная фракция у данного корабля отсутствует;
	С помощью данных типов можно определять, какие корабли клановые пираты или военные будут считать обязательными к уничтожению при захвате системы.
	   Типы, к которым всегда враждебны военные:
	      - Kling - доминаторы;
	      - PirateMilitary - всё, что безоговорочно клановое;
	      - PirateActive - сюда же переводятся рейнджеры, которые выступят на стороне клана (уничтожат хотя бы одного военного) во время обороны системы;
	      - Custom - кастомные фракции (без приставки 'SubFaction');
	   Типы, к которым всегда враждебны клановые пираты:
	      - Kling - доминаторы;
	      - CoalMilitary - всё, что безоговорочно коалиционное;
	      - CoalActive - сюда же переводятся рейнджеры и гражданские, которые выступят на стороне военных (уничтожат хотя бы одного кланового пирата) во время обороны системы;
	      - Custom - кастомные фракции (без приставки 'SubFaction');
  Примечание: Если выставить новый тип Standing для корабля, то он вскоре снова затрёт его своим, а вот станциям менять тип можно без особых проблем. Если же выставить определённый Standing кораблю всё же необходимо, то можно использовать наложение кастомной фракции, в качестве своеобразного маркера. Корабли, в названии кастомной фракции которых присутствует 'FixedStanding', изменять свой Standing автоматически не будут. Если же повесить на корабль кастомную фракцию 'SubFactionFixedStanding', то выставлять ему кастомную иконку и цвет цифр урона через Main будет не нужно, поскольку в таком случае кастомная фракция заменять эти элементы не будет.
OrderForsage - проверяет, не влючен ли у корабля форсаж, либо включает/выключает его:
	1 - корабль;
  Опционально:
	2 - если значение больше 0, то включить форсаж;
HullHP - возвращает или устанавливает запас прочности корпуса:
	1 - сам корпус или использующий его корабль;
  Опционально:
	2 - какое количество HP установить корпусу;
HullDamage - возвращает процент повреждений корпуса корабля (от 0 до 100, где 0 - полностью целый корпус):
	1 - корабль;
Hitpoints - возвращает текущий запас прочности корпуса корабля:
	1 - корабль;
HullDamageSuspectibility - возвращает восприимчивость корпуса к определённому типу урона:
	1 - корпус/корабль;
	2 - тип воспримчивости (0 - En, 1 - Sp, 2 - Mi или дамагсет для автоматического определения "входящего" урона);
ShipSlots - возвращает количество открытых слотов определённого типа в корпусе корабля (с учётом всех применённых штрафов и бонусов):
	1 - корабль;
	2 - номер типа слота:
	  1 - st_Weapon;
	  2 - st_Artefact;
	  3 - st_Radar;
	  4 - st_Scaner;
	  5 - st_RepairRobot;
	  6 - st_CargoHook;
	  7 - st_DefGenerator;
	  8 - st_Forsage;
ShipRefuel - восполняет запас топлива в установленном баке корабля до максимума:
	1 - корабль;
ShipRepairEq - полностью чинит всё установленное на корабле оборудование (но не структуру корпуса и артефакты):
	1 - корабль;
ShipImproveItems - улучшает оборудование на корабле:
	1 - корабль;
	2 - сколько раз улучшить (один заход на корабль - улучшение одного случайного предмета или вставка в него случайного ММ);
ItemImprovement - проверяет, улучшен ли данный предмет (значение одного из основных параметров выше, либо ниже нормы для данного ТУ), либо улучшает его:
	1 - предмет (проверит, улучшен ли он, что выражается в соотнесении стандартных статов предмета для данного ТУ с его текущими параметрами);
  Опционально:
	2 - степень улучшения:
	   0 - стажёры;
	   1 - обычные спецы;
	   2 - лучшие спецы;
	   3+ - случайные спецы (вариант по умолчанию);
	3 - какой параметр улучшать, если предмет имеет несколько характеристик:
	   0 - случайный параметр из возможных (вариант по умолчанию), для предметов с одним параметром выберет только его;
	   1 - первый параметр;
	   2 - второй параметр;
	4 - Id предмета/зерно для определения рандомного модификатора в формуле улучшения (можно использовать, чтобы "стандартизировать" степень улучшения для разных предметов);
  Примечание: Данная функция игнорирует параметр BlockImp.
ItemCanBeBroken - проверяет, имеется ли у предмета шкала износа:
	1 - предмет;
ItemIsBroken - проверяет наличие флага полной сломанности на предмете (не идентично проверке ItemDurability(item) == 0):
	1 - предмет (0 - не сломан, 1 - сломан);
ItemDurability - возвращает текущий износ предмета в проценатх (от 0 до 100, где 0 полностью изношенный предмет) или устанавливает этот процент:
	1 - предмет;
  Опционально:
	2 - какой процент износа установить;
  Важно: Может возвращать нахер не нужные отрицательные значения прочности! Используйте ItemIsBroken() для надёжной проверки сломанности предмета.
ItemFragility - возвращает текущий показатель "хрупкости" предмета с учётом всех штрафов/бонусов, в виде float:
	1 - предмет;
	  Игровая оценка надёжности предмета (выбирается ближайший к текущему Fragility показатель):
	    0.70 - непревзойдённая надёжность (QualityGrade0 в Lang);
		0.80 - очень высокая надёжность (QualityGrade1 в Lang);
		0.90 - высокая надёжность (QualityGrade2 в Lang);
		1.00 - средняя надёжность (QualityGrade3 в Lang);
		1.20 - низкая надёжность (QualityGrade4 в Lang);
		1.40 - очень низкая надёжность (QualityGrade5 в Lang);
		1.60 - ужасная надёжность (QualityGrade6 в Lang);
ItemLevel - возвращает/устанавливает ТУ оборудования:
	1 - оборудование (в том числе корпус);
  Опционально:
	2 - какой ТУ установить (от 1 до 8);
ShipTechLevelKnowledge - возвращает/устанавливает кораблю разрешение на пользование оборудованием доминаторов указанного уровня вне зависимости от ГТУ (по умолчанию каждый ТУ оборудования доминаторов разблокируется для всех прочих кораблей только по мере роста ГТУ):
	1 - корабль;
  Опционально:
	2 - какой максимальный уровень допуска установить (от 1 до 8);
MissilesToRearm - возвращает сколько зарядов не хватает ракетному оружию до полного комплекта или пополняет боезапас:
	1 - оружие;
  Опционально:
	2 - на сколько пополнить боезапас (для разрядки орудия нужно указать отрицательное значение):
	  ГТУ 1 - 10 cr.
	  ГТУ 2 - 10 cr.
	  ГТУ 3 - 28 cr.
	  ГТУ 4 - 46 cr.
	  ГТУ 5 - 64 cr.
	  ГТУ 6 - 82 cr.
	  ГТУ 7 - 100 cr.
	  ГТУ 8 - 100 cr.
	Примечание: Стоимость пополнения одного заряда (любого) зависит от ГТУ (сама функция MissilesToRearm деньги за пополнение не списывает).
ShipSpecialBonuses - возвращает величину акринового бонуса определённого типа для указанного корабля или устанавливает эту величину (это значения дополнительных скриптовых бонусов на весь корабль, а не тех, что добавляются акриновым оборудованием):
	1 - корабль;
	2 - тип бонуса числом (пример: bonSpeed - это игровая числовая переменная);
  Опционально:
	3 - какое значение бонуса установить, либо строка 'Total' для запроса общей текущей суммы данного бонуса на всём корабле, включая все акрины и ММ;


Задания:
StartTextQuest - запускает текстовый квест (для мгновенного запуска необходимо также перевести игрока на любую другую форму):
	1 - имя квеста строкой;
	2 - текст при победе (можно оставить '', тогда по умолчанию будет выводить 'Задание выполнено');
	3 - текст при поражении (можно оставить '', тогда по умолчанию будет выводить 'Квест провален');
StartRobots - запускает ПБ:
	1 - название файла карты ПБ вместе с расширением (пример: 'SeaBattle.cmap');
	2 - стартовый текст;
	3 - текст при победе;
	4 - текст при поражении;
  Опционально:
	5 - место проведения строкой (на случай, если в текстах используется подстановка названия планеты);
	6 - дополнительные настройки строкой (подставлять можно и в виде числа) из трёх цифр вида '621':
	  Первая цифра - раса правителя в текстовых сообщениях (по умолчанию 6):
	    1 - малоки;
		2 - пеленги;
		3 - люди;
		4 - фэяне;
		5 - гаальцы;
		6 - без портрета;
	  Вторая цифра - сложность карты (по умолчанию 2):
	    1 - 50%
		2 - 100%
		3 - 150%
		4 - 200%
	  Третья цифра - дополнительный бонус (по умолчанию 1):
	    1 - без бонуса;
		2 - ускоренная поддержка с воздуха;
		3 - усиленная броня;
  Примечание: Оригинальные номера карт в Lang: с 01 по 74 с учётом пиратских сюжетных.
MarkRobotsMapAsUsed - помечает конкретный планетарный бой, как уже выполненный игроком:
	1 - имя карты (пример: 'something.cmap');
  Опционально:
	2 - маркер для ресета таймера выдачи ПБ (чтобы в правительстве в тот же ход не выдавали задание на новый бой);
 Примечание: Для карт, имеющих возможность повторного прохождения за игру (параметр Reiteration), необходимо запускать MarkRobotsMapAsUsed несколько раз. Столько, сколько указано в Reiteration, так как один запуск этой функции равен одному прохождению конкретной карты.
PlayerQuestInProgress - без аргументов, проверяет, есть ли у игрока неоконченные правительственные задания;
BuildListOfQuestPossibleLocations - записывает в массив список коалиционных систем, находящихся на определённом расстоянии от указанной системы пропускает системы, где идет бой или куда летят доминаторы:
	1 - массив для записи результатов (будет очищен автоматически);
	2 - система;
	3 - минимальное расстояние;
	4 - максимальное расстояние;


Деньги:
GalaxyMoney - возвращает текущую среднюю галактическую сумму денег (результат пропорционален среднему капиталу рейнджеров), условно заданную разработчиками в градациях от незначительной до огромной:
	1 - размер суммы:
	   0 - Galaxy.MiniMoney(own);
	   1 - Galaxy.SmallMoney(own);
	   2 - Galaxy.AverageMoney(own);
	   3 - Galaxy.BigMoney(own);
	   4 - Galaxy.HugeMoney(own);
  Опционально:
	2 - модификатор расы, от малоков (минимальный модификатор) до гаальцев (максимальный модификатор), по умолчанию выставлен на людей:
	   0 - малокский модификатор;
	   1 - пеленгский модификатор;
	   2 - человеческий модификатор (выбирается по умолчанию);
	   3 - фэянский модификатор;
	   4 - гаальский модификатор;

function TGalaxy.MiniMoney(Owner:TOwner = People):integer;
begin
  Result := Round(FRangersAverageCapital * kMoneyMini * mOwner[Owner].kMargin);
  if Result > MiniItemCost then Result := MiniItemCost + Round((Result - MiniItemCost) * 0.3);
end;

  kMoneyMini    = 1 / 100;
  kMoneySmall   = 1 / 65;
  kMoneyAverage = 1 / 40;
  kMoneyBig     = 1 / 25;
  kMoneyHuge    = 1 / 15;

  MiniItemCost    = 000250;
  SmallItemCost   = 001000;
  AverageItemCost = 005000;
  BigItemCost     = 010000;
  HugeItemCost    = 025000;

FirstGiveMoney - без аргументов, возвращает сумму денег на счету игрока на момент начала игры;
RangersCapital - без аргументов, возвращает суммарный общегалактический капитал всех рейнджеров (используется во многих внутриигровых расчётах);
ShipMoney - возвращает или устанавливает текущее количество денег корабля:
	1 - корабль;
  Опционально:
	2 - какое количество денег установить, если количество денег изменено, то вернёт количество денег до изменения;
ShipWealth - возвращает текущий капитал конкретного корабля:
	1 - корабль, капитал складывается из:
	   - Текущий счёт;
	   - Стоимость оборудования на корабле;
	   - Стоимость оборудования на складах;
	   - Депозит;
PlayerDebt - возвращает или устанавливает долг игрока по кредиту:
	Без аргументов - возвращает долг игрока;
  Опционально:
	1 - установить сумму долга (1 или 0);
PlayerDebtDate - возвращает или устанавливает дату возврата кредита:
	Без аргументов - возвращает дату;
  Опционально:
	1 - устанавливает дату;
PlayerDebtCnt - возвращает или устанавливает количество просрочек по кредитам:
	Без аргументов - возвращает количество;
  Опционально:
	1 - устанавливает количество;
PlayerDeposit - возвращает или устанавливает изначальную (целую) сумму на депозите игрока:
	Без аргументов - возвращает сумму;
  Опционально:
	1 - какую сумму установить;
PlayerDepositDate - возвращает или устанавливает дату открытия депозита:
	Без аргументов - возвращает дату;
  Опционально:
	1 - устанавливает дату;
PlayerDepositDay - возвращает или устанавливает сколько дней прошло с открытия депозита:
	Без аргументов - возвращает количество дней;
  Опционально:
	1 - устанавливает количество дней;
  Примечание: Дни, в которые процент находился под кредитной заморозкой, игра вычитает автоматически.
PlayerDepositPercent - возвращает или устанавливает % депозита:
	Без аргументов - возвращает процент (в виде целого, например 30, которое следует понимать как 3.0%);
  Опционально:
	1 - устанавливает процент (также в виде целого);
  Примечание: Сам по себе депозит является статичной переменной integer, а накопленный процент рассчитывается только при запросе к этому числу. Если вы собираетесь самостоятельно менять сумму на депозите, то необходимо сперва рассчитать накопленный процент по оригинальной игровой формуле: round(FDeposit * Power(1 + 0.01 * FDepositPercent / BKkDepositPercentPeriod, FDepositDay / 365 * BKkDepositPercentPeriod)) - где функция Power - это возведение первого аргумента X в степень второго Y (скриптовыми функциями может быть записана как exp(Y * ln(X))). После этого необходимо изменить сумму депозита с учетом процента, и под конец переустановить дату открытия счёта на день его изменения.
  Пример готовой кастомной функции расчёта процентов в скрипте мода ExpBK:
  //Функция расчёта накопленных процентов для текущего состояния депозитного счёта
  function DepositPercentCalc()
  {
	  temp_float = 1.0 + 0.0001 * PlayerDepositPercent() / 12; //Считаем X
	  temp_float = exp((1.0 * PlayerDepositDay() / 365 * 12) * ln(temp_float)); //Считаем Y и возводим X в степень Y
	  result = round(temp_float * PlayerDeposit()); //Применяем получившийся процент к сумме на счету и округляем результат
  }


Здоровье:
ShipHealthFactor - возвращает/устанавливает срок действия болезни/стимулятора:
	1 - корабль, либо 0, если нужно просто вернуть стандартную длительность для данного типа болезни/стимулятора;
	2 - № болезни/стимулятора;
  Опционально:
	3 - какую длительность действия установить (число ходов), либо автоматически установить стандартную длительность для данного типа болезни/стимулятора (если передан -1);
PlayerMedPolicy - возвращает или устанавливает количество дней до завершения действия медицинского полиса у игрока:
	Без аргументов - вернёт количество дней;
  Опционально:
	1 - установить количество дней;
ShipHealthFactorStatus - возвращает срок болезни (вирусный период):
	1 - корабль;
	2 - тип болезни;
  Опционально:
	3 - какой вирусный период установить (0 - нету вируса, 1-99 есть вирус, 100 - полноценная болезнь;
  Примечание: Чекумаш, Слепота и Святой фанатизм моментально накидываются на игрока при любом положительном значении вируса, но только если игрок при этом находится на планете/станции.
PlayerImmunity - текущая устойчивость (иммунитет) игрока к болезням (меняется со временем и при лечении на МЦ):
	1 - какое значение установить (0 - минимум, 100 - максимум);
Номера болезней:
  0 - Лучевая болезнь (все расы: снижает получаемый опыт (штраф накапливается, но если повесить болезнь скриптом, то будет составлять 50%));
    Примечание: Лучевая болезнь больше не применяется в КР:HD.
  1 - Ослепление (все расы: делает все силуэты космических объектов полупрозрачными, точность, манёвренность, техника и торговля по -3);
  2 - Чекумаш (все расы: появляются различные глюки в космосе);
  3 - Святой фанатизм (все расы: все корабли и оборудование начинают казаться доминаторскими, точность и манёвренность по +1, обаяние -1, лидерство +2);
  4 - Комплексный иммуноцид (все расы: практически моментальное заражение чем угодно, если в организм попадёт вирус);
  5 - Загадочная луатанция (все расы: невозможность заниматься рэкетом, периодические выплаты из фонда (только для игрока), точность -2, обаяние +3);
  6 - Наркозависимость (все расы: повышает износ оборудования в 2 раза (только для игрока), точность и манёвренность по -3, техника -2);
  7 - Вихревая контузия (все расы: накладывает скрытый дебаф* (только для игрока), точность -2, манёвренность -5, торговля -10);
  8 - Мышечное растяжение (все расы: накладывает скрытый дебаф* (только для игрока), точность, манёвренность и торговля по -2, обаяние и лидерство по -1);
  9 - Великий Малососус (только малоки: увеличивает массу корабля на 20% (только если заболевший - малок, но иное в нормальных условиях и невозможно), лидерство и торговля по +3);
  10 - Горькая пеленоша (только пеленги: повышает износ оборудования в 3 раза (исключая износ в бою) и накладывает скрытый дебаф* (только для игрока), техника -10);
  11 - Ака Сециянка (только фэяне: шанс случайных дропов товара из трюма в космосе (только для игрока), точность -1, техника -2, торговля +2);
  12 - Новый молизон (только гаальцы: торговля медикаментами и едой на планетах считается контрабандой, точность и манёвренность по +1);
Номера стимуляторов:
  13 - Малокская сижа (точность +4, манёвренность +3);
  14 - Одноглазый Хамас (любой рэкет всегда будет успешен (только для игрока), обаяние и лидерство по -1);
  15 - Звёздная пыль (точность, манёвренность, техника и торговля по +1);
  16 - Супер техник (снижает износ оборудования на 60% (только для игрока), техника +5);
  17 - Гаалистра времени (повышает скорость корабля на 30%, точность +4, манёвренность +2);
  18 - Кровяной джогар (повышает иммунитет);
  19 - Рагобамский шёпот (обаяние +10 (а ещё можно есть рагобамских жаб, лол));
  20 - Ведущий Шахманду (увеличивает срок найма других кораблей в 2 раза (только для игрока), обаяние +1, лидерство +4);
  21 - Психотропный кэш (увеличивает дальность радара в 2 раза (только для игрока), мощность сканера +12, обаяние -3);
  22 - Торговая маркировка (увеличивает получаемый торговый опыт в 1,5 раза (для игрока, транспортов и рейнджеров), торговля +8);
  23 - Дубльплекс (увеличивает награду за правительственные задания в 1.3 - 2.3 раза (только для игрока), точность и манёвренность по -1);
  24 - Абсолютный статус (сроки исполнения правительственных заданий становятся в 1,5 раза мягче (только для игрока), обаяние +2);
    *Важно: Если игрок (и только игрок) болеет вихревой контузией, мышечным растяжением или горькой пеленошей (эффект не суммируется), то наносимый им урон получает скрытый дебаф и случайно умножается (в момент атаки) на значение от 0% до 100%.


Ход (даты):
GameDateTxtByTurn - возвращает строку с датой указанного хода (к примеру - 21 апреля 3301):
	1 - номер хода;
CurTurn - без аргументов, возвращает текущий ход:
	Без аргументов - вернуть номер текущего хода;
  Опционально:
	1 - установить новый номер хода;
ForceNextDay - без аргументов, принудительный запуск следующего хода;
IsFilm - проверяет проигрывается ли сейчас отображение хода (т.е. летают/стреляют ли по экрану корабли), если летают, то операции со сменой шкурок могут работать некорректно
(а могут и корректно, после последнего рефакторинга, но я не проверял);
FilmFlags - проверяет и выставляет различные условия для автоматического прерывания фильма (отображения хода) между ходами:
	1 - тип флага, либо система, в которой нужно его установить (систему имеет смысл ставить лишь ту, в которой находится игрок, так что её указывать не обязательно);
	2 - включить/выключить флаг (0 или 1), либо тип флага;
	3 - только включить/выключить флаг (0 или 1);
  Примеры:
	- FilmFlags(N) - проверяет установленный флаг (N в данном случае пустые скобки по идее);
	- FilmFlags(N, val) - устанавливает нужный флаг на следующий ход, например FilmFlags(3, 1);
	- FilmFlags(star, N) - аналогично проверяет флаг, но для определённой системы;
	- FilmFlags(star, N, val) - устанавливает флаг для определённой системы;
  Типы флагов:
	0 FilmBuild, film is being made for this star, can't set value
	1 - данный флаг прерывает фильм с началом боевых действий (игрок получил урон, либо нанёс урон сам);
	2 - данный флаг прерывает фильм если игрок подобрал предмет, форсаж износил двигатель ниже предельно допустимого значения, либо другой NPC инициировал разговор с игроком;
	3 - данный флаг не прерывает фильм вообще никогда (не используется в оригинальной игре);
	Все значения флагов проверяются кодом в конце хода и автоматически сбрасываются с началом следующего. То есть если вам нужен непрерывный полёт корабля из точки А в точку Б, то нужно будет каждый ход задавать глобальный (или конкретно для данной системы) флаг типа 3. Любой из установленных флагов сам игрок может прервать нажатием кнопки "Конец хода";
	//star - no reason normally to set flags 1..3 for stars other than player's location, but can be used to skip checking

Транклюкаторы:
UseTranclucator - активирует и возвращает адрес одного транклюкатора на любом корабле:
	1 - корабль (корабль, запустивший транклюкатора, автоматически становится его хозяином);
  Опционально:
	2 - артефакт-транклюкатор, который нужно активировать;
PlayerTranclucators - возвращает количество активных транклюкаторов игрока, или корабль конкретного активного транклюкатора:
	Без аргументов - возвращает количество;
  Опционально:
	1 - номер транклюкатора, начиная с 0;
!!!Для возврата конкретного транка функция PlayerTranclucators делает перебор всех кораблей в Галактике. Имейте это ввиду, когда будете работать над оптимизацией кода!!!
ArtTranclucatorToShip - возвращает корабль транклюкатора из артефакта:
	1 - артефакт (неактивный транклюкатор);
TranclucatorData - возвращает или устанавливает определённый параметр транклюкатора:
	1 - транклюкатор;
	2 - параметр (строкой или номером);
  Опционально:
	3 - новое значение параметра;
	  Параметры:
		0 или 'Proprietor' - хозяин транклюкатора;
		1 или 'ArtSize' - размер артефакта, в который превратится транклюкатор после сворачивания;
		2 или 'ArtSysName' - системное имя артефакта, в который превратится транклюкатор после сворачивания;
		3 или 'Docking' - маркер (0/1), при котором транклюкатор, имеющий приказ простого следования, залетит в трюм после сближения с хозяином;
		4 или 'SeekItems' - маркер, при котором транклюкатор будет заниматься сбором вещей;
		5 или 'AutoArrange' - маркер, при котором транклюкатор будет автоматически менять оборудование на более качественное из своего трюма;
		6 или 'LandStorage' - маркер, при котором транклюкатор после совершения посадки на любую планету или станцию, автоматически свернётся на склад в виде артефакта;
		7 или 'LandPermitPlanets' - маркер, при котором транклюкатору разрешены автоматические посадки на планеты при сборе вещей;
		8 или 'LandPermitRuins' - маркер, при котором транклюкатору разрешены автоматические посадки на станции при сборе вещей;
		9 или 'SeekPermitNone' - маркер, при котором транклюкатору разрешён сбор зондов, цистерн, карт сокровищ и корпусов (в оригинальной игре не используется);
		10 или 'SeekPermitArtefact' - маркер, при котором транклюкатору разрешён сбор артефактов (в т.ч. кастомных);
		11 или 'SeekPermitMicromodule' - маркер, при котором транклюкатору разрешён сбор микромодулей;
		12 или 'SeekPermitEquipment' - маркер, при котором транклюкатору разрешён сбор оборудования;
		13 или 'SeekPermitUseless' - маркер, при котором транклюкатору разрешён сбор ошмётков и прочих "юзлесов";
		14 или 'SeekPermitGoods' - маркер, при котором транклюкатору разрешён сбор товаров;
		15 или 'SeekPermitNode' - маркер, при котором транклюкатору разрешён сбор нодов и кастомных сыпучих;


Чёрные дыры:
GABStatus - локальная скриптовая переменная (по умолчанию имеется внутри каждого скрипта), отвечающая за заказ скриптом аркадного боя, значения:
	0 - АБ не заказан данным скриптом;
	1 - текущий скрипт заказал АБ;
	2 - заказанный АБ завершён и скрипт получает внеплановое срабатывание тернкода (сразу же в день завершения АБ, а не в день вылета игрока из ЧД/гипера);
  Примечание: По умолчанию тернкод во всех скриптах срабатывает перед началом АБ для игрока, так что можно поймать любой "залёт" в ЧД проверкой функции ShipInHole. Также имейте ввиду, что каждый ход, который игрок проведёт внутри ЧД будет также аналогичным образом обработан тёрнкодом, что нужно учесть, особенно если вы собираетесь запускать собственный бой АБ вместо стандартного игрового.
HoleCreate - создаёт и возвращает чёрную дыру:
	1 - место для создания входа в ЧД;
	2 - место для создания выхода из ЧД, тип места должен быть Free, Near Planet, To Star, From Group;
HoleCreate2 - создаёт и возвращает чёрную дыру по упрощённой схеме, если нет необходимости задавать её точные координаты:
	1 - система со входом в ЧД;
	2 - система с выходом из ЧД, остальное будет подобрано случайно (возвращает созданную ЧД);
HoleMap - возвращает или устанавливает карту аркадного боя для ЧД:
	1 - чёрная дыра;
  Опционально:
	2 - путь и название карты АБ ('ABMap.Map_name'), либо особый маркер:
	  'SkipAB' - автоматически пропустит аркадный бой при влёте игрока в данную ЧД;
	  'NoEntry' - запрещает игроку вход в данную ЧД, а также такая ЧД будет невидима на карте;
HoleTurnCreate - возвращает или устанавливает ход создания ЧД (фактически определяет день, когда она закроется):
	1 - чёрная дыра;
  Опционально:
	2 - какой ход создания установить;
  Примечание: Срок жизни обыкновенной ЧД (по умолчанию) составляет 200 дней со дня открытия.
HoleStar1 - возвращает или устанавливает систему со входом в конкретную ЧД:
	1 - ЧД;
  Опционально:
	2 - система, куда переместить точку входа;
HoleStar2 - возвращает или устанавливает систему с выходом из конкретной ЧД:
	1 - ЧД;
  Опционально:
	2 - система, куда переместить точку выхода из ЧД;
StarHoles - возвращает количество ЧД в системе, или конкретную ЧД из этого списка:
	1 - система;
  Опционально:
	2 - номер ЧД в списке;
GalaxyHoles - возвращает количество ЧД в галактике, либо конкретную ЧД из этого списка:
	Без аргументов - возвращает количество;
  Опционально:
	1 - номер ЧД в списке, вернёт конкретную ЧД;
HoleX1 - возвращает или устанавливает X координату входа в ЧД:
	1 - ЧД;
  Опционально:
	2 - новая X координата;
HoleY1 - возвращает или устанавливает Y координату входа в ЧД:
	1 - ЧД;
  Опционально:
	2 - новая Y координата;
HoleX2 - возвращает или устанавливает X координату выхода из ЧД:
	1 - ЧД;
  Опционально:
	2 - новая X координата;
HoleY2 - возвращает или устанавливает Y координату выхода из ЧД:
	1 - ЧД;
  Опционально:
	2 - новая Y координата;


Аркадный бой (все функции из данного списка применяются из тернкода, в момент влёта игрока в ЧД):
CreateABShip - создаёт (и возвращает указатель для изменения модификаторов) стандартный корабль для аркадного боя:
	1 - путь к анимации корабля в 'Main.dat\Data\SE' (например, 'Ship.Fei.Liner' создаст в АБ фэянский лайнер, а 'Ruins.Blazer' - Блазера);
  Опционально:
	2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
	3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
	4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
	5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
	6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ConvertToABShip - создаёт (и возвращает указатель для изменения модификаторов) корабль для АБ по шаблону реального игрового корабля:
	1 - корабль-шаблон;
  Опционально:
	2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
	3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
	4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
	5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
	6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ABShipModifiers - возвращает или устанавливает кораблю модификаторы для аркадного боя:
	1 - корабль;
	2 - модификатор строкой:
	   'damage' - наносимый урон (базовое значение 100);
	   'recharge' - скорость перезарядки орудий (базовое значение 100);
	   'speed' - скорость корабля (базовое значение 100);
	   'gravity' - то, как сильно на корабль будут действовать различные притягивающие объекты (базовое значение 100);
	   'regen' - скорость восстановления здоровья (базовое значение 0):
	      - Дроид младший: +100 (за каждого младшего дроида в слоте);
		  - Бонус-аптечка: +1000;
		 Примечание: Все перечисленные бонусы суммируются.
	   'fragility' - модификатор получаемого урона (базовое значение 100);
	   'luck' - шанс выпадения вещей из противников (базовое значение 100);
  Опционально:
	3 - какое значение установить (в теории принимает даже отрицательные значения, но как с ними будет работать код АБ неизвестно);
  Примечание: В обычной ситуации менять модификаторы можно самому игроку по событию t_OnStartAB или кораблям, создаваемым функцией CreateABShip. Однако, принимать в качестве корабля указатель на игрока (Player()) функция  может в любой момент, но если игрок при этом не находится в ЧД (или не сработало t_OnStartAB), то изменить модификатор она не сможет (вернёт 0). Может быть полезно для того, чтобы менять игроку модификатор от кастомного артефакта уже в процессе идущей аркадной битвы, если, например, игрок решит его снять или надеть.
StartAB - запускает аркадный бой с установленными выше условиями:
	Без аргументов - вернёт число всех заказанных на данный момент АБ, включая заказанные другими скриптами;
  Опционально:
	1 - имя АБ карты, номер или строка пути в CacheData вида 'ABMap.Map_name';
	2 - используемый фон в виде номера (от 1 до 4, где 4 - небесный фон) или полный адрес в CacheData строкой;
  Примечание: При вызове данной функции в момент залёта игрока в ЧД, стандартный заданный игрой аркадный бой будет заменён на установленный игроком вариант, с учётом всех созданных ранее в том же обработчике АБ кораблей и применённых модификаторов. Данная функция запускает аркадный бой, попутно выставляя маркер GABStatus = 1, так что все настройки этого боя должны быть заданы непосредственно перед вызовом данной функции.


Операции с нодами:
CreateNodes - создаёт ноды и возвращает на них ссылку:
	1 - количество;
  Опционально:
	2 - серия доминатора (0 - 2);
	3 - вид в космосе (0 - контейнер, 1 - ноды);
GetNodesFromShip - возвращает общее количество нодов на корабле или удаляет некоторое их количество:
	1 - корабль (возвращает количество);
  Опционально:
	2 - сколько нодов изъять;
GetNodesFromStorage - возвращает общее количество нодов на складе (игрока) или удаляет некоторое их количество:
	Без аргументов - возвращает общее количество нодов на всех складах;
  Опционально:
	1 - планета/станция, возвращает количество нодов на конкретной базе/планете;
	2 - сколько нодов изъять со склада планеты/станции;
RangerBaseNodes - возвращает или изменяет состояние нод-счёта рейнджера:
	1 - рейнджер (возвращает текущее состояние нод-счёта);
  Опционально:
	2 - какое состояние нод-счёта установить;


Запреты:
NoDropToShip - запрет кораблю дропать любые предметы при гибели:
	1 - корабль;
  Опционально:
	2 - запретить/разрешить дроп;
NoTargetToShip - проверяет, устанавливает и снимает запрет атаковать корабль:
	1 - корабль;
  Опционально:
	2 - изменить состояние запрета:
	   0 - разрешить атаковать корабль;
	   1 - запретить атаковать корабль данный корабль (включая нацеливание пушек) всем, кроме безусловно враждебных кораблей (доминаторы, военные и т.д.);
	   2 - запретить атаковать корабль данный корабль (включая нацеливание пушек) всем, кроме безусловно враждебных кораблей и игрока;
	   3 - запретить пиратам и рейнджерам по своей инициативе нападать на этот корабль с целью ограбления;
	   4 - запретить только рейнджерам по своей инициативе нападать на этот корабль с целью ограбления;
	   5 - запретить только пиратам по своей инициативе нападать на этот корабль с целью ограбления;
	   6 - повесить на корабль маркер квестовой цели, что будет привлекать повышенное внимание всяких пиратов и прочих грабителей;
NoTalkToShip - проверяет, устанавливает и снимает запрет разговаривать с кораблём:
	1 - корабль;
  Опционально:
	2 - запретить/разрешить переговоры;
NoScanToShip - проверяет, устанавливает и снимает запрет сканировать корабль:
	1 - корабль;
  Опционально:
	2 - запретить/разрешить сканировать корабль;
	   Примечание: Две вышеперечисленные функции могут ставить запрет на вызовы других кораблей (игрок не сможет самостоятельно вызывать/сканировать другие корабли) непосредственно для игрока. Для этого необходимо указать маркер 1 - установить запрет, или 2 - снять запрет, в качестве первого и единственного аргумента (пример: NoTalkToShip(1)). Соответственно, при вызове этих функций без аргумента, они вернут состояние конкретно данного запрета для игрока.
NoJump - проверяет, устанавливает и снимает запрет на совершение прыжков игроком:
	Без аргумента - проверяет наличие запрета;
  Опционально:
	1 - запретить/разрешить игроку совершать прыжки;
  Примечание: Чтобы скрытно повесить запрет совершения прыжков на NPC, можно использовать штраф bonFuel через функцию ShipSpecialBonuses() (либо bonJump, но такой штраф будет заметен в карточке двигателя). Учтите, однако, что такой "запрет" для NPC будет не безоговорочным, и в ряде случаев некоторые типы NPC (например, рейнджеры) будут нарушать данный запрет (например, если рейнджер стремится воссоединиться со своим напарником).
NoLanding - проверяет, устанавливает и снимает запрет игроку совершать посадку на конкретную планету или станцию:
	1 - планета/станция (проверяет состояние запрета);
  Опционально:
	2 - запретить/разрешить игроку посадку на указанный объект;
NoShopUpdate - проверяет, устанавливает и снимает запрет на автоматическое обновление магазина (одновременно оборудования и товаров) игрой:
	1 - магазин (планета или база);
  Опционально:
	2 - запретить/разрешить (1/0) автообновление ассортимента;
NoDropItem - проверяет, устанавливает и снимает запрет выбрасывать/перемещать предмет:
	1 - предмет;
  Опционально:
	2 - запретить/разрешить выбрасывать;
RuinsAllowModernization - проверяет или устанавливает разрешение у игрока на модернизацию базы:
	1 - база (проверяет наличие разрешения);
  Опционально:
	2 - разрешить/запретить игроку модернизацию базы;


Статистические данные:
DomikKilledInCurSystem - количество домиков, убитых в текущей системе (обнуляется при прыжке):
	1 - корабль;
ShipKillFactionInCurSystem - возвращает/устанавливает число конкретных кораблей, уничтоженных кораблём в текущей системе (счётчики обнуляются если корабль ушёл в гипер, попал в тюрьму, а также сразу после захвата системы):
	1 - корабль;
	2 - тип уничтоженных им кораблей:
	  -1 - корабли с кастомной фракцией;
	   0 - коалиционные корабли;
	   1 - доминаторы;
	   2 - клановые пиратские корабли;
  Опционально:
	3 - какое число уничтоженных кораблей данного типа установить;
  Примечание: Завышая с помощью данной функции число уничтоженных кораблей Коалиции или доминаторов можно "подбодрить" пирата (а заодно и всех остальных пиратов, т.к. успехи одного повышают общий процент успешности идущего боя) и, тем самым, снизить вероятность пиратского бегства из обороняемой системы. Также данную функцию можно использовать для определения, какие корабли кроме военных должны быть уничтожены пиратами для захвата системы (все корабли, успевшие убить хотя бы одного кланового пирата).
ShipStatistic - возвращает/изменяет указанные статистические данные корабля:
	1 - корабль;
	2 - тип статистики:
	   0 - убил всего;
	   1 - убил пиратов;
	   2 - убил доминаторов;
	   3 - освободил систем;
	   4 - убил мирных;
	   5 - убил военных;
	   6 - убил рейнджеров;
	   7 - убил врагов в ЧД;
	   8 - убил врагов в гипере (гиперпираты при перелётах между системами);
	   9 - текущее "торговое пенальти" игрока (накапливается при торговле в убыток и до тех пор, пока не будет полностью компенсировано прибылью, опыт и рейтинг за торговлю игроку начисляться не будет);
	   10 - родная планета корабля (в третьем аргументе её можно изменить);
	   11 - ход рождения корабля;
  Опционально:
	3 - новое значение выбранной статистики;
PlayerDominatorStatistic - возвращает/изменяет число доминаторов определённой серии, уничтоженных игроком:
	1 - серия доминаторов:
	   0 - блазероиды;
	   1 - келлероиды;
	   2 - терроноиды;
  Опционально:
	2 - новое число уничтоженных доминаторов указанной серии;
PlayerQuestsCompleted - возвращает число выполненных игроком заданий определённого типа;
	1 - тип задания:
	  0 - доставка грузов;
	  1 - убийства кораблей;
	  2 - текстовые квесты;
	  3 - защита систем;
	  4 - защита кораблей;
PlayerPlanetaryBattlesCompleted - без аргументов, возвращает число выполненных игроком планетарных боёв;
QuestsStatusByNom - принимает тип и номер правительственного задания (включая несюжетные ТК), и возвращает его статус:
	1 - тип квеста:
	  0 - SendLetter;
	  1 - KillShip;
	  2 - PlanetQuest;
	  3 - DefSystem;
	  4 - DefShip;
	2 - номер квеста (есть в Lang в разделе Quest);
	   Возвращаемые типы статусов:
	      0 - not taken;
		  1 - taken;
	  	  2 - completed;
		  3 - completed and got reward;
		  4 - failed;
GalaxyDominatorResearchPercent - возвращает процент исследования доминаторов на НБ:
	Без аргументов - вернёт общий процент исследования доминаторов на НБ;
  Опционально:
	1 - число, вернет процент исследования конкретной расы доминатора;
	2 - установить новое значение;
GalaxyDominatorResearchMaterial - возвращает количество материала для исследования доминаторов на НБ:
	Без аргументов - вернёт общее количество материала для исследования доминаторов на НБ;
  Опционально:
	1 - число, вернёт количество материала для исследования конкретной расы доминатора;
	2 - установить новое значение;
GalaxyTechLevel - возвращает текущий ГТУ;
GalaxyDiffLevels - возвращает среднюю сложность игры, либо значение одной из конкретных настроек (от 50 до 500), без аргументов возвращает общую сложность, номера отдельных настроек:
	0 - пираты;
	1 - разброс цен;
	2 - учёные;
	3 - поломки;
	4 - оборудование;
	5 - задания;
	6 - чёрные дыры;
	7 - удача;


Стандартные операторы:
unknown - объявляет переменную неопределённого типа (нужна для последующего объявления/зачистки массивов или внешних функций);
  Примечание: Если приравнять значение unknown переменной любой другой (при помощи функции copy()), то вторая переменная также получит значение unknown. Это может быть полезно, если необходимо, например, зачистить массив без удаления его структуры (что особенно актуально для многомерных массивов) для последующей перезаписи его значениями другого типа.
int - объявляет переменную типа integer;
dword - объявляет переменную типа dword;
str - объявляет переменную типа string;
float - объявляет переменную типа double (название не соответствует фактическому типу в дабоязыке);
  Примечание: При объявлении переменных в скрипте, переменные, объявленные визуальным объектом, равны по валидности переменным, объявленным внутри кода, однако для улучшения читабельности и во избежание путаницы, все скриптовые переменные желательно объявлять как визуальные объекты. В прочих кодах (Act, Use и т.д.) объявлять переменные возможно только в коде, однако место их объявления не имеет никакого значение для определения переменной, поскольку компилятор запоминает все объявленные переменные в момент своего первого прохода по коду, благодаря чему конструкции вида: if(!var){int var = 1;} - не приведут к крашу.
if - стандартный оператор условия;
else - стандартный оператор, исполняющий условие, если предыдущий if исполнен не был, всегда должен стоять после if и допускает конструкции вида:
  if(...)
  { ... }
  else if(...)
  { ... }
for - стандартный цикл перебора по определённому счётчику с условием:
	1 - начальное значение числа (например, i = 0);
	2 - условие с числом (например, i <= 3);
	3 - операция с числом после каждого прохода цикла (например, i = i + 1);
  Примечание: Аргументы цикла for разделяются символом ';'.
while - стандартный цикл перебора до тех пор, пока исполняется указанное в нём условие:
	1 - условие (например, i != 0);
exit - вызывается без скобок, прерывает дальнейшее исполнение кода в текущем операторе;
continue - вызывается без скобок, прерывает дальнейшее исполнение текущего круга цикла - переводит цикл на следующий круг;
break - вызывается без скобок, прерывает дальнейшее исполнение текущего цикла, завершает его;
function - объявляет функцию, которая будет доступна только внутри конкретного скрипта, пример: function MyFun(X, Y){ ... }
  Примечание: По умолчанию все переменные функции имеют тип unknown, однако при желании можно указать им определённый жесткий тип. Переменные функции существуют лишь внутри самой функции, однако внешние глобальные переменные и переменные скрипта функция может использовать без каких-либо ограничений.
result - обозначает возврат внутренней скриптовой функции и записывается внутри неё, пример: result = X + Y;
throw - выбрасывает эксепшен и вызывает краш игры, выносит в лог указанный текст:
	1 - текст или число для вывода в лог (пример: throw 'No, no, no!';);
== - равно;
!= - неравно;
! - знак неравенства, обозначает проверку на возврат 'false', которое в дабокоде обозначается исключительно числом 0 (поскольку булевы переменные в нём отсутствуют). Аналогичная проверка на 'true' будет срабатывать при возврате от условия любого положительного или отрицательного числа, кроме 0.
~ - побитовое отрицание, которое можно использовать для быстрой (точнее более оптимальной) проверки неравенства значения переменной числу -1. Пример: if(~N), где N == -1 вернёт 0, а во всех остальных случаях не 0.
  Важно: С точки зрения оптимизации проверки вида if(!(~N)) как аналог if(N == -1) по быстродействию неэффективны, а их использование в данном случае неоправданно.
> - больше;
>= - больше или равно;
< - меньше;
<= - меньше или равно;
% - производит деление числа на указанное значение и возвращает только остаток (целый, без учёта возможной дробной части) от такого деления, пример: 123 % 10 = 3, 1000 % 10 = 0;
& - побитовое сравнение И;
| - побитовое сравнение ИЛИ;
&& - логическое сравнение И;
|| - логическое сравнение ИЛИ;
<< - побитовый сдвиг на определённую позицию вперёд (запись 1 << N в данном случае будет эквивалентна 2 ^ N (2 в степени N), а 4 << N эквивалентна 4 * 2 ^ N);
>> - побитовый сдвиг на определённую позицию назад (запись 1 >> N в данном случае будет эквивалентна 1 / 2 ^ N с отбрасыванием дробной части);
\\ - комментирование строки;
\ - экранирование символа " ;
\\\ - экранирование символа ' ;


Служебные:
Rnd - возвращает псевдослучайное целое число из диапазона:
	1 - нижняя граница;
	2 - верхняя граница (могут быть отрицательными) (без включения тонкой настройки на полный рандом, данная функция использует заранее определённое галактическое зерно, что гарантирует идентичность бросков даже после перезагрузки игры);
  Опционально:
	3 - задать своё зерно для текущего броска;
rnd - возвращает псевдослучайное целое число, начиная с нуля:
	1 - верхняя граница диапазона минус один (то есть rnd(5) будет возвращать результаты только от 0 до 4);
  Примечание: В отличие от Rnd(), rnd() всегда возвращает случайный результат, т.к. зерно определяется рандомно. А ещё, в отличие от Rnd(), rnd() полное говно и никому не рекомендую использовать эту кривую дельфийскую поделку!
randomize - автоматически перемешивает зерно для функции rnd;
randseed - позволяет узнать или задать текущее зерно для функции rnd:
	Без аргументов - узнать текущее зерно;
  Опционально:
	1 - задать новое зерно;
loadlibrary - загружает в память dll-библиотеку и записывает её адрес в переменную dword, которую потом можно использовать в функции libraryfunction:
	1 - путь загрузки относительно папки с игрой (строкой);
  Пример: dword lib = loadlibrary('Mods\YourMod\YourLib.dll');
freelibrary - очищает память, занятую под dll-библиотеку, и возвращает int с результатом:
	1 - dword с адресом dll-библиотеки;
libraryfunction - загружает из переменной с адресом dll-библиотеки в указанную переменную функцию, и устанавливает ей значение скрытого типа LibraryFun, поэтому присваивать функцию нужно всегда переменной с типом unknown:
	1 - dword с адресом dll, полученный через функцию loadlibrary;
	2 - тип возвращаемого загружаемой функцией значения строкой (доступны только int, dword, str и float), а если возврата нет, то без разницы;
	3 - название функции в dll, которую необходимо загрузить в переменную;
	4, 5, 6, и т.д. - типы аргументов загружаемой функции (также строкой) по порядку;
  Пример: unknown fun = libraryfunction(lib, 'dword', 'FunctionName', 'str', 'dword', 'dword');
  В результате, объявленную переменную с функцией можно будет использовать в качестве обычной функции: fun(arguments);
  Примечание: Возврат значения из данных функций возможен только для переменных типа int, dword, str (получение str в C++ должна производиться типом wchar_t* с типом самой функции const wchar_t*, подробности в примере ниже) и float (получение и передача float в C++ должна производиться типом unsigned int, подробности в примере ниже). Передавать в качестве аргументов можно переменные любых типов.
    Пример функции в C++ для получения, изменения и возврата строки скрипту:
		//Для использования типа string
		#include <string>
		//Для конвертации wstring
		#include <locale>
		#include <codecvt>

		//Для записи всех необходимых функций внутрь самой библиотеки необходимо использовать следующую настройку:
		//Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded(/ MT) (для релиза)
		//Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded Debug(/ MTd) (для дебага)
		//Подробнее: https://stackoverflow.com/questions/3162325/after-building-exe-using-vs-2010-c-missing-msvcp100-dll

		using namespace std;
		//Объявляем экспортируемость функции (актуально в VS 2019 для сборки dll на C++)
		extern "C" __declspec(dllexport)
		//Объявляем саму функцию и получаемый из скрипта аргумент в виде str
		const wchar_t* StringChange(wchar_t* script_str)
		{
			//Для дальнейшего успешного возврата строки в игру нам потребуется статичная переменная
			//Статичные переменные объявляются лишь раз, поэтому обязательно выносим объявлением на отдельную строку
			//Также для удобства статичную переменную можно объявить и вне конкретной функции, что актуально, если вы собираетесь писать сразу несколько разных экспортных функций с возвратом строки в игру
			static wstring wide_string;
			//Если нам необходимо преобразовать wchar_t*, полученный из игры, в string, то подойдёт следующий способ
			//Для удобства данный класс можно объявлять и вне функции в общем пространстве dll
			static wstring_convert<codecvt_utf8<wchar_t>> convert;
			//Применив его, на выходе получим простую string
			string basic_string = convert.to_bytes(script_str);
			//Производим необходимые действия с полученной строкой
			basic_string += "Some text";
			//Аналогичную операцию проводим для преобразования string в статичный wstring для последующего возврата значения в игру
			wide_string = convert.from_bytes(basic_string);
			//После чего возвращаем скрипту wstring в виде константы (также необходимое условие)
			return wide_string.c_str();
		}
    Пример функций в C++ для преобразования float ИЗ и В скриптовый формат:
		//Функция для преобразования переменной типа float из C++ в тип unsigned int, распознаваемый скриптом
		unsigned int FloatToGame(float a)
		{
			return *(unsigned int*)&a;
		}
		//Функция для преобразования переменной типа unsigned int, полученной как float из скрипта, в стандартный double, используемый в C++
		double FloatFromGame(unsigned int a)
		{
			return *(float*)&a;
		}
		  Примечание: Обратите внимание, переменная float в дабоязыке на самом деле double, однако передача значений в DLL доступна лишь в 32-битном формате, поэтому фактически обмен идёт в виде реальных типов float.
ImportAll - производит автоматическое объявление и загрузку в переменные всех функций из объявленной в Main dll-библиотеки:
	1 - имя библиотеки строкой;
  Примечание: Данную функцию удобно использовать для подключения внешних функций конкретному интерфейсному, Act- или Use- коду. Все объявленные таким образом функции будут автоматически выгружены из памяти при перезагрузке или выходе из игры. Для сокращения обращений к данной функции (и сокращения лишних переобъявлений функций) при повторных срабатываниях кода допустимо использовать следующую конструкцию в начале нужного кода (объявление LibInit должно оставаться внутри условия):
	01=if(!LibInit)
	02 ^{
		01=int LibInit = 1;
		02=ImportAll('LibName');
	}
ImportedFunction - производит упрощённое объявление новой функции из dll, при условии предварительного указания библиотеки и нужной функции из неё в Main.dat:
	1 - название объявленной в Main библиотеки строкой;
	2 - название конкретной функции строкой (пример: unknown PortionInDiapason = ImportedFunction('UtilityFunctions', 'PortionInDiapason'));
  Пример объявления dll с функциями в Main.dat:
	Data {
		ScriptLibs ^{
			UtilityFunctions ^{ //Название библиотеки для подстановки в ImportedFunction
				Path=Mods\Tweaks\UtilityFunctionsPack\DATA\UtilityFunctions.dll //Путь до файла dll
				RoundTo=float,RoundTo,float,float,int //Название и объявление функций из библиотеки (аналогично libraryfunction)
				PortionInDiapason=float,PortionInDiapason,float,float,float,float,float
				IsShiftCtrlPressed=int,IsShiftCtrlPressed
				DeclareBonusArray=void,DeclareBonusArray,int
			}
			ScriptName=UtilityFunctions,LibName2,LibName3 //И т.д., объявление библиотек и полного набора их функций для конкретного скрипта ScriptName, при этом при подобном объявлении никаких дополнительных операций в самом скрипте производить не нужно, все функции из объявленных в Main библиотек будут доступны в скрипте с самого начала его инициализации
		}
	}
  Примечание: Первым в списке указателя функции идёт тип её возврата, однако если функция не подразумевает возврата вовсе (void), то вместо типа можно указать любое невалидное значение. Тот же void для этого вполне подойдёт.
new - создаёт и записывает в переменную новый экземпляр класса:
	1 - название нового класса строкой (запоминать нужно в переменную с типом unknown, т.к. вернётся в неё тип class);
delete - удаляет экземпляр класса из переменной:
	1 - переменная с типом class;
round - применить банковское (стандартное для игры) округление к дробному:
	1 - число;
  Опционально:
	2 - к какому целому числу округлять (по умолчанию округляет к единицам):
	   1 - к единицам;	
	   10 - к десяткам;
	   100 - к сотням;
abs - возвращает модуль числа:
	1 - число (int или float);
min - возвращает наименьшее число из представленных:
	1 - первое число;
	2 - второе число;
	3 - третье число и т.д. (int или float);
max - возвращает наибольшее число из представленных:
	1 - первое число;
	2 - второе число;
	3 - третье число и т.д. (int или float);
int - возвращает целое, отбрасывая дробную часть (аналогично округлению в меньшую сторону, но в целом как функция почти бесполезна):
	1 - число;
frac - возвращает дробную часть, отбрасывая целое:
	1 - число;
sqr - возводит число в квадрат:
	1 - число;
sqrt - извлекает из числа квадратный корень:
	1 - число;
pi - не функция (!!!), а просто общая переменная, в которой записано число Пи (точное значение в переменной: 3.14159265516356);
sin - вычисляет синус:
	1 - число;
cos - вычисляет косинус:
	1 - число;
arctan - вычисляет и возвращает в радианах арктангенс числа:
	1 - число;
exp - вычисляет экспоненту:
	1 - число;
ln - вычисляет натуральный логарифм:
	1 - число;
count - возвращает число символов в строке:
	1 - строка;
trim - удаляет все пробелы, табуляции и переносы строк с правого и левого края строки:
	1 - строка;
substr - выделяет и возвращает указанный набор символов из строки:
	1 - строка;
	2 - номер отсчётного символа (начиная с 0), по умолчанию вернёт весь остаток строки, начиная с символа под указанным номером;
  Опционально:
	3 - сколько символов из строки вернуть, начиная с отсчётного (пример - substr('wxyz', 1, 2) вернёт 'xy', а без указания третьего аргумента вернёт весь остаток строки 'xyz');
findsubstr - ищет в строке определённую строку и при успехе возвращает номер первого символа найденной строки:
	1 - строка;
	2 - какую строку ищем (пример - findsubstr('xyz', 'y') вернёт 1) - при неудаче возвращает -1;
lowercase - превращает все буквы в строке в строчные:
	1 - строка;
uppercase - превращает все буквы в строке в заглавные:
	1 - строка;
copy - копирует одну переменную в другую с сохранением типа:
	1 - в какую переменную копировать;
	2 - из какой переменной копировать (допустимо копировать переменную "из" и "в" ячейку массива, включая переменные типа unknown);
ord - возвращает числовой код символа:
	1 - символ;
toansi - переводит кодировку строки в ANSI:
	1 - строка;
tounicode - переводит кодировку строки в UTF-16 (стандартная кодировка для игры, BlockPar по умолчанию сохраняет в ней все .dat):
	1 - строка;
Sound - воспроизводит указанный звук:
	1 - строка пути к звуку в 'CacheData/Bm', пример: Sound('Sound.QuestOk') воспроизведёт звук выполненного задания;
Format - ищет в первом аргументе (строке) сочетание символов из второго аргумента и заменяет на третий, допускается использование множества замен в одной операцией:
	1 - исходная строка;
	2 - что заменить в исходной строке;
	3 - на что это заменить;
	4, 5 аналогично 2, 3 и т.д.;
	6 - либо любой чётный аргумент (строкой) в конце списка задаёт, либо выключает тэги цвета, которые будут автоматически подставлены вокруг всех замен:
	  '' - отключить подстановку цветовых тэгов;
	  '255,255,255' - какой цвет задать подстановкам в формате RGB;
  Пример: Format('Траляля#0# - мне на всё плевать!', '#0#', '-ляля'); - вернёт строку: 'Траляля<color=0,50,200>-ляля</color> - мне на всё плевать!';
CT (вероятно означает "Copy Text") - возвращает строковое значение указанного параметра из Lang.dat:
	1 - строка вида 'путь к параметру в датнике', пример: CT('Items.Engine.Type.8') вернёт слово 'Темпоральный';
GetMainData - функция аналогичная CT, позволяет получить значение параметра по адресу его элемента из Main.dat:
	1 - строка вида 'путь к параметру в датнике', пример: GetMainData('Data.SE.Planet.001.BG') - вернёт 312;
GetGameOptions - возвращает значение указанного параметра из игрового конфига (CFG.TXT):
	1 - название параметра;
  Пример: 'ResolutionX' или 'ResolutionY' - вернёт разрешение экрана по X или Y (в виде int). Если запросить 'VideoMode', то вернет их же, но одной строкой через запятую (соответственно в виде str);
  Примечание: Функция берёт значения из уже загруженной в память копии конфига, поэтому изменение .txt файла при запущенной игре не даст видимого результата.
CurrentMods - возвращает общее количество подключённых модов или путь к конкретному подключённому моду:
	Без аргументов - вернёт общее количество подключённых модов;
  Опционально:
	1 - номер мода в списке (начиная с 0), вернёт путь к конкретному подключённому моду;
  Примечание: Моды в списке располагаются в том же порядке, что и в логе. Возвращаемые пути имеют вид 'Evolution\EvoBalance'.
SFT - выводит в лог-файл любое значение (например, SFT(ShipName(Player())) выведет в лог имя игрока), допускается множество аргументов, незаменимая функция для отладки:
	1 - какое значение или строку вывести в игровой лог;
BlockExist - проверяет наличие указанного раздела в Lang:
	1 - путь к разделу в Lang.dat (например, 'Artefacts.CustomArtefacts.EMP_bomb');
ResourceExist - ищет в CacheData указанный ресурс (не путь до файла, а уже объявленный ресурс) и при успехе возвращает 1:
	1 - путь к разделу в CacheData.dat, начиная с самого корня (например, 'Bm.FormShip2.YourResourceName');
CreateActCodeEvent - вручную запускает заданный акткодовый эвент определённой инфошки или предмета:
	1 - тип эвента, например t_OnStep, t_OnTakingDamage и т.д.;
	2 - предмет или корабль, из акткода которого будет исполнено событие (для корабля событие сработает сразу во всех его инфошках, в которых оно есть);
	3 - корабль, т.е. то, что будет возвращать функция ScriptItemActShip() в обработчике;
	4 - то, что будет возвращать функция ScriptItemActObject1();
	5 - то, что будет возвращать функция ScriptItemActObject2();
	6 - параметр, т.е. ScriptItemActParam() (при желании, через ScriptItemActParam в самом акткоде события можно что-нибудь вернуть, возвращаемый параметр будет являться результатом вызова CreateActCodeEvent);
GenerateCodeStringFromBlock - создаёт из блока датника готовый код и записывает его в строку:
	1 - путь к разделу с кодом (ActCode или UseCode) в Lang;
  Примечание: Готовую строку кода можно подставлять в скриптовые объекты функцией ItemOnActCode или ItemOnUseCode;
ExecuteCodeFromString - исполняет код из строки, позволяет передавать код между скриптами с помощью глобальных переменных или создать таким образом полноценную глобальную функцию:
	1 - строка с кодом;
  Опционально (для создания функции):
	2 - первый аргумент для исполняемой строки в виде строки (имя переменной-аргумента внутри создаваемой функции);
	3 - значение первого аргумента для исполняемой строки (можно подставить сюда любое значение или другую переменную);
	4 - второй аргумент для исполняемой строки в виде строки, либо (если не добавлять 5 аргумент) результат возврата вызова основной функции ExecuteCodeFromString, то есть, по сути, возврат функции из исполняемой строки (имя возвратной внутренней переменной указывать также строкой);
  Примечание: Аргументов для исполняемой строки можно задать сколько угодно, но при этом правило следующее: при нечётном числе аргументов функции ExecuteCodeFromString возврата не будет, а при чётном - последний аргумент всегда будет считаться её возвратом. Если последний возвратный аргумент объявлен как новая переменная, то его непосредственное объявление (присвоение типа int, str и т.д.) должно происходить в самой исполняемой строке. Если же для возврата указан один из ранее указанных аргументов, например: ExecuteCodeFromString('NewsAdd(X);', 'X', 1, 'X') - то дополнительно объявлять возвратную переменную не нужно.
  Наглядный пример использования: tempVar = ExecuteCodeFromString('varZ = varX + varY; int result = varZ;', 'varX', 2, 'varY', 2, 'varZ', 0, 'result'); - где tempVar в конечном итоге получит значение из временного аргумента varZ, то есть 4 (возвратная переменная result здесь так названа чисто для удобства, но на самом деле может иметь любое имя). Также в данном конкретном примере можно было обойтись и без объявления возвратной переменной, указав вместо неё напрямую 'varZ'.
  Ещё примечание: Для передачи кода между скриптами, вместо глобальных переменных можно использовать обычные переменные и функцию GetValueFromScript(). Также, вместо использования переменных, общий код можно записывать прямиком в Lang, после чего извлекать его функцией CT и получать готовую исполняемую строку, которую, при желании, будет легко изменить даже без обращения к скрипту.
GetValueFromScript - позволяет узнать значение конкретной переменной (в т.ч. вернуть скриптовый предмет, но не группу, т.к. скриптовая группа - это номер) или элемента массива из конкретного скрипта (в случае отсутствия скрипта вернёт unknown). Работает в том числе и из акткода:
	1 - имя скрипта строкой (путь указывать не нужно);
	2 - имя переменной или массива строкой (не указывать глобалки, иначе крашнет, однако можно указывать общие игровые переменные типа t_Weapon1);
  Опционально:
	3 - индекс массива, если проверяется массив (номер числом или имя строкой);
	4, 5, 6 и далее - дополнительные индексы для многомерных массивов;
  Примечание: При запросе общих игровых переменных вроде t_Weapon1 (иногда бывает полезно) скрипт указывать не обязательно. Вместо него можно оставить пустую строку ''. Если же вы запрашиваете переменную из конкретного скрипта, то этот скрипт должен быть обязательно активен (в момент срабатывания своего иниткода скрипт уже считается активным).
StartVideo - добавляет видеоролик в список на воспроизведение, либо возвращает число роликов в очереди:
	Без аргументов - возвращает количество скриптов, которые показывали видео (или количество скриптов, ожидающих показа видео);
  Опционально:
	1 - путь к видеофайлу;
	2 - название (путь) звуковой дорожки в разделе 'Bm.Sound' (пример: StartVideo('data\record.vdo', 'Record'));
GVideoStatus - общая глобальная переменная, используемая для показа видеороликов скриптом, возможные значения:
	0 - ролик не воспроизводится;
	1 - ролик заказан скриптом;
	2 - ролик завершился;


Для работы с интерфейсом:
CurrentForm - возвращает текущую открытую форму строкой (все игровые формы прописаны в Main.dat, в разделе ML):
  Оригинальные формы:
	'StarMap' - форма общего экрана космоса;
	'Film' - форма просмотра повтора хода(ов) в космосе;
	'AB' - форма аркадных боёв и перелёта между системами, при включении соответствующей ТН;
	'Talk' - дочерняя форма диалога с кораблём/станцией в космосе;
	'Planet' - форма экрана обитаемых планет;
	'PlanetNO' - форма экрана необитаемых планет (вызываемое меню для размещения зондов также находится здесь);
	'PlanetQuest' - форма прохождения текстового квеста;
	'Gov' - форма планетарного правительства;
	'RuinsTalk' - правительство и общий экран станции (а также все мостики);
	'GoodsShop' - дочерняя форма магазина товаров;
	'EquipmentShop' - дочерняя форма магазина оборудования;
	'Info' - дочерняя форма инфоцентра;
	'Hangar' - дочерняя форма ангара;
	'Ship' - дочерняя форма, изменяемое игроком меню корабля (его собственный корабль, его транклюкатор, станция с проплаченным взносом на изменение);
	'Scaner' - дочерняя форма, не изменяемое игроком меню корабля (при сканировании других NPC);
	'Rewards' - дочерняя форма меню просмотра правительственных наград/медалей, открываемое через форму 'Ship';
	'Rating' - дочерняя форма рейтинга рейнджеров;
	'Galaxy' - дочерняя форма галакарты;
	'Journal' - дочерняя форма бортового журнала игрока;
	'SelectFace' - дочерняя форма выбора расы, лица и имени, вызываемая из 'RuinsTalk' при смене подданства на ПБ;
	'Quest' - неиспользуемая в игре (и, видимо, недоделанная) дочерняя форма со списком всех текущих заданий игрока;
	'Count' - дочерняя форма вызова интерфейсного элемента CountBox;
	'Number' - дочерняя форма вызова интерфейсного элемента NumberBox;
   Примечание: Элементы MessageBox, TextBox и ListBox конструируются кодом в момент вызова, а потому отдельных форм не имеют.
	'GameMenu' - дочерняя форма игрового меню, вызываемого по Esc;
	'MainForm' - главное (первое) меню игры;
	'SaveManager' - форма экрана сохранения/загрузки игры;
	'CfgSettings' - форма основных игровых настроек;
	'Achievements' - дочерняя форма просмотра игровых достижений;
	'LoadRobot' - дочерняя форма выбора планетарных боёв в главном меню;
	'LoadQuest' - дочерняя форма выбора текстовых квестов в главном меню;
	'LoadAB' - дочерняя форма выбора аркадных боёв в главном меню;
	'ModsManager' - дочерняя форма выбора подключённых модов в главном меню;
	'Score' - форма экрана результатов игры (очки и таблица рекордов);
	'GameSettings' - форма экрана настроек перед началом новой игры;
	'Introduction' - форма экрана загрузки новой игры с введением: "Добровольцы! Вы сделали правильный выбор...";
	'GameEnd' - форма экрана конца игры (когда игрок победил или проиграл/погиб);
	'GameLoad' - форма экрана загрузки игры из главного меню;
	'Jump' - форма экрана загрузки во время прыжков между системами (но не в ЧД);
	'Load' - форма экрана загрузки во всех остальных случаях;
	'About' - форма экрана игровых титров;
	'Style' - вспомогательная служебная форма, содержащая в себе различные элементы (вроде скролл-бара), из которой все прочие формы могут выдёргивать необходимые им куски (но это не точно);
  Кастомные формы:
	'AutoSearch' - форма оформления запроса автопоиска из мода ExpAutoSearch;
FormChange - выполнить переход на другую форму:
	1 - имя формы строкой;
  Опционально:
	2 - конкретный корабль/станция, если вызывается открытие формы 'Ship' (будет открыта форма 'Ship' для указанного корабля);
RunChildForm - выполнить переход на другую форму, которая будет считаться дочерней по отношению к текущей, и при закрытии вернётся на неё же. Используется для переходов на формы, которые изначально не имеют возможности открываться друг за другом (например, с 'Ship' на 'Galaxy'):
	1 - форма строкой;
  Опционально:
	2 - режим, в котором откроется форма Galaxy:
	  0 - fgm_Teleport (телепортирует корабль в указанную систему после закрытия формы, есть базовая анимация);
	  1 - fgm_Show (режим простого просмотра без возможности совершить прыжок);
	  2 - fgm_Move (будет отдавать приказ на обычный прыжок между системами);
	  3 - fgm_BlackHole (будет открывать ЧД, как на ТИ);
  По умолчанию дочерняя форма 'Galaxy' откроется в режиме fgm_Teleport;
UpdateFormShip - без аргумента, обновляет форму 'Ship'. Используется для быстрого обновления формы корабля после различных действий (например, после выброса предмета в космос);
FormCurShip - без аргументов, возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner' (помогает определить, что форма 'Ship' открыта для станции или транклюкатора, а не для корабля игрока);
UICheckElement - проверяет текущее состояние элемента (Panel, GraphButton, Image и т.д.):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя элемента;
	3 - тип проверки;
	  Возможные типы:
	    'IsActive' - возвращает состояние элемента, скрыт/виден;
	    'IsDisable' (только для кнопок) - вернёт 1, если кнопка видна, но заблокирована (аналогично кнопке связи, когда у корабля отсутствует радар);
		'IsDown' - проверка состояния кнопки, нажата ли она в текущий момент (полезно для проверки состояний кнопок-чекбоксов);
		'PosX' - текущая позиция элемента по оси X (учитывает скорректированное значение, если автокоррекция имела место быть);
		'PosY' - текущая позиция элемента по оси Y (учитывает скорректированное значение, если автокоррекция имела место быть);
	    'Text' (только для Label и Edit) - позволяет вернуть текущий текст элемента или задать текст для Edit четвёртым аргументом;
	    'Image' (только для Image, GI или GAI) - позволяет вернуть путь к изображению или выставить этот путь четвёртым аргументом;
	    'CurFrame' (только для GAI) - возвращает текущий активный кадр анимации (нумерация начинается с 0);
  Опционально:
	4 - задаёт текст или путь к изображению для элемента, если 3-м аргументом выбран 'Text' или 'Image', либо меняет состояние нажатости кнопки, если выбран 'IsDown' (привязанный к кнопке обработчик при таком переключении исполнен не будет);
  Примечание: В отличие от функций описанных ниже, способных работать только с установленными оверрайдами элемента, UICheckElement может возвращать информацию для любых игровых элементов вне зависимости от наличия на них скриптового оверрайда.
InterfaceState - добавляет элементу (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний или возвращает состояние уже имеющегося оверрайда:
	1 - название формы строкой;
	2 - имя элемента строкой;
  Опционально:
	3 - установить оверрайд:
	  -1 - убрать оверрайд;
	   0 - скрыть элемент;
	   1 - показать элемент;
	   2 - заблокировать кнопку (Disable);
	   3 - разблокировать кнопку (Enable);
InterfaceText - возвращает/устанавливает текст элемента (вешает оверрайд), если ранее текст в элементе не изменяли данной функцией, то вернёт пустую строку:
	1 - название формы строкой;
	2 - имя элемента (только для типов Label и Edit);
  Опционально:
	3 - новый текст;
InterfaceImage - возвращает/устанавливает картинку элемента (вешает оверрайд), если ранее изображение в элементе не изменяли данной функцией, то вернёт пустую строку:
	1 - название формы строкой;
	2 - имя элемента (только для классов GI, GAI или Image, либо любого элемента в случае замены параметра);
  Опционально:
	3 - путь к новому изображению, либо указатель на замену конкретного параметра выбранного элемента, подробности ниже;
  Примечание: Данная функция может заменять значения любых параметров в любом элементе, для чего третьим аргументом необходимо указать 'Style:Полный путь к разделу с изменяемым параметром'. Путь к параметру должен указывать на раздел, содержащий только необходимый параметр и его новое значение, пример:
	ChangeParam ^{
		Param=NewValue
	}
  С помощью данного метода можно менять любые "статичные" параметры, вроде Help или StyleBarY.
InterfacePos - устанавливает (вешает оверрайд) новые координаты указанного элемента:
	1 - название формы строкой;
	2 - имя элемента;
	3 - смещение по оси Х;
	4 - смещение по оси Y (под смещением подразумевается смещение относительно текущего местоположения элемента);
	5 - позиция элемента по оси Z;
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
InterfaceSize - устанавливает (вешает оверрайд) параметр Size элемента:
	1 - название формы строкой;
	2 - имя элемента;
	3 - размер по оси Х;
	4 - размер по оси Y;
ButtonClick - запускает кодовый обработчик клика указанной кнопки (не изменяет состояние нажатости кнопки, для этого нужно воспользоваться функцией UICheckElement):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя кнопки;
SetFocus - задаёт фокус указанному элементу (в частности элементу типа Edit):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя элемента;
StarMapCenterView - центрирует камеру на определённой точке космоса (без звука):
	1 - координата Х;
	2 - координата Y;
  Опционально:
	3 - число циклов анимации сходящейся на целевой точке окружности, по умолчанию воспроизводится три раза (можно указать дофига, но проигрываться оно будет очень долго);
StarMapCurPosX - без аргументов, возвращает текущую координату X позиции камеры на форме 'StarMap' (в космосе);
StarMapCurPosY - без аргументов, возвращает текущую координату Y позиции камеры на форме 'StarMap' (в космосе);

Для работы с кастомными формами:
OpenCustomForm - открывает кастомную форму: путь к кастомной форме, начиная из папки "Main.ML" (если кастомная форма прописана сразу в разделе 'ML', то просто указать её имя);
CloseCustomForm - закрывает открытую кастомную форму:
   - Без аргументов, либо 1 - закрыть текущую открытую кастомную форму;
   - 0 или любой другой аргумент - отмена выхода с кастомной формы (отменить закрытие из блока CodeAfterRun невозможно, так что хз зачем оно нужно вообще);
   - 255 - закрыть родительскую форму (не знаю нафига нужно);
CustomInterfaceState - добавляет элементу на текущей открытой кастомной форме (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний или возвращает состояние имеющегося оверрайда:
	1 - имя элемента строкой;
  Опционально:
	2 - установить оверрайд:
	  -1 - убрать оверрайд;
	   0 - скрыть элемент;
	   1 - показать элемент;
	   2 - заблокировать кнопку (Disable);
	   3 - разблокировать кнопку (Enable);
CustomInterfaceText - возвращает текст элемента на текущей открытой кастомной форме, если текст не изменяли модом, то вернёт пустую строку:
	1 - имя элемента (только для типов Label и Edit);
  Опционально:
	2 - новый текст;
CustomInterfaceImage - возвращает/устанавливает картинку элемента на текущей открытой кастомной форме, если изображение не изменялось модом, то вернёт пустую строку:
	1 - имя элемента (только для классов GI, GAI или Image, либо любого элемента в случае замены параметра);
  Опционально:
	2 - путь к новому изображению, либо указатель на замену конкретного параметра выбранного элемента, подробности ниже;
  Примечание: Данная функция может заменять значения любых параметров в любом элементе, для чего третьим аргументом необходимо указать 'Style:Полный путь к разделу с изменяемым параметром'. Путь к параметру должен указывать на раздел, содержащий только необходимый параметр и его новое значение, пример:
	ChangeParam ^{
		Param=NewValue
	}
  С помощью данного метода можно менять любые "статичные" параметры, вроде Help или StyleBarY.
CustomInterfacePos - возвращает/устанавливает новые координаты элемента на текущей открытой кастомной форме:
	1 - имя элемента;
	2 - смещение по оси Х;
	3 - смещение по оси Y;
CustomInterfacePosZ - возвращает/устанавливает позицию элемента на текущей открытой кастомной форме по оси Z (слой);
	1 - имя элемента;
	2 - позиция элемента по оси Z;
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
CustomInterfaceSize - устанавливает параметр Size элемента на текущей открытой кастомной форме:
	1 - имя элемента;
	2 - размер по оси Х;
	3 - размер по оси Y;
  Примечание: Проще всего запускать все необходимые функции для изменения размеров и позиций элементов кастомной формы в прикреплённом к ней блоке интерфейсного кода (просто размещаете его внутри кастомной формы) 'CodeBeforeRun'. Аналогично, перед уходом с кастомной формы внутри неё срабатывает обработчик 'CodeAfterRun'.


Для работы с массивами:
newarray - превращает в массив переменную типа unknown (также можно использовать сразу после функции free):
	1 - начальное число элементов в новом массиве (пример: unknown array = newarray(7)), 2, 3 и далее (опционально) - сколько подэлементов будет в каждом из предыдущих элементов массива (для объявления многомерного массива);
  Примечание: Раньше данная функция часто использовалась в иниткоде скриптов, т.к. невозможно было объявить массив как-то иначе, но в последних версиях RScript эта необходимость отпала, т.к. появилась возможность объявлять массив напрямую в объекте переменной. При необходимости, этой функцией можно переобъявлять уже объявленные массивы через тернкод (массивы будут очищены автоматически).
  Примечание: При добавлении значения в ячейку с неинициализированным типом, тип ячейки будет автоматически приравнен к типу значения, однако все последующие изменения значения данной ячейки уже будут по умолчанию получать инициализированный в ней тип. Для изменения инициализированного типа значения в ячейке массива можно использовать функцию copy.
  Расширение многомерных массивов: Данная функция также используется при необходимости расширить многомерный массив. Сперва необходимо расширить массив обычной функцией ArrayAdd(arr, dummy), где dummy - переменная типа unknown. После этого новый пустой элемент массива можно разбить на нужное число подэлементов вызвав данную функцию: arr[N] = newarray(2, 3, 4 и т.д. сколько подэлементов вам необходимо объявить в новом элементе).
free - очищает массив (в отличие от ArrayClear, затирает массив полностью, удаляя даже нулевой элемент):
	1 - массив;
  Важно: В тип unknown данная функция массив не превращает, поэтому если обратиться к нему после чистки чем-либо кроме функций newarray или arraychange, то получится краш (в дабокоде массивы без элементов использоваться не могут). Также после чистки можно просто превратить пустой массив в unknown, посредством функции copy (нужно просто скопировать в него переменную с типом unknown). Попытка сохранить игру пока в памяти содержится пустой массив, приведёт к ошибке.
arraychange - меняет размер массива (также можно использовать сразу после функции free):
	1 - массив;
	2 - какой размер установить;
  Примечание: В том числе работает для многомерных массивов, но возможны ошибки в связи с дабокодом (!!!).
ArrayAdd - добавляет новый (следующий по нумерации) элемент в массив и возвращает размер массива после добавления элемента (нельзя использовать после функции free до восстановления нулевого элемента):
	1 - массив;
	2 - добавляемое значение;
  Опционально:
	3 - название нового элемента массива строкой (в дальнейшем такой элемент можно будет вызывать по его имени, пример: Array['ElName']);
  Примечание: Допустимо добавлять в конец в том числе элементы верхнего порядка из многомерных массивов, пример: ArrayAdd(array, array[1]) - где array[1] на самом деле содержит в себе подмассивы array[1, 2, 3].
ArrayDelete - удаляет элемент из массива со сдвигом остального содержимого:
	1 - массив;
	2 - номер элемента для удаления (для многомерных массивов удалит данный номер и все его подномера);
  Примечание: В том числе этой функцией допустимо удалять элементы в многомерных массивах. В этом случае для удаления элемента не из первого порядка необходимо строить запрос вот так: ArrayDelete(array[first, second], third). Однако, при удалении многомерного элемента, его подмассивы сами не очищаются, что может привести к утечке памяти. Если необходимо полностью удалить "ветку" из многомерного массива, то перед вызовом ArrayDelete необходимо вызвать функцию вида free(array[first]), либо free(array[first, second]) и т.д.
ArrayClear - очищает массив от элементов, удаляя все элементы, кроме 0 (которому присваивается тип unknown):
	1 - массив;
ArrayDim - возвращает размер массива:
	1 - массив;
ArraySort - сортирует массив, либо несколько массивов (сортировка идёт по значениям первого);
ArraySortPartial - частично сортирует массив или несколько массивов (не слишком актуально, но если есть ну очень большой массив, то его сортировку можно делать по частям, чтобы не провоцировать задержку хода, для чего сперва вызывается с первым аргументом 1, потом 2, и так далее до N, где N - количество элементов в массиве, начиная с нулевого);
ArrayRandomize - хаотично, но согласованно перетасовывает содержание архива или нескольких массивов:
	1 - сколько раз перетасовать;
	2 - первый массив;
	3 - второй массив ... N-ый массив;
ArrayFind - ищет в массиве определённый элемент:
	1 - массив;
	2 - элемент;
ArrayFindInSorted - ищет элемент, предполагая, что массив уже был отсортирован (работает быстрее чем ArrayFind, что полезно для больших массивов);


OnUseCode и OnActCode:
ScriptActionsRun - форсирует обработку запрошенных скриптовых действий, которые выполняются в другом потоке. Квесты, ПБ, взлеты и т.д. Все, что заказывается функциями, содержащими GScriptThread.MakeRun(); Предназначено для использования из OnUseCode (в остальных случаях обработка запустится и так);
ShowEffect - используется в OnUseCode и OnActCode, воспроизводит эффект:
	1 - строка пути к эффекту выстрела конкретного орудия в Main.dat\SE (чтобы эффекта не было, нужно выставить 'Weapon.NoGraph');
	   Примечание: Выстрел а'Эгиса лежит по пути 'Weapon.PDTurret'.
	2 - номер палитры эффекта для оружия, ShotVisual в Lang (вместе с 'Weapon.NoGraph' выставляйте на 0);
	3 - объект-цель для воспроизведения анимации (корабль, база и т.д.);
  Опционально:
	4 - диллер эффекта (кто якобы наносит выстрел по цели, может быть 0);
	5 - сколько урона нанести (выводимые цифры), реальный урон цели не наносится, это нужно делать функцией DealDamageToShip или прописывать через HullHP;
	6 - показать или нет анимацию взрыва. Если значение больше 0, то будет показан взрыв с плавным исчезанием "взорванного" корабля, цифры от 1 до 7 определяют, какая именно анимация взрыва будет показана;
	7 - воспроизвести или нет (0/1) звук выстрела (актуально для эффектов в Main.dat\SE\Weapon\***);
	8, 9, 10 - RGB цвета для показа урона (если выставить на 0,0,0, то цифры урона показаны не будут, а по умолчанию цвет цифры урона будет равен цвету расы корабля-цели);

ShowStaticEffect - проиграть gai-эффект:
	1 - строка в Main.dat ('SE.Effect');
	2 - координата X;
	3 - координата Y (ВАЖНО! Не воспроизводить эффект в отсутствие в системе игрока, т.к. это может привести к крашу с ошибкой деления на ноль!);
FilmSound - используется в OnUse и OnActcode, воспроизводит звук, позволяя указать его источник:
	1 - строка пути к звуку (например 'Sound.Drop');
	2 - источник звука (объект) - также желательно проверять, находится ли игрок в момент воспроизведения на планете/станции/в системе, чтобы звук не проигрывался игроку в неподобающих местах;
CurItem - используется в OnUseCode и OnActCode, возвращает текущий предмет (предмет, на котором сработал данный код);
CurInfo - возвращает прямой указатель на текущую инфошку (только для акткода в инфошках);
ScriptItemActShip - используется в OnActCode, возвращает текущий корабль (корабль, на котором сработал данный акткод);
ScriptItemActObject1 - используется в OnActCode, возвращает первый объект действия (подробности ниже);
ScriptItemActObject2 - используется в OnActCode, возвращает второй объект действия (подробности ниже);
ScriptItemActParam - используется в OnActCode, возвращает и/или изменяет текущий параметр акткодового события (подробности ниже);
ScriptItemActionType - используется в OnActCode, возвращает тип текущего сработавшего акткодового события;
(!!!) В целях оптимизации старые виды записи проверок: if(ScriptItemActionType() == t_OnStep && ScriptItemActParam() == 0)
необходимо заменять на более быстрые и новые вида: if(ScriptItemActionType(t_OnStep, 0)) (!!!)
  Список всех возможных событий ScriptItemActionType:
	t_OnStep - выполняется 12 раз за ход, опрашивая все акткодовые предметы и инфошки в Галактике, начинает с 0 и заканчивает 11 шагом:
		ScriptItemActShip() - если акткод исполняется для корабля или предмета, лежащего на корабле, то возвращает соответствующий корабль;
		ScriptItemActObject1() - система, где лежит предмет (только если предмет с исполняемым акткодом находится в открытом космосе);
		ScriptItemActParam() - текущий шаг (число от 0 до 11);
	t_OnWeaponShot - выполняется для корабля и орудия в момент выстрела из неракетного оружия:
		ScriptItemActShip() - стреляющий корабль;
		ScriptItemActObject1() - цель выстрела;
		ScriptItemActObject2() - оружие, из которого стреляют;
		ScriptItemActParam() - если выстрел был сделан по кораблю, то возвращает (без аргумента) или меняет нанесённый цели урон (до применения к нему защиты цели);
		ScriptItemActParam() - если выстрел был сделан по ракете, то возвращает/устанавливает маркер (0 - попал, 1 - промазал);
		ScriptItemActParam() - если выстрел был сделан по предмету, то возвращает или устанавливает дополнительный урон от сплеша (как если бы стреляли по взрывной бочке);
	t_OnWeaponShot2	- выполняется для корабля непосредственно перед нанесением урона цели из неракетного оружия (перед t_OnDealingDamage):
		ScriptItemActShip() - стреляющий корабль;
		ScriptItemActObject1() - цель выстрела;
		ScriptItemActObject2() - оружие, из которого был произведён выстрел;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет наносимого урона;
	t_OnMissileShot - выполняется для корабля в момент выстрела из ракетного оружия:
		ScriptItemActShip() - выпускающий ракету корабль;
		ScriptItemActObject1() - ракета;
		ScriptItemActObject2() - оружие, из которого она была выпущена;
		  Примечание: В момент срабатывания данного события ракета уже считается потраченной из боекомплекта, так что, восполняя его в этот момент на единицу, можно получить бесконечное ракетное оружие.
	t_OnMissileShot2 - выполняется для корабля непосредственно перед нанесением урона цели (кораблю/станции) ракетой (перед t_OnDealingDamage):
		ScriptItemActShip() - выпустивший ракету корабль;
		ScriptItemActObject1() - цель ракеты;
		ScriptItemActObject2() - ракета;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет наносимого урона;
	t_OnMissileHittingObject - выполняется, когда ракета попадает в предмет/астероид (срабатывает для хозяина ракеты):
		ScriptItemActShip() - выпустивший ракету корабль;
		ScriptItemActObject1() - объект-цель;
		ScriptItemActObject2() - ракета;
		ScriptItemActParam() - ракета промахнулась (0) или попала (1) по предмету (можно сейвить предметы);
	t_OnGettingWeaponHit - выполняется, когда по кораблю наносят урон оружием:
	t_OnGettingMissileHit - выполняется, когда по кораблю наносят урон ракетой:
		ScriptItemActShip() - атакуемый корабль;
		ScriptItemActObject1() - атакующий корабль/хозяин ракеты;
		ScriptItemActObject2() - оружие/ракета;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет получаемого урона;
		  Примечание: Если атакующий корабль пользуется оружием со сплешом (или AOE типа Вертикса), то событие t_OnGettingWeaponHit сработает на всех кораблях, попавших в зону поражения, в том числе на дружественных и не получивших урон.
	t_OnDealingDamage - выполняется для корабля при нанесении урона другому кораблю или станции (до непосредственного применения урона к цели):
		ScriptItemActShip() - корабль/станция, наносящая урон;
		ScriptItemActObject1() - цель;
		ScriptItemActParam() - возвращает (без аргумента) или меняет нанесённый цели урон;
	t_OnTakingDamage - выполняется для корабля при получении любого урона неопределённого типа: от звезды, астероида, бомбы и т.д. (урон от орудий не учитывается):
	t_OnTakingDamageEn - выполняется для корабля при получении энергетического урона:
	t_OnTakingDamageSp - выполняется для корабля при получении осколочного урона:
	t_OnTakingDamageMi - выполняется для корабля при получении ракетного урона:
		ScriptItemActShip() - корабль/станция, получающая урон;
		ScriptItemActObject1() - источник урона (корабль/станция, ракета/торпеда, астероид, звезда, предмет или 0);
		ScriptItemActParam() - возвращает (без аргумента) или меняет полученный урон;
		  Примечание: При проверке на получение ракетного урона именно от ракеты (!), нужно дополнительно проверять ScriptItemActObject1() командой MissileOwner, чтобы вернуть атакующий корабль, который, однако, к тому моменту, может быть уже мёртв.
	t_OnScan - выполняется при сканировании корабля (срабатывает для игрока и сканируемого корабля, т.к. сами боты сканировать не умеют):
		ScriptItemActShip() - корабль игрока;
		ScriptItemActObject1() - сканируемый корабль;
	t_OnDroidRepair - выполняется для корабля при починке его дроидом:
		ScriptItemActParam() - возвращает/устанавливает количество отремонтированных HP;
	t_OnAnotherItem - выполняется, когда предметом с акткодом кликают по какому-то другому предмету:
	t_OnAnotherItem2 - выполняется, когда по предмету с акткодом кликают каким-то другим предметом:
		CurItem() - предмет с акткодом, для которого выполняется событие;
		ScriptItemActObject1() - другой предмет;
		ScriptItemActParam() - результат клика, аргументы (по умолчанию обработает как 0):
		  0 - предмет останется в руке (t_OnAnotherItem) / будет перемещён в трюм (t_OnAnotherItem2);
		  1 - предмет будет потрачен (удалён);
		  2 - предмет останется висеть в руке, даже если кликнули по другому предмету в трюме;
		  3 - предмет будет потрачен (удалён), а форма 'Ship' автоматически закроется;
	t_OnAnotherGoods - аналогичное t_OnAnotherItem2 событие с той лишь разницей, что срабатывает оно исключительно для товаров (продукты, минералы и т.д.), поскольку товары в трюме не являются предметами и требуют особого подхода в определении их "пика" (соответственно t_OnAnotherItem и t_OnAnotherItem2 для товаров срабатывать не будут):
		CurItem() - предмет с акткодом, для которого выполняется событие;
		ScriptItemActObject1() - тип товара в руке;
		ScriptItemActObject2() - количество товара в руке;
		ScriptItemActParam() - результат клика, аргументы (по умолчанию обработает как 0):
		  0 - не делать ничего;
		> 0 - удалить (потратить) указанное количество товара из руки игрока (потратить больше того, что висит в руке невозможно);
		< 0 - удалить (потратить) указанное количество товара из руки игрока (минус отбрасывается, потратить больше того, что висит в руке невозможно) и закрыть форму 'Ship';
	  Примечание: t_OnAnotherGoods срабатывает исключительно для экипированных предметов, а по предметам в трюме или на складе кликнуть товарами невозможно.
	t_OnItemHit - выполняется когда по предмету чем-то попали (срабатывает только для предмета):
		ScriptItemActObject1() - оружие/ракета;
		ScriptItemActObject2() - система, в которой находится предмет;
		ScriptItemActParam() - урон при взрыве, если предмет взрывоопасен;
	t_OnEnteringForm - выполняется при открытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
	t_OnLeavingForm - выполняется при закрытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
		CurrentForm() - возвращает текущую открытую форму (не акткодовый параметр, но очень удобно использовать вместе с событиями входа/выхода для определения нужной формы);
		  Примечание: Данные события при открытии формы 'Ship' срабатывают исключительно для игрока и не могут сработать для, например, транклюкатора игрока (или улучшаемой игроком станции), хотя фактически для него при просмотре эквипа также открывается форма 'Ship'.
	t_OnReEnteringForm - выполняется при автоматическом перезаходе на форму Ship (автообновление формы Ship после любого изменения формы, происходит почти на каждое действие игрока в меню корабля):
	t_OnShipBuysGoods - при покупке товара кораблём:
	t_OnShipSellsGoods - при продаже товара кораблём:
		ScriptItemActShip() - корабль, совершающий сделку;
		ScriptItemActObject1() - возвращает указатель на "информационный" предмет товара, из которого можно получить все основные данные о совершённой сделке:
		   - Тип купленного/проданного товара ItemType(ScriptItemActObject1());
			   Типы товаров:
			     t_Food (0) - продукты;
			     t_Medicine (1) - медикаменты;
			     t_Technics (2) - техника;
			     t_Luxury (3) - роскошь;
			     t_Minerals (4) - минералы;
			     t_Alcohol (5) - алкоголь;
			     t_Arms (6) - оружие;
			     t_Narcotics (7) - наркотики;
		   - Количество купленного/проданного товара ItemSize(ScriptItemActObject1());
		   - Общая стоимость купленного/проданного товара (сумма сделки) ItemCost(ScriptItemActObject1());
		ScriptItemActObject2() - имеет возврат только для события t_OnShipSellsGoods и также возвращает "информационный" предмет, но имеющий другие характеристики, из которых можно получить информацию о прибыльности совершённой продажи:
		   - Количество проданного товара с учётом того, сколько товара данного типа было реально закуплено кораблём на свои деньги. Прибыль/убыль с продажи краденного или найденного в космосе/гипере товара не будет учтена в формуле начисления опыта за торговлю/пенальти за торговлю себе в убыток:
			   * Если размер данного предмета окажется 0, значит, весь проданный товар является краденным/найденным и его продажа не будет засчитана в качестве торговой прибыли.
			   * Если размер предмета меньше, чем размер предмета из ScriptItemActObject1(), значит, кораблём была закуплена только часть проданного товара, а полученная с такой сделки прибыль/убыль должна быть пропорционально снижена для данного количества товара.
			   * Если же товар имеет размер равный размеру предмета из ScriptItemActObject1(), значит, весь товар был честно куплен кораблём и 100% от его стоимости будет учтено в качестве прибыли/убыли от продажи.
		   - Непосредственно прибыль/убыль от совершённой продажи:
			   * Если размер первого и второго предмета совпадают, то разница между их стоимостью и будет считаться чистой прибылью (если стоимость первого предмета выше стоимости второго) или убылью (если стоимость первого предмета ниже стоимости второго) от продажи.
			   * Если же размер второго предмета меньше, чем у первого (но не равен 0, т.к. в таком случае считать бессмысленно), то сперва необходимо будет получить фактическую стоимость продажи, которая реально участвует в учёте игрой прибыли/убыли. Сперва поделите стоимость первого предмета на его размер (определите стоимость единицы товара) и затем помножьте полученную стоимость единицы товара на размер второго предмета. Далее необходимо просто сравнить полученную "валидную" стоимость сделки с полной стоимостью второго предмета. Если полученное число выше стоимости второго предмета, значит при продаже была получена прибыль, а иначе на лицо явная убыль, которая будет зачислена игрой в "торговое пенальти".
			      Примечание: Торговое пенальти - общая сумма убыли, полученной игроком (другие корабли пенальти не получают) от торговли в убыток. До тех пор, пока пенальти не будет полностью компенсировано торговой прибылью (любая прибыль вычитается из накопленного пенальти), опыт и рейтинг за прибыльную торговлю начисляться не будут. Начисление и списание пенальти (равно как и начисление рейтинга и опыта) происходит уже после срабатывания описываемых акткодовых событий. Проверить и изменить текущую сумму пенальти можно с помощью функции ShipStatistic(Player(), 9).
		  Примечание: Менять характеристики "информационных" предметов, возвращаемых через ScriptItemActObject1() и ScriptItemActObject2() бессмысленно, т.к. на параметры совершённой сделки они не повлияют. Также попытка удаления или переноса "информационных" предметов в другое место приведёт к крашу.
		ScriptItemActParam() - возвращает/изменяет маркер о легальности совершённой сделки (0 - легальна, 1 - нелегальна);
	t_OnPlayerTalkedWithShip - когда игрок закончил разговор с кораблём, которого вызвал сам:
	t_OnShipTalkedWithPlayer - когда игрок закончил разговор с вызвавшим его кораблём:
		ScriptItemActShip() - корабль игрока (предположительно);
		ScriptItemActObject1() - корабль, с которым закончил говорить игрок;
	t_OnStartAB - срабатывает перед началом любой аркадной битвы, в которую вступает игрок:
		ScriptItemActShip() - всегда возвращает корабль игрока (бесполезный возврат);
		ScriptItemActObject1() - тоже корабль игрока, но уже исключительно АБ-шный. Возврат из этой функции можно использовать только для подстановки первым аргументом в ABShipModifiers, чтобы установить желаемые модификаторы игроку (удобно использовать в акткоде кастомных артефактов);
	  Примечание: Данное событие можно использовать исключительно для изменения аркадных модификаторов игрока (ABShipModifiers). Добавить/удалить корабли NPC в бой в этот момент уже нельзя.
	t_OnABItemDrop - срабатывает при получении игроком предмета из убитого в аркадном бою противника (перед добавлением предмета в трюм и перед выводом уведомления о полученных предметах):
		ScriptItemActShip() - корабль игрока;
		ScriptItemActObject1() - предмет, который будет добавлен в трюм к игроку (можно поменять ему цену, вес, акрин и т.д.);
	t_OnItemPickUp - выполняется когда предмет подняли захватом (срабатывает для поднявшего корабля и для поднятого предмета):
		ScriptItemActShip() - поднявший корабль;
		ScriptItemActObject1() - поднятый предмет (в момент срабатывания уже находится на корабле, не сработает для товаров);
	t_OnDropItem - предмет выкинули из трюма и он движется (для детекта дропов из кораблей NPC):
	t_OnDropItemFixed - предмет выкинули из трюма и он неподвижен (для детекта дропов из корабля игрока):
		ScriptItemActShip() - дропнувший корабль (детектится даже после своего "уничтожения");
		ScriptItemActObject1() - дропнутый предмет;
	t_OnReduceEqBattle - срабатывает для предмета, когда происходит его износ в бою:
	t_OnReduceEqUse - срабатывает для предмета, когда происходит его износ от использования:
	t_OnReduceEqForce - срабатывает для предмета, когда происходит его износ от воздействия бертора:
	t_OnReduceEqForsage - срабатывает для двигателя, когда происходит его износ от форсажа:
		ScriptItemActShip() - корабль, на котором установлен предмет;
		ScriptItemActObject1() - предмет, который изнашивается;
		ScriptItemActParam() - количество вычитаемых у предмета очков износа, которое необходимо поделить на 1000, для получения точного процента "урона" (полностью исправный предмет имеет стойкость в 100 тысяч очков износа (100%), а полностью изношенный - 0);
	t_OnTrancPacking - срабатывает при сворачивании транклюкатора для корабля хозяина и транклюкатора:
		ScriptItemActObject1() - транклюкатор-артефакт (при необходимости, можно вернуть самого транка по функции ArtTranclucatorToShip);
		ScriptItemActObject2() - куда сворачивается транклюкатор (корабль, планета, станция);
	t_OnDeath - срабатывает для корабля перед его уничтожением:
		ScriptItemActShip() - погибающий корабль;
	t_OnPlayerChangeHull - срабатывает при смене корпуса игроком:
		ScriptItemActObject1() - новый корпус (на который меняем);
		ScriptItemActObject2() - старый корпус (экипированный);
	  Примечание: Исполняется для корабля игрока, а также последовательно для старого (до установки), а затем для нового (после установки) корпуса.
	t_OnPlayerUseMM - срабатывает, когда игрок устанавливает микромодуль в оборудование:
		ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция, с проплаченным взносом на изменение;
		ScriptItemActObject1() - оборудование, в которое вставляется ММ;
		ScriptItemActObject2() - микромодуль в виде предмета;
	t_OnPlayerSkillIncrease - срабатывает при повышении навыка игроком для самого игрока, его транклюкатора или улучшаемой станции:
		ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция с проплаченным взносом на изменение;
	t_OnItemEquip - выполняется, когда предмет в скриптовом объекте или артефакт надевается (не срабатывает для корабля);
	t_OnItemDeEquip - выполняется, когда предмет в скриптовом объекте или артефакт снимается (не срабатывает для корабля);
		CurItem() - предмет;
	  Эти два события - сраное дерьмо! Они не видят корабль, на который экипируется/с которого снимается предмет, и способны работать исключительно для предметов в скриптовых объектах, что делает их бесполезными в 99% случаев.
	t_OnNonStandartEqChange - срабатывает при смене любого оборудования на корабле нестандартным путём, а именно функцией ItemIsInUse (и только ей, т.к. различные функции типа Get и Drop событием не фиксируются) или при смене комплектаций;
		ScriptItemActShip() - корабль, на котором произошла смена оборудования;
	t_OnItemDestroy - выполняется перед уничтожением предмета (срабатывает только для уничтожаемого предмета);
		CurItem() - уничтожаемый предмет;
	t_OnShowingItemInfo - срабатывает перед отображением карточки предмета с данным событием;
		CurItem() - предмет, для которого отображается карточка;
		ScriptItemActShip() - если предмет на корабле или складе планеты/станции, то возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner';
		ScriptItemActObject1() - возвращает звезду, если предмет находятся в открытом космосе и планету/станцию, если предмет закопан на необитаемой планете или продаётся в магазине обитаемой планеты/станции (если предмет на корабле или складе, то вернёт 0);
	t_OnCheckingUsability - выполняется, когда игрок курсором пикает предмет, по очереди возвращая все эквипнутые на корабле предметы. Если получает в ответ на очередной предмет 1, то подсвечивает слот этого предмета, как если бы игрок мог установить в него микромодуль;
	t_OnCheckingUsability2 - то же, что и t_OnCheckingUsability, только выполняется для экипированного предмета, а не для взятого "в руку" игроком (исполняется после t_OnCheckingUsability, поэтому если первое событие уже выставило маркер на подсветку, то для подсвеченного предмета t_OnCheckingUsability2 исполнено не будет);
		CurItem() - предмет с акткодом, для которого исполняется событие;
		ScriptItemActObject1() - очередной экипированный предмет (для t_OnCheckingUsability) / предмет "в руке" игрока (для t_OnCheckingUsability2);
		ScriptItemActParam(1) - отправляет маркер, что слот текущего экипированного предмета необходимо подсветить;
	t_OnCheckingUsabilityGoods - аналогичное t_OnCheckingUsability2 событие с той лишь разницей, что срабатывает оно исключительно для товаров (продукты, минералы и т.д.), поскольку товары в трюме не являются предметами и требуют особого подхода в определении их "пика" (соответственно t_OnCheckingUsability и t_OnCheckingUsability2 для товаров срабатывать не будут):
		CurItem() - предмет с акткодом, для которого выполняется событие;
		ScriptItemActObject1() - тип товара в руке;
		ScriptItemActObject2() - количество товара в руке;
		ScriptItemActParam(1) - отправляет маркер, что слот текущего экипированного предмета необходимо подсветить;
	  Примечание: Определить стоимость и прочие параметры товара "в руке" можно через функцию FormShipCurItem().

	Важно!!! В целях оптимизации акткода, после его написания необходимо создать специальные параметры-фильтры с указанием всех событий, задействованных в этом коде, пример:
      OnActCodeTypes=t_OnDeath,t_OnItemDestroy,t_OnStep - тэг для указания самих событий (t_OnStep здесь указывать не обязательно, если ниже вы указали второй тэг);
      OnActStepTypes=0,5,11 - конкретные этапы срабатывания события t_OnStep, в данном примере будут обработаны только этапы 0, 5 и 11 (если в вашем коде нет событий t_OnStep, либо они занимают полный диапазон шагов от 0 до 11, то указывать данный тэг не требуется);
	Данная оптимизация крайне важна, т.к. позволяет убрать из акткода все лишние и заведомо холостые проверки, тем самым значительно повышая скорость расчёта хода. Тэги необходимо ставить в разделе предмета, либо инфошки, наряду с прочими тэгами вроде Name, Text и т.д. Указать подобные тэги для акткода, который затем будет подставлен в скриптовый объект, невозможно, но т.к. подобных объектов во всей игре довольно мало, делать этого и не требуется.
	Примечание: Все события "для корабля" также срабатывают и для всех установленных и лежащих в его трюме предметов с поправкой на то, что для получения акткода оборудование должно быть сперва занесено в скрипт, артефакты обрабатывают акткод только будучи установленными в слот, а юзлесные предметы работают всегда, в том числе и из трюма (и, при желании, даже могут быть эквипнуты в несуществующий слот).


Функции, активирующие активные способности артефактов из оригинальной игры:
OnUseCodeTranclucator - функция, активирующая транклюкатора при использовании, возвращает транклюкатора;
OnUseCodeTransmitter - функция, без аргумента активирующая ТМ при использовании: 1 - трансмиттер, активирует указанный ТМ, 2 - маркер для отключения звука и сообщения об активации ТМ (если 0, то сообщения и звук отключены);
OnUseCodeBlackHole - функция, активирующая Субпортал при использовании, возвращает созданную ЧД;
OnUseCodeMissileDef - функция активации Ракетанга, уничтожение своих ракет;


Виды эффектов в дамагсете (присваиваются в параметре WeaponMods):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели;
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм, эффект Третона);
  'Shock' (64) - вешает на цель эффект ионизации;
  'Acid' (128) - ослабляет броню цели;
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели, эффект Лирекрона);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);
Примечание: Замедления 'Decelerate', 'DecelerateA' и 'DecelerateAEx' полностью идентичны друг другу, однако при совместном использовании кратно увеличивают замедляющий эффект. К примеру, Вжик в режиме совместимости использует одновременно 'DecelerateA' и 'DecelerateAEx', что увеличивает его замедляющий эффект ровно в два раза.
  'Undefendable' (2048) - применяет к цели урон, считающийся отражённым Поляризатором (наносимый урон игнорирует броню и ГЗП, не не резисты);
  'NonLethal' (4096) - применяет эффект, как от непосредственного воздействия ионизации (наносит урон корпусу, но полностью уничтожить корабль не может)
  'ScanBonus' (8192) - повышает урон оружия на 15% (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BonusToDamaged' (16384) - повышает урон по повреждённой цели вплоть до 33% (если у цели остался 1 HP) в зависимости от степени повреждения цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
    Примечание: kdamage := kdamage * (1 + 0.33 * (1 - FHull.FHitPoints / FHull.FSize));
  'MoreDrop' (32768) - повышает шанс дропа оборудования при уничтожении цели, аналогично ЛВВ (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'DropCargo' (65536) - добавляет 5% шанс дропа товара из трюма при нанесении урона цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'ReduceEngine' (131072) - наносит повреждения двигателю цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockWeapon' (262144) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки оружия цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'BlockDroid' (524288) - имеет шанс (обратно пропорционален размеру корпуса цели) блокировки дроида цели (необходимо превышение мощности сканера над защитой цели, а также нахождение цели в пределах радиуса радара);
  'NoDelta' (1048576) - отключает разброс урона (оружие с данным эффектом всегда наносит максимальный урон, эффект Эсодафера);

Примечание: Для проверки наличия определённых эффектов в дамагсете конкретного орудия, необходимо сперва узнать его полный дамагсет (GetEquipmentStats(weapon, 6)), а затем применить к нему одну из проверок следующего вида:
  if((damageset & 64)) - проверит, имеется ли в дамагсете эффект, вешающий на цель ионизацию (в случае наличия эффекта, выражение в скобках вернёт проверке 64);
  if(!(damageset & 64)) - проверит, что в данном дамагсете эффекта, вешающего на цель ионизацию, нет (вернёт 0);
  if((damageset & 64) || (damageset & 256)) - проверит, имеется ли в дамагсете эффект, вешающий ионизацию или эффект, вешающий ЭМ-помехи;
  if((damageset & (64+256)) == (64+256)) - проверит, имеются ли в дамагсете одновременно оба этих эффекта;
  if((damageset & 1+2+4+8+16+32+64+128+256)) - проверит, имеется ли в дамагсете хоть один из перечисленных в проверке эффектов (записывать проверочный сет в виде суммы не обязательно, но удобно для читабельности кода);
  Также имейте в виду, что вешать эффекты с требованием к мощности сканера на всякие посторонние объекты (не на оружие) типа акринов ракет бессмысленно, т.к. работать они там всё равно не будут.


Галактические события (запоминаются игрой сразу же в момент совершения и могут быть просмотрены из любого кода в любой момент):
GalaxyEvents - без аргументов, возвращает все последние сохранённые в памяти галактические события (самые старые из них постепенно удаляются);
  Примечание: Для проверки последних галасобытий желательно делать перебор от конца к началу списка, и останавливать цикл по достижении первого же события от прошлого хода.
GalaxyEventDate - возвращает дату галактического события:
	1 - номер события из списка;
GalaxyEventType - возвращает тип галактического события в виде строки:
	1 - номер события из списка;
GalaxyEventData - возвращает числовые данные галактического события:
	1 - номер события из списка (возвращает количество доступных типов данных для этого события);
  Опционально:
	2 - номер типа данных (возвращает значение указанного типа данных события);
GalaxyEventsTextData - возвращает текстовые данные галактического события:
	1 - номер события из списка (возвращает количество доступных типов строковых данных для этого события);
  Опционально:
	2 - номер типа данных (возвращает значение указанного типа строковых данных события);

Типы галактических событий:
	'PlayerKillsShip' - игрок кого-то уничтожил:
	'PlayerAssistKillsShip' - игрок оказал помощь в уничтожении:
			Числовые данные:
				0 - числовой тип уничтоженного корабля (ShipTypeN);
				1 - Id системы;
				2 - Id уничтоженного корабля;
				3 - раса уничтоженного корабля;
				4 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
				5 - подтип уничтоженного корабля;
			Текстовые данные:
				0 - имя уничтоженного корабля;
				1 - полное имя уничтоженного корабля;
				2 - строчный кастомный тип уничтоженного корабля (ShipType);
	'PlayerTranclucatorKillsShip' - транклюкатор игрока кого-то уничтожил:
	'PlayerTranclucatorAssistKillsShip' - транклюкатор игрока оказал помощь в уничтожении:
			Числовые данные:
				0 - тип уничтоженного корабля номером (ShipTypeN);
				1 - Id системы;
				2 - Id уничтоженного корабля;
				3 - раса уничтоженного корабля;
				4 - Id транклюкатора игрока;
				5 - раса транклюкатора игрока;
				6 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
				7 - подтип уничтоженного корабля;
			Текстовые данные:
				0 - имя уничтоженного корабля;
				1 - имя транклюкатора игрока;
				2 - полное имя уничтоженного корабля;
				3 - строчный кастомный тип уничтоженного корабля (ShipType);
	'PlayerCompanionKillsShip' - компаньон игрока кого-то уничтожил:
	'PlayerCompanionAssistKillsShip' - компаньон игрока оказал помощь в уничтожении:
			Числовые данные:
				0 - тип уничтоженного корабля;
				1 - Id системы;
				2 - Id уничтоженного корабля;
				3 - раса уничтоженного корабля;
				4 - тип корабля компаньона;
				5 - Id корабля компаньона;
				6 - раса корабля компаньона;
				7 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру);
				8 - подтип уничтоженного корабля;
			Текстовые данные:
				0 - имя уничтоженного корабля;
				1 - имя компаньона;
				2 - строчный кастомный тип уничтоженного корабля (ShipType);
		Важно!!! Возврат строчного типа корабля для оригинальных типов кораблей ('Ranger', 'Warrior' и т.д.) всегда будет возвращать пустую строку.
	'LabeledShipKilledInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) был уничтожен:
			Текстовые данные:
				0 - строковая метка корабля;
	'LabeledShipSurvivedInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) выжил в бою:
			Числовые данные:
				0 - оставшееся после боя здоровье в единицах HP;
				1 - максимальный уровень здоровья (сколько было в начале боя) в единицах HP;
			Текстовые данные:
				0 - строковая метка корабля;
	'PlayerAcceptsMoneyForTruce' - игрок согласился принять деньги за примирение с другим кораблём:
	'PlayerExtortsMoney' - игрок вытребовал деньги у другого корабля (имеется в виду, вытребовал успешно):
	'PlayerExtortsGoods' - игрок вытребовал груз у другого корабля:
			Числовые данные:
				0 - количество полученных денег или стоимость груза;
				1 - тип другого корабля;
				2 - Id системы;
				3 - Id другого корабля;
				4 - раса другого корабля;
			Текстовые данные:
				0 - имя другого корабля;
	'PlayerDebtNullified' - кредитный долг игрока обнулился из-за уничтожения всех БЦ (срабатывает, если игрок имел долг):
			Числовые данные:
				0 - обнулённый долг;
	'PlayerNodesNullified' - нод-счёт игрока обнулился из-за уничтожения всех ЦР (срабатывает, если на счету имелся хоть 1 нод):
			Числовые данные:
				0 - обнулённые ноды;
	'PlayerUsesSubportal' - игрок активировал субпортал:
			Числовые данные:
				0 - Id ЧД;
				1 - дата открытия ЧД;
	'PlayerJumpsThroughSubportal' - игрок совершил прыжок через субпортал:
			Данные отсутствуют;
	'PlayerUsesBeacon' - игрок активировал трансфакторный маяк:
			Числовые данные:
				0 - Id системы, в которой был активирован маяк;
	'PlayerChangesNationality' - игрок сменил расу:
			Числовые данные:
				0 - новая раса;
	'PlayerChangesSide' - игрок сменил сторону конфликта:
			Числовые данные:
				0 - на чью сторону перешёл игрок (0 - Коалиция, 1 - пиратский клан);
	'PlayerOrdersPirateRaid' - игрок заказал пиратский набег:
			Числовые данные:
				0 - Id атакуемой системы;
	'PlayerDeath' - игрок погиб:
			Данные отсутствуют;
	'PlayerBuysEquipment' - игрок приобрёл предмет в магазине оборудования:
	'PlayerSellsEquipment' - игрок продал оборудование или юзлесный предмет:
			Числовые данные:
				0 - тип предмета;
				1 - цена предмета;
				2 - вес предмета;
				3 - Id предмета;
				4 - тип магазина (0 - планета, 1 - станция);
				5 - Id магазина;
			Текстовые данные:
				0 - название предмета;
	'PlayerBuysGoodsFromPlanet' - игрок приобрёл товары на планете:
	'PlayerSellsGoodsToPlanet' - игрок продал товары на планете:
			Числовые данные:
				0 - тип товара;
				1 - количество товара;
				2 - общая стоимость товара;
				3 - Id планеты;
	'PlayerBuysMissiles' - игрок зарядил ракетное орудие (купил заряды):
			Числовые данные:
				0 - потраченные деньги;
				1 - число купленных зарядов;
	'PlayerFinishesQuest' - игрок завершил текстовый квест (возможно, имеются ввиду вообще все задания, кроме ПБ):
			Числовые данные:
				0 - тип квеста;
				1 - номер квеста;
				2 - полученные деньги;
				3 - полученный опыт;
	'PlayerFinishesPlanetaryBattle' - игрок завершил планетарный бой:
			Числовые данные:
				0 - номер ПБ;
				1 - полученные деньги;
				2 - полученный опыт;
	'PlayerReceivesMM' - игрок приобрёл микромодуль (видимо, только на ЦР):
			Числовые данные:
				0 - Id микромодуля;
				1 - тип микромодуля (уровень);
				2 - цена микромодуля в нодах;
	'PlayerReceivesMMAsReward' - игрок получил микромодуль в качестве награды:
			Числовые данные:
				0 - Id микромодуля;
				1 - тип микромодуля;
	'PlayerReceivesMMOnNewYear' - игрок получил микромодуль в качестве новогоднего подарка:
			Числовые данные:
				0 - Id микромодуля;
				1 - тип микромодуля;
	'PlayerLiberatesSystem' - игрок освободил систему:
			Числовые данные:
				0 - Id системы;
				1 - новый владелец системы;
				2 - бывший владелец системы;
				3 - количество сбитых (игроком?) кораблей;
				4 - Id планеты награждения;
	'RuinsCreated' - построена новая станция:
	'RuinsDestroyed' - станция уничтожена:
			Числовые данные:
				0 - числовой тип станции;
				1 - Id станции;
				2 - Id системы;
			Текстовые данные:
				0 - имя станции (без приставки типа);
				1 - строчный кастомный тип станции (ShipType);
		Важно!!! Возврат строчного типа станции для оригинальных станций всегда будет возвращать пустую строку.
	'PlayerEntersCheatCode' - игрок ввёл чит-код:
			Числовые данные:
				0 - стоимость чита в очках;
			Текстовые данные:
				0 - название чита;
	'SaveLoaded' - игрок загрузил сохранённую игру:
			Числовые данные:
				0 - флаг загрузки дампа для загруженного сейва (да/нет);
			Текстовые данные:
				0, 1, 2 и т.д. - перечисление всех подключённых в сейве модов в формате 'Expansion\ExpArts';
	'GlobalChangeToPlayerReputation' - произошло глобальное изменение репутации игрока (например, выплатил пособие семьям погибших рейнджеров):
			Числовые данные (как именно хардкод изменил репутацию в данном событии):
			   0 - тип произведённого изменения репутации (диапазон от 0 до 100):
			      0 - повысить репутацию до указанного значения;
			      1 - понизить репутацию до указанного значения;
			      2 - прибавить указанное значение к уже имеющемуся, но не выше 100;
			      3 - отнять указанное значение от уже имеющегося, но не ниже 0;
			      4 - отнять указанное значение от уже имеющегося, но не ниже 10 (то есть не доводить до враждебного уровня);
			   1 - само значение для изменения репутации;
			   2 - сет рас, для планет и кораблей которых было применено данное глобальное изменение репутации;
			Текстовые данные: отсутствуют;

Стейткод (то есть код, привязанный к любому стейту посредством if/Op):
ShipJoin - присоединяет корабль к скриптовой группе:
	1 - номер или название группы без кавычек (каждый скрипт определяет свои группы по их внутреннему номеру);
	2 - корабль;
  Опционально:
	3 - маркер (можно подставить что угодно, кроме строки) запрета на автоматический перевод корабля в первый привязанный к группе стейт, что подразумевает дальнейший его перевод в какой-либо стейт вручную через ChangeState(), либо, если была передана не пустая строка, перевод корабля сразу в указанный (строкой) стейт, либо, если сюда была передана пустая строка, то будет присвоен стандартный стейт по умолчанию;
	4, 5, 6, 7 - стартовые значения переменных GetData/SetData данного скриптового корабля (по умолчанию имеют 0), тип dword;
  Важно: При добавлении корабля в скриптовую группу, любой прикреплённый к стейту (в который попадёт корабль) код будет в первый раз исполнен сразу же в момент добавления!
ShipOut - выводит корабль из его текущей скриптовой группы (любой NPC может быть одновременно записан лишь в одну скриптовую группу, так что указывать её не требуется):
	1 - корабль (если указать игрока, то он будет выведен из своей текущей группы в данном конкретном скрипте);
AllShipOut - без аргументов, выводит все корабли из всех групп в текущем скрипте (по сути, является функцией для полного отключения скрипта);
ChangeState - сменить State корабля на другой, игнорируя обычную схему переходов:
	1 - стэйт (название строкой в кавычках или номер);
  Опционально:
	2 - корабль (по умолчанию стэйт будет изменён для корабля в текущем стэйте CurShip);
StateIs - проверяет наличие скриптового корабля в определённом стейте/стейтах (вернёт 1, если корабль находится в одном из перечисленных):
	1 - корабль в скриптовой группе (для нескриптовых кораблей будет всегда возвращать 0);
	2, 3, 4 ... N - номера, либо названия стейтов в виде строк, наличие в которых корабля необходимо проверить;
  Примечание: Обработка стейткода может происходить множество раз за ход и включается тогда, когда кораблю нужно использовать собственную логику для определения дальнейших действий. Также при работе со стейткодом внутренняя переменная CurShip всегда будет возвращать корабль, для которого в данный момент обрабатывается стейткод. То есть весь привязанный к стейтам код можно смело писать через CurShip вне зависимости от количества кораблей в группе, т.к. все они будут обрабатываться последовательно.
Hit - проверяет, атаковал/был ли атакован игрок скриптовым кораблём (после выставления маркер уже не обнуляется):
	1 - скриптовый корабль (вернёт 1, если игрок, его транк или партнёр нанесли урон этому кораблю);
  Опционально:
	2 - если подставлена 1, то функция вернёт 1 только в том случае, если по игроку (и только по нему) нанёс урон скриптовый корабль из первого аргумента;
  Примечание: После выставления маркера Hit на скриптовом корабле, сброшен он с него уже не будет, что делает эту функцию, по сути, одноразовой проверкой на случившуюся агрессию между конкретным скриптовым кораблём и игроком.
CurShip - переменная, в которую записан корабль, для которого в данный момент исполняется стейткод;
EndState - переменная, которая приравнивается к 1, когда текущий стейт завершает своё основное дествие (например, корабль прибыл в точку назначения, указанную для него в стейте с типом Move);
GetData - получить числовые данные типа dword (по 4 переменные на каждый скриптовый корабль) для скриптового (находящегося в группе) корабля:
	1 - номер данных (0-3);
  Опционально:
	2 - корабль (при вызове из стейткода корабль можно не указывать);
SetData - задать числовые данные типа dword для скриптового (находящегося в группе) корабля:
	1 - новое значение данных;
	2 - номер данных (0-3);
  Опционально:
	3 - корабль (при вызове из стейткода корабль можно не указывать);
  Примечание: Если запрашиваемый корабль - игрок, то его данные можно получать исключительно из скрипта, в котором находится конкретная группа с игроком (из акткода и юзкода по данным игрока всегда будет возвращаться unknown).
ShipData - то же, что и GetData/SetData, но объединённое в одной функции и только для первой переменной/ячейки данных:
	Без аргументов - возвращает текущее значение данных;
	1 - задать новое значение данных;
  Примечание: Данную функцию можно вызывать исключительно из стейткода.
ShipInCurScript - проверяет, участвует ли корабль в текущем скрипте:
	1 - корабль;
  Примечание: Функция ShipInCurScript является внутренней скриптовой проверкой и может быть вызвана только внутри какого-либо скрипта.
ShipInScript - делает проверку, записан ли корабль в какую-то (любую) скриптовую группу и/или имеет на себе включённый OrderLock:
	1 - корабль;
  Опционально:
	2 - если 0, то отключить проверку на OrderLock, оставив проверку только на нахождение в скриптовой группе (по умолчанию проверка на OrderLock включена);
  Примечание: Функция ShipInScript является универсальной проверкой и может быть вызвана откуда угодно.

Интерфейс и кастомные инфошки:
CurInfo - без аргументов, возвращает прямой указатель на инфошку при вызове из её акткода;
ShipCustomShipInfosCount - возвращает общее количество кастомных инфошек на корабле:
	1 - корабль;
ShipAddCustomShipInfo - добавляет на корабль/станцию кастомную инфошку и возвращает её указатель аналогично функции CurInfo():
	1 - корабль;
	2 - строка с системным именем инфошки (из Lang);
  Опционально:
	3 - строка с описанием инфошки (заменит собой описание из Lang) или маркером 'NoShow' (не будет отображаться в разделе состояний корабля), также можно оставить пустой '';
	4 - числовая переменная инфошки №1 (тип int);
	5 - числовая переменная инфошки №2;
	6 - числовая переменная инфошки №3;
	7 - строковая переменная инфошки №1 (тип str);
	8 - строковая переменная инфошки №2;
	9 - строковая переменная инфошки №3;
ShipDeleteCustomShipInfo - удаляет одну указанную кастомную инфошку с корабля (одинаковых инфошек там может висеть и несколько):
	1 - корабль;
	2 - строка с системным именем или номер инфошки, либо прямой указатель CurInfo();
ShipFindCustomShipInfoByType - возвращает номер инфошки по её имени в списке инфошек корабля:
	1 - корабль;
	2 - системное имя инфошки;
ShipCustomShipInfoDescription - возвращает или устанавливает описание инфошки:
	1 - корабль;
	2 - номер или имя инфошки;
  Опционально:
	3 - строка, которая заменит собой текущее описание;
ShipCustomShipInfoData - возвращает или устанавливает числовые данные переменной (тип int) для инфошки:
	1 - корабль;
	2 - номер или имя инфошки (или сама инфошка CurInfo() при вызове из акткода инфошки, в таком случае вместо корабля можно поставить 0);
	3 - номер переменной (1-3);
  Опционально:
	4 - какое значение установить (при подстановке тэга вида <Data1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки данных);
ShipCustomShipInfoTextData - возвращает или устанавливает текстовые данные переменной (тип str) для инфошки:
	1 - корабль;
	2 - номер или имя инфошки;
	3 - номер переменной (1-3);
  Опционально:
	4 - какое значение установить (при подстановке тэга вида <TextData1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки текстовых данных);
StarMapLabel - добавляет к названию системы на галакарте текстовую метку:
	1 - система;
	2 - строковая метка;
StarCustomStarInfosCount - возвращает общее количество кастомных инфошек системы (один объект в списке системы (планета/станция и т.д.) - одна инфошка):
	1 - система;
StarAddCustomStarInfo - добавляет кастомную инфошку для системы:
	1 - система;
	2 - текстовая метка инфошки для дальнейшего поиска её номера в списке кастомных инфошек системы (можно добавлять сюда тип и Id станции, например, чтобы было удобно потом удалять инфошку в случае её гибели);
	3 - название объекта в списке объектов системы (находится слева от главной иконки);
	4 - удалённость изображаемого инфошкой объекта от центра системы, определяет положение кастомной инфошки в списке объектов системы;
	5 - путь к главной иконке объекта (обычно иконка самой планеты/станции) строкой вида: 'Bm.YourPath' (будет автоматически отмасштабирована до нужного размера, если передать большую картинку);
	6 - текст справа от главной иконки, либо путь к дополнительным картинкам (для планеты сюда обычно подставляются картинки расы, отношения и т.д.);
  Примечание: Справа от главной иконки можно добавить либо текст, либо картинки/картинку. И то и другое добавить не получится. Путь к дополнительным картинкам/картинке добавляется в четвёртый аргумент строкой вида: 'Image:Bm.Path1,Bm.Path2', и т.д.
StarFindCustomStarInfoByType - ищет номер кастомной инфошки системы по её текстовой метке (если не найдёт, вернёт -1):
	1 - система;
	2 - текстовая метка инфошки;
StarDeleteCustomStarInfo - удаление кастомной инфошки для системы:
	1 - система;
	2 - номер кастомной инфошки;
StarCustomStarInfoData - возвращает/устанавливает нужное значение в кастомной инфошке звезды:
	1 - система;
	2 - номер кастомной инфошки;
	3 - запрашиваемый параметр:
	   'Dist' - удалённость изображаемого инфошкой объекта от центра системы, определяет положение кастомной инфошки в списке объектов системы;
	   'Name' - название объекта в списке объектов системы (находится слева от главной иконки);
	   'Icon' - путь к главной иконке объекта (обычно иконка самой планеты/станции) строкой вида: 'Bm.YourPath' (будет автоматически отмасштабирована до нужного размера, если передать большую картинку);
	   'Info' - текст справа от главной иконки, либо путь к дополнительным картинкам (для планеты сюда обычно подставляются картинки расы, отношения и т.д.);
	 Примечание: Справа от главной иконки можно добавить либо текст, либо картинки/картинку. И то и другое добавить не получится. Путь к дополнительным картинкам/картинке добавляется в четвёртый аргумент строкой вида: 'Image:Bm.Path1,Bm.Path2', и т.д.
  Опционально:
	4 - новое значение параметра;


Прочее:
HoleMamaCreate - осталось от КР1, чёрная дыра Махпеллы;
RobotSupport - поддерживаются планетарные битвы, на особо слабых машинах могут не работать;
StarListToPlanetList - вспомогательная функция для пиратской сюжетки, из списка систем строит список планет по критериям, которые я уже сам не помню (evilcoward);
StarListToTransitPlanetList - вспомогательная функция для пиратской сюжетки, составляет список планет находящихся где-то по дороге от одной системы к другой, с учетом модификаторов, которые я уже не помню (evilcoward);
EndGame - завершает партию:
	Без аргументов - перекинет сразу на экран титров;
  Опционально:
	1 - тип выводимой на экран пиратской победной концовки (числа 5-18):
CustomWin - кастомная победа;
	1 - текст, который будет выведен на экране победы;
  Опционально:
	2 - номер картинки, которая будет установлена на экране победы (по умолчанию ставится стандартная расовая);
CustomLose - кастомное поражение:
	1 - текст, который будет выведен на экране поражения;
  Опционально:
	2 - номер картинки, которая будет установлена на экране поражения (по умолчанию ставится стандартная расовая);
PirateWin - возвращает или устанавливает тип завершения пиратской сюжетной ветки:
	Без аргументов - вернёт текущий статус пиратской сюжетки;
  Опционально:
	1 - какой статус пиратской сюжетки установить:
	   0 - пираты воюют с Коалицией (начальный статус);
	   1 - пираты проникли во власть (положительная);
	   2 - пираты вернулись к истокам (положительная);
	   3 - Коалиция спасена от пиратов (отрицательная);
	   4 - пиратов преследуют неудачи (отрицательная);
	   5 - пираты поработили Коалицию (положительная);
ShipInPrison - проверяет начинает/заканчивает тюремную отсидку рейнджера или пирата:
	1 - корабль рейнджера или пирата (если запросить статус отсидки другого корабля, вернёт 0);
  Опционально:
	2 - посадить/выпустить;
ControlledSystems - возвращает количество систем, контролируемых одной из сторон конфликта в данный момент:
	1 - сторона конфликта:
	   0 - Коалиция;
	   1 - доминаторы;
	   2 - пираты;
CapitalShipStats - проверяет наличие, либо добавляет/изменяет мостик для указанного корпуса:
	1 - корпус (вернёт номер привязанного мостика, либо 0, если мостик не установлен);
  Опционально:
	2 - какой номер мостика установить (для мостика ТИ восстанавливает запас энергии до 1000);
  Только для мостика ТИ:
	3 - какой конкретно максимальный запас энергии установить;
  Примечание: Номер мостика ТИ всегда 1.
PlayerBridge - возвращает номер мостика, на котором находится игрок, либо переводит игрока на него:
	Без аргументов - вернёт номер текущего мостика (либо 0, если игрок не на мостике);
  Опционально:
	1 - номер мостика, на который нужно перевести игрока (если 0, то выйти с мостика);
	2 - какой фон установить для мостика, на который будет переведён игрок;
WeaponHit - конкретный корабль производит выстрел по конкретной цели (не отрисовывает никаких эффектов):
	1 - стреляющий корабль/станция;
	2 - объект-цель (только корабль/станция или ракета);
	3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа не важна);
FireWeapon - полноценный выстрел, принимает любые цели, сам применяет и отрисовывает всё эффекты:
	1 - стреляющий корабль/станция;
	2 - объект-цель (корабль/станция, астероид, предмет или ракета);
	3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа не важна);
  Примечание: Если выстрел производится по предмету (астероидам и ракетам всё же нужен указатель на орудие), то показатель урона конкретного орудия не будет иметь никакого значения. Таким образом, третий аргумент можно задать как 0 (что также отменит и анимацию выстрела), и не париться с поисками подходящей для выстрела пушки. Учтите, однако, что выстрел по предмету без указания пушки всё равно вызовет в этом предмете срабатывание события t_OnItemHit, однако в возврате функции ScriptItemActObject1() в таком случае будет закономерно записано 0. Также данные функции не смогут произвести полноценный запуск ракеты из ракетного орудия. Для запуска ракет необходимо использовать функции LaunchMissile() или же непосредственно SpawnMissile().
LaunchMissile - производит запуск ракеты/торпеды из указанного ракетного орудия и возвращает указатель на выпущенную ракету (не расходует и не проверяет текущий боезапас, но можно делать это вручную):
	1 - стреляющий корабль/станция;
	2 - объект-цель (корабль/станция, астероид, предмет или ракета);
	3 - конкретное ракетное (не проверял с другими типами) орудие, которое производит выстрел (может находиться где угодно в Галактике (или в хранилище), но должно существовать в виде предмета, степень износа не важна);
  Опционально:
	4 - порядковый номер ракеты (начиная с 0), нужен чтобы можно было производить "веерные" запуски, для чего необходимо вызвать функцию несколько раз, каждый раз задавая последующий номер;
  Примечание: Если запустить торпеду с помощью данной функции, но не менять значение боезапаса вручную, то потеряв цель, торпеда вернётся обратно на корабль и пополнит боезапас запустившего её орудия, если оно находится на корабле (проверяет по Id), но выше максимума пополнить всё равно не сможет.
DealDamageToShip - наносит урон кораблю не учитывая броню и ГЗП, но учитывая процентные модификаторы артефактов и оружейных модификаций, а также резисты корпуса:
	1 - цель (корабль/станция);
	2 - объект источник урона (может быть 0);
	3 - урон;
	4 - дамагсет;
  Опционально:
	5 - радиус урона от сплеша;
	  Важно: При вызове из акткода данная функция прерывает исполнение акткода и наносит урон кораблю/предмету у которого также может сработать акткод с аналогичным событием (в том числе с такой же инфошки, что приведёт к перезаписи значения переменных уже в изначальном акткоде), что может в итоге привести к неконтролируемой циклической реакции срабатываний акткода между разными кораблями/предметами. Используйте данную функцию с должной осторожностью!
	  Примечание: Имеется в виду, что сама функция наносит указанной цели сплешевый урон, а не раздаёт сплеш на все окружающие цели. Радиус здесь - это лишь расстояние до условной основной цели (которой урон нужно наносить отдельно). При этом если указана дружественная цель, то такой урон будет автоматически занулён (т.к. весь сплеш в игре именно так и работает). Не задавайте этот аргумент, либо установите его в -1, если подразумевается, что вы наносите урон по основной цели.
RuinsMicromoduleChain - возвращает подходящий* микромодуль (номер бонуса) из цепочки предлагаемых станцией (любой, не обязательно ЦР) на текущий момент:
	1 - станция;
	2 - уровень микромодуля, который необходимо вернуть:
	   0 - ММ третьего уровня;
	   1 - ММ второго уровня;
	   2 - ММ первого уровня;
  Опционально:
	3 - номер ММ из текущей цепочки (0-50), *по умолчанию вернёт ММ, подходящий игроку по хардкодовым условиям выдачи (проверит содержимое корабля);
	4 - маркер (0/1) для возврата ММ из альтернативной цепочки;
	  Примечание: Альтернативная цепочка отличается от основной только (!) более редким списком микромодулей первого уровня. Получить микромодули первого уровня из альтернативной цепочки игрок может в каждый кратный 33 номер хода. Альтернативная цепочка обновляется одновременно с основной.
  Примечание: Хардкодовая логика предусматривает выдачу ММ строго по списку, однако также она учитывает содержимое корабля игрока. Если на корабле игрока имеется оборудование, в которое можно вставить очередной ММ в цепочке (начиная с нулевого), а также данного ММ на его корабле ещё нет (уже вставленные ММ не в счёт), то к покупке будет предложен именно он. В противном случае игра переходит к следующему ММ в цепочке и повторяет проверку. Никакой "истории покупок" у игры нет, благодаря чему можно бесконечно получать один и тот же ММ в цепочке, просто перекладывая только что купленный ММ на склад. В случае если игрок за раз скупил все ММ в цепочке (либо проверка не обнаружила на его корабле подходящего оборудования (оборудование с уже установленным ММ также считается неподходящим) и прокрутила цепочку в конец списка), то ему будет до бесконечности предлагаться последний ММ в цепочке. Все цепочки ММ для всех станций в Галактике обновляются одновременно, раз в 57 дней (каждый кратный 57 номер хода).


Функции для получения игровых достижений (тех же, что есть и в Steam):
GetAchievementSHU - без аргументов, получить достижение "Клонобоец";
GetAchievementGIRLSHIRE - без аргументов, получить достижение "Если б я был султан...";
GetAchievementGIRLSQUEST - без аргументов, получить достижение "Подкаблучник";
GetAchievementPIRATEWIN - без аргументов, получить достижение "Рачехан и все-все-все";
GetAchievementCOALLITION - без аргументов, получить достижение "За коалицию!";
GetAchievementHULL - без аргументов, получить достижение "Мир и порядок!";

Типы товаров:
  t_Food (0) - продукты;
  t_Medicine (1) - медикаменты;
  t_Technics (2) - техника;
  t_Luxury (3) - роскошь;
  t_Minerals (4) - минералы;
  t_Alcohol (5) - алкоголь;
  t_Arms (6) - оружие;
  t_Narcotics (7) - наркотики;

Типы предметов:
  t_Artefact (8) кастомный артефакт
  t_Artefact2 (9) неломаемый кастомный артефакт (создаётся добавлением в его раздел в Lang параметра NoWear=1)
  t_ArtefactHull (10) Железные жупи, минимальный размер 11
  t_ArtefactFuel (11) Чёрная жижа, минимальный размер 4
  t_ArtefactSpeed (12) Пси-ускоритель материи, минимальный размер 11
  t_ArtefactPower (13) Отморозки, минимальный размер 7
  t_ArtefactRadar (14) Пролонгер, минимальный размер 9
  t_ArtefactScaner (15) Сканерный кэш, минимальный размер 8
  t_ArtefactDroid (16) Дроид младший, минимальный размер 9
  t_ArtefactNano (17) Нанитоиды, минимальный размер 3
  t_ArtefactHook (18) Эриметр, минимальный размер 3
  t_ArtefactDef (19) Поляризатор, минимальный размер 11
  t_ArtefactAnalyzer (20) Вероятностный анализатор, минимальный размер 5
  t_ArtefactMiniExpl (21) Локализатор взрывной волны, минимальный размер 10
  t_ArtefactAntigrav (22) Антигравитатор, минимальный размер 18
  t_ArtefactTransmitter (23) Трансфакторный маяк, минимальный размер 3
  t_ArtefactBomb (24) Кварковая бомба, минимальный размер 5
  t_ArtefactTranclucator (25) Транклюкатор, минимальный размер 45
  t_ArtDefToEnergy (26) Пропорционар, минимальный размер 5
  t_ArtEnergyPulse (27) Пятерик, минимальный размер 8
  t_ArtEnergyDef (28) Проглот, минимальный размер 5
  t_ArtSplinter (29) Навинт, минимальный размер 9
  t_ArtDecelerate (30) Вжик, минимальный размер 5
  t_ArtMissileDef (31) Ракетанг, минимальный размер 6
  t_ArtForsage (32) Обливионный коннектор, минимальный размер 6
  t_ArtWeaponToSpeed (33) Сопланатор, минимальный размер 7
  t_ArtGiperJump (34) Гипергенератор, минимальный размер 5
  t_ArtBlackHole (35) Субпортал, минимальный размер 3
  t_ArtDefToArms1 (36) Протон, минимальный размер 8
  t_ArtDefToArms2 (37) Армс, минимальный размер 7
  t_ArtArtefactor (38) Артефактор, минимальный размер 3
  t_ArtBio (39) Биомир, минимальный размер 3
  t_ArtPDTurret (40) а'Эгис, минимальный размер 9
  t_ArtFastRacks (41) Ралс, минимальный размер ???
  t_Hull (42) корпус;
  t_FuelTanks (43) топливный бак;
  t_Engine (44) двигатель;
  t_Radar (45) радар;
  t_Scaner (46) сканер;
  t_RepairRobot (47) дроид;
  t_CargoHook (48) захват;
  t_DefGenerator (49) ГЗП;
Э   t_Weapon1 - Промышленный лазер (50), все расы;
О   t_Weapon2 - Осколочное орудие (51), все расы;
Э   t_Weapon3 - Лезка (52), все расы;
Р   t_Weapon4 - Ракетомет (53), все расы;
Э   t_Weapon5 - Третон (54), все расы;
Э   t_Weapon6 - Волновой фазер (55), все расы;
О   t_Weapon7 - Потоковый бластер (56), все расы;
Э   t_Weapon8 - Электронный резак (57), все расы;
О   t_Weapon9 - Мультирезонатор (58), все расы;
Э   t_Weapon10 - Атомный визион (59), все расы;
Э   t_Weapon11 - Дезинтегратор (60), все расы;
Э   t_Weapon12 - Турбогравир (61), все расы;
О   t_Weapon13 - ИМХО-9000 (62), только доминаторы;
Э   t_Weapon14 - Вертикс (63), только доминаторы;
Р   t_Weapon15 - Торпедный аппарат (64), только доминаторы;
О   t_Weapon16 - Эсодафер (65), только пиратский клан;
Э   t_Weapon17 - Кафаситор (66), только пиратский клан;
Р   t_Weapon18 - Лирекрон (67), только пиратский клан;
    t_CustomWeapon - любое кастомное оружие (68), проверять его строковый кастомный тип необходимо функцией CustomWeaponType();
  t_Protoplasm - ноды (69);
  t_UselessItem - квестовый (юзлесный) предмет (70);
  t_MicroModule - микромодуль (71);
  t_Cistern - цистерна (72) (в скриптовом коде может быть создана функцией CreateEquipment());
  t_Satellite - зонд (73);
  t_UselessCountableItem - кастомный сыпучий (74);

Бонусы для акринов и микромодулей (могут иметь отрицательные значения и выступать в качестве штрафов):
  bonHull (0) - бонус к броне корпуса;
  bonFuel (1) - бонус к объему топливного бака (работет только в качестве бонуса от ММ)****;
  bonSpeed (2) - бонус к скорости двигателя;
    Примечание: Все акриновые бонусы к скорости сперва плюсуются к текущей скорости двигателя, а расчёт фактической скорости корабля происходит позднее.
  bonJump (3) - бонус к дальности прыжка двигателя;
  bonRadar (4) - бонус к дальности радара;
  bonScan (5) - бонус к мощности сканера;
  bonDroid (6) - бонус к эффективности починки дроида;
  bonHook (7) - бонус к размеру захватываемых захватом предметов;
  bonDef (8) - бонус к мощности генератора защитного поля;
  bonWEnergy* (9) - бонус к силе энергетического оружия;
  bonWSplinter* (10) - бонус к силе осколочного оружия;
  bonWMissile* (11) - бонус к силе ракетного оружия;
  bonWRadius* (12) - бонус к дальности стрельбы оружия;
  bonSlotRadar (13) - открыть/закрыть слот радара;
  bonSlotScaner (14) - открыть/закрыть слот сканера;
  bonSlotDroid (15) - открыть/закрыть слот дроида;
  bonSlotHook (16) - открыть/закрыть слот захвата;
  bonSlotDef (17) - открыть/закрыть слот генератора защитного поля;
  bonSlotWeapon (18) - открыть/закрыть слоты оружия;
  bonSlotArt (19) - открыть/закрыть слоты артефактов;
  bonSlotForsage (20) - открыть/закрыть слот форсажа;
  bonHookRadius (21) - бонус к дальности действия захвата;
  bonSkill1 (22) - изменяет навык точности;
  bonSkill2 (23) - изменяет навык манёвренности;
  bonSkill3 (24) - изменяет навык техники;
  bonSkill4 (25) - изменяет навык торговли;
  bonSkill5 (26) - изменяет навык обаяния;
  bonSkill6 (27) - изменяет навык лидерства;
  bonMass (28) - изменяет процент массы корабля и установленного оборудования (работает только в качестве бонуса от корпусного акрина, либо от ММ);
  bonExtraAkrinEff (29) - изменяет мощность акрина, при значении 100 эффект акрина увеличивается в 2 раза (работет только в качестве бонуса от ММ);
  bonExtraAkrinPenalty (30) - изменяет мощность отрицательного акринового бонуса, при этом положительное не изменяется (работет только в качестве бонуса от ММ);
  bonAmmo* (31) - увеличение боезапаса ракетного оружия (применимо только для ракетного оружия, не работает из спецакрина);
  bonShots* (32) - добавляет ракеты к выстрелу, применимо только для ракетного оружия с типом выстрела Rocket или Missile (бонус работает только из акрина на оружие или ММ);
  bonMissileSpeed* (33) - увеличивает скорость выпускаемых ракет/торпед (применимо только для ракетного оружия);
  bonShotSpeed* (34) - изменение очерёдности выстрела (применимо только для оружия);
  bonHookMaxSpeed*** (35) - прибавка к скорости притяжения захвата на дальней дистанции;
  bonHookMinSpeed*** (36) - прибавка к скорости притяжения захвата на ближней дистанции;
  bonStimCapacity (37) - изменяет максимальное количество принимаемых игроком за раз стимуляторов (учтите, что на МЦ фактическое число стимуляторов для приема в установленном игрой и бонусами диапазоне определяется рандомом);
  bonZonds (38) - бонус к максимальному лимиту зондов под контролем игрока (при превышении лимита износ активных зондов ускоряется);
  bonAttacks* (39) - дополнительное число выстрелов за ход в конкретном орудии (бонус работает только из акрина или ММ на оружие, либо из ShipSpecialBonuses**);
  bonResistAsteroid (40) - снижает/увеличивает урон от попадания астероидов в процентном соотношении, где 0 - базовое для корабля значение (bonResistAsteroid=50 снизит урон от попадания астероида в два раза);
    *Примечание: Все оружейные (с приставкой W, а также бонусы bonShots, bonAttacks, bonShotSpeed, bonMissileSpeed и bonAmmo) бонусы, будучи записаны в оружейные акрины, применяются только на то орудие, в котором установлен соответствующий акрин. Все прочие бонусы на оружейных акринах работают по общим правилам.
    **Примечание: При использовании бонуса bonAttacks в ShipSpecialBonuses, в каждое орудие будут добавлены не дополнительные выстрелы, но полная итерация его залпа за ход. К примеру, если орудие должно выстрелить 3 раза за ход, то с ShipSpecialBonuses +2 оно сделает 9 выстрелов, а с ShipSpecialBonuses -1 ни одного. Скорость износа всех орудий, при наличии данного бонуса, снижается пропорционально числу дополнительных залпов.
    ***Примечание: Скорость притяжения предмета минимальна на пределе дистанции захвата и максимальна в нулевой точке, то есть в координатном центре самого корабля. Чем ближе предмет лежит к кораблю - тем выше скорость захвата. Минимальное значение скорости захвата составляет 0.1, так что полностью опуститься в ноль она не сможет ни при каких бонусах.
	****Также бонус к объёму бака можно навесить в виде штрафа через ShipSpecialBonuses(), и хотя визуально никакой разницы в карточке корабля видно не будет, для NPC такая метка будет означать запрет на совершение прыжков (если поставить -1000, например), т.к. он будет считать, что топлива на прыжок ему никуда не хватает. Фактически, костыль на запрет совершения прыжков для NPC.

Список событий для интерфейсного кода:
OnPressCode - данный код срабатывает при левом щелчке мышью по объекту (только для GraphButton);
OnMouseRightClick - данный код срабатывает при правом щелчке мышью по объекту (не вызывает срабатывания анимации нажатия, только для GraphButton);
OnMouseEnterCode - данный код срабатывает при наведении курсора на объект;
OnMouseLeaveCode - данный код срабатывает при уводе курсора с объекта;

Дополнительная информация:
  Срабатывание тернкода в скриптах:
	 TurnCode или тёрнкод, буквально означает "код хода", поэтому логично было бы ожидать, что он срабатывает каждый ход. Тем не менее, это не совсем так. Также данный ход срабатывает в моменты взлёта/посадки игрока, а также при влёте/вылете его из ЧД. Помимо этого, тернкод конкретного скрипта срабатывает при завершении игроком скриптового (запущенного из конкретного скрипта) текстового квеста, чтобы "поймать" и обработать результат его выполнения успех/провал.
	 Данную особенность этого исполнителя важно понимать, чтобы не вешать в него "ежедневные" счётчики вида: x = x - 1 (такие возможно использовать только в событии t_OnStep в акткоде). Вместо них нужно пользоваться не прямыми счётчиками вида: x = x + CurTurn(), и далее проверять его срабатывание состояние через if(x <= CurTurn()).
  На какой планете выдают награду при освобождении системы:
	 Награду за освобождение системы всегда выдают на первой (от звезды) заселённой планете.
  Добавление кастомных правительственных наград (медалей, орденов и т.д.):
     Все награды в КР размещены в разделе Reward в игровом Lang и могут быть, при желании, дополнены новыми. Для этого достаточно добавить новую награду на незанятый порядковый номер (перед этим убедившись, что его не используют другие моды) и увеличить общий счётчик Count в конце раздела с наградами. Максимальное число наград в игре ограничено и составляет 256 слотов (0-255), из которых оригинальная игра использует всего 48 (0-47). В моде ExpBlackMarket была добавлена скриптовая 49-я (номер 48 в Lang) награда, а в ShuRebellion 50-я (номер 49 в Lang).
	 Если вам по какой-либо причине нужно добавить в список награду, которая не должна автоматически выдаваться в игре (например, вы хотите выдавать её скриптом), то необходимо "заблокировать" два параметра этой награды, а именно Race и Status, путём подстановки невалидного значения (пустое будет расценено игрой как "Any") в качестве которого отлично подойдёт, например "None". Параметр Type необходимо указывать корректно в любом случае, т.к. он игре необходим.
  Перебор расы при создании корпуса/оборудования/артефакта/предмета:
     Если нужно рандомно определить расу-производителя, но при этом вы хотите исключить из списка возможных рас, например, доминаторов, удобнее всего будет воспользоваться подобной командой: while(race == 5) race = Rnd(0, 7);
  Исключение Тортугаца и Нифигаца при переборе систем:
	 Наиболее удобный способ (исключающий проверку по названиям систем), использовать проверку вида:
	 if(StarToCon(star) == StarToCon(PlanetToStar(PlanetPirateClan())));
  Как выявить рейнджера со скином корпуса "Таухито":
	 Скин "Таухито" намертво прописывается хардкодом на корабли при исполнении всех нижеперечисленных условий:
	   - Корабль является рейнджером (ShipTypeN(ship) == t_Ranger);
       - Корабль имеет Id кратный шести;
	   - Ход рождения корабля меньше 666;
	   - Корабль имеет человеческую расу пилота;
	   - Корабль не имеет женский портрет;
	 Чтобы "снять" с корабля данный скин и "серию" (хотя на самом деле это не настоящая серия), необходимо либо сменить расу пилота, либо установить женский портрет. Также проверить наличие данного скина можно, запросив прямой адрес функцией Chameleon().
  Как проверить размер правительственной награды в коде текстового квеста:
     GRewardMoney - параметр внутри текстового квеста. При его наличии туда будет записан размер основной награды за квест, которую получит игрок. Может быть полезно для расчёта дополнительной награды в % от основной, а не по фиксированной быстроустаревающей (из-за инфляции) константе.
  Общие переменные в текстовых квестах и скриптах:
	 При объявлении в скрипте глобальной переменной вида GQuestVarExt_SomeVar (в названии должна присутствовать приставка 'GQuestVarExt_'), и одновременном объявлении в текстовом квесте параметра ext_SomeVar (должна присутствовать приставка 'ext_', а также должно совпадать название самой переменной), их значения будут всегда синхронизированы.
