Специальные отладочные чит-коды:
SUDO - код для вызова консоли разработчика, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
EVENTS - код для вывода в лог всех текущих Галактических событий, работающий только в тестовых экзешниках (получить такие можно у evilcoward);
INFOS - код для вывода в лог подробной информации обо всех инфошках на всех кораблях Галактики;
ZAWARUDO - код для "заморозки времени" (полностью останавливает расчёт ходов), однако при перелётах между системами может отрабатывать некорректно;

Особые игровые параметры для кастомных артефактов:
NoWear - полностью отключает износ у данного артефакта, делает его неломаемым, а также меняет тип его предмета с t_Artefact на t_Artefact2: 1 - данный артефакт становится неломаемым;
CountsAs - заставляет ботов считать данный кастомный арт одним из оригинальных, что позволяет им использовать его автоматически: 1 - системное название оригинального артефакта, пример: CountsAs=ArtMiniExpl
SharedUse - при указании этого тэга вместе с CountsAs, игра будет считать данный артефакт аналогом оригинала и не позволит установить его в слот, если на кораблей уже и так установлен оригинальный арт или любой другой арт с таким тэгом: 1 - считать данный артефакт аналогом оригинала при установке в слот;
SharedEffect - при указании этого тэга вместе с CountsAs, игра превратит данный кастомный артефакт в полный аналог оригинального, включая полное повторение всех его активных и пассивных эффектов (но для блокировки слота указать SharedUse всё равно надо). Данный тэг может быть полезен, если вы хотите изменить работу оригинального арта, но вам также нужны переменные под запись данных в артефакт (CustomArtData), которых у оригинальных артов попросту нет: 1 - данный артефакт будет иметь тот же эффект, что и оригинальный;

Полезные параметры для графических (и прочих) элементов в Main:
PosAutoCorrection - включает/выключает автокоррекцию позиции конкретного элемента для всех игровых разрешений: True - включить, False - выключить;
PosAutoCorrectionXCoef - коэффициент корректировки позиции по оси X, принимает дробные значения, в обычной ситуации от 0.0 (самая левая часть экрана) до 1.0 (самая правая часть экрана), хотя возможны и отрицательные значения;
PosAutoCorrectionYCoef - коэффициент корректировки позиции по оси Y, принимает дробные значения, в обычной ситуации от 0.0 (самая верхняя часть экрана) до 1.0 (самая нижняя часть экрана), хотя возможны и отрицательные значения;
  Примечание: Сперва настройте желаемую позицию элемента в разрешении 1024x768, а затем "подровняйте" его с помощью PosAutoCorrection на любом другом разрешении до желаемого результата (наиболее часто подходящие значения 0.5 и 1.0). В итоге вы получите полную адаптацию позиции элемента под любые разрешения.
ImageFirst - параметр для объекта типа GAI, в котором указывается опорный кадр в случае, если прикреплённой анимации он необходим;
SoundStart - параметр для объекта типа GAI, проигрывает указанный звук при начале воспроизведения прикреплённой анимации (пример, SoundStart=Sound.Sell);
Radius - параметр для звезды, задаёт радиус области в центре системы, в которой будет выводиться информация о звезде при наведении курсора;
SafeRadius - параметр для звезды, задаёт безопасный радиус облёта звезды, в зависимости от которого корабли будут выбирать свою траекторию;
DamageRadius - параметр для звезды, задаёт радиус, в пределах которого кораблям будет наноситься урон от звезды;
DrawLines - параметр для раздела 'Data.StyleConstellation' в Main.dat. Включает и отключает отрисовку линий между группами звёзд на галакарте:
	Yes - включить отрисовку линий созвездий;
	No - выключить отрисовку линий созвездий;
LinesColor - параметр для раздела 'Data.StyleConstellation' в Main.dat. Меняет цвет линий между группами звёзд на галакарте и имеет нестандартную форму записи формата RGB, где каждый цвет задаётся не байтовой переменной (0 - 255), а через float от 0.0 до 1.0 (пример, LinesColor=1.0,1.0,0.0);
WeaponPort1 - параметр для анимации корабля. Устанавливает точку на анимации, из которой будут отрисовываться выстрелы орудий. Всего можно добавить до 10 таких точек (WeaponPort1, WeaponPort2, WeaponPort3 и т.д.). Номер точки, из которой будет произведён следующий выстрел, определяется случайным образом.
Tail1 - устанавливает точку на анимации, из которой будет отрисован динамический след двигателя корабля. Всего можно установить до 10 таких точек (Tail1, Tail2, Tail3 и т.д.).
  Примечание: Параметры WeaponPort и Tail принимают координаты точки (пикселя) на анимации в формате 'Tail=X,Y'.

Прочие полезные фичи:
  Дополнительные параметры для палитр к акринам на оружие:
	SoundShot - звук выстрела, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше;
	SoundExpl - звук разрыва ракеты/торпеды, который заменит стандартный игровой звук для данного орудия, прописывается полным путём в кэше (подставляется в палитру разрыва ракеты/торпеды);
  Название атрибута для добавления серий корпуса флагманам:
    Flagman - подставляется в раздел конкретной серии в параметр ShipType (не включён в список атрибута Any);
  Дополнительные параметры Main.dat для ракет (раздел 'ML.Missile'):
	Scale - определяет визуальный размер анимации ракеты/торпеды, по умолчанию для всех ракет задан как 1.0;

Различные игровые параметры для бонусов (параметры добавляется в раздел бонуса в Lang, пример: Special=1):
Special - означает, что текущий бонус является акрином (или, по крайней мере, особым ММ), чтобы он не выпадал в списках выдачи ММ на ЦР: 1 - бонус является акрином или особым ММ;
Color - тэг для указания цвета имени бонуса (ММ или акрина). В отличие от прямого подставления цветовых тэгов в параметр Name, Color полностью меняет имя бонуса во всех подстановках, в т.ч. цвет кавычек ММ после его установки в предмет, пример: Color=41,125,222 (цвета указываются в формате RGB);
Equipments - для акринов обозначает, к какому типу предметов игра будет автоматически применять данный акрин в магазинах, а для ММ, в предметы какого типа может быть установлен данный микромодуль:
	'Any' - аналогичен параметру "по умолчанию" (если Equipments в бонусе не указан) и включает в себя любые типы оборудования и оружия;
	   Важно: Если данное значение не занимает всю строку (к примеру записано Equipments=Any,Hull), то в качестве валидного показателя оно засчитано не будет и все необходимые типы предметов придётся указывать вручную.
	'Hull' - бонус может быть применён к любому корпусу;
	'Engine' - бонус может быть применён к любому двигателю;
	'FuelTank' - бонус может быть применён к любому топливному баку;
	'Radar' - бонус может быть применён к любому радару;
	'Scaner' - бонус может быть применён к любому сканеру;
	'Droid' - бонус может быть применён к любому дроиду;
	'Hook' - бонус может быть применён к любому захвату;
	'DefGenerator' - бонус может быть применён к любому ГЗП;
	'WEnergy' - бонус может быть применён к любому энергетическому оружию;
	'WSplinter' - бонус может быть применён к любому осколочному оружию;
	'WMissile' - бонус может быть применён к любому ракетному оружию;
	'W01' - бонус может быть применён к промышленному лазеру;
	'W02' - бонус может быть применён к осколочному орудию;
	'W03' - бонус может быть применён к лезке;
	'W04' - бонус может быть применён к ракетомету;
	'W05' - бонус может быть применён к третону;
	'W06' - бонус может быть применён к волновому фазеру;
	'W07' - бонус может быть применён к потоковому бластеру;
	'W08' - бонус может быть применён к электронному резаку;
	'W09' - бонус может быть применён к мультирезонатору;
	'W10' - бонус может быть применён к атомному визиону;
	'W11' - бонус может быть применён к дезинтегратору;
	'W12' - бонус может быть применён к турбогравиру;
	'W13' - бонус может быть применён к ИМХО-9000;
	'W14' - бонус может быть применён к вертиксу;
	'W15' - бонус может быть применён к торпедному аппарату;
	'W16' - бонус может быть применён к эсодаферу;
	'W17' - бонус может быть применён к кафаситору;
	'W18' - бонус может быть применён к лирекрону;
	'Имя типа кастомного оружия' - бонус может быть применён к указанному кастомному оружию;
Owner - для акринов обозначает, к каким расам игра будет автоматически применять данный акрин в магазинах (актуально только для коалиционных рас и пиратов), а для ММ, в предметы с какой расой может быть установлен данный микромодуль:
	'Any' - аналогичен параметру "по умолчанию" (если Owner в бонусе не указан) и включает в себя все расы, кроме неизвестной;
	  Важно: Если данное значение не занимает всю строку (к примеру записано Owner=Any,None), то в качестве валидного показателя оно засчитано не будет и все необходимые расы придётся указывать вручную.
	'Maloc' - добавляет в набор малокскую и доминаторскую расу;
	'Peleng' - добавляет в набор пеленгскую и доминаторскую расу;
	'People' - добавляет в набор человеческую и доминаторскую расу;
	'Fei' - добавляет в набор фэянскую и доминаторскую расу;
	'Gaal' - добавляет в набор гаальскую и доминаторскую расу;
	'PirateClan' - добавляет в набор пиратскую и доминаторскую расу;
	'None' - добавляет в набор неизвестную и доминаторскую расу;
	'Blazer' - ограничивает применение бонусов к доминаторскому оборудованию только блазероидной серией;
	'Keller' - ограничивает применение бонусов к доминаторскому оборудованию только келлероидной серией;
	'Terron' - ограничивает применение бонусов к доминаторскому оборудованию только терроноидной серией;
	   Примечание: Ограничительные указатели серий допустимо комбинировать, например как 'Owner=Maloc,Blazer,Terron'.
	'NonKling' - особый указатель, запрещающий установку данного бонуса в любое доминаторское оборудование (как автоматическими скриптовыми функциями, так и вручную игроком);
  Важно: Как бы вы не составляли набор, если в нём отсутствует указатель 'NonKling', доминаторская раса будет неизбежно присутствовать в его составе! Например, строка 'Owner=Maloc' или 'Owner=None' будет фактически расценена игрой как 'Owner=Maloc,Kling' и 'Owner=None,Kling' соответственно. Ограничить же применение бонуса только к доминаторскому оборудованию можно, добавив параметр 'Owner=ewfksdf', где само значение невалидного указателя значения не имеет (с тем же успехом можно писать и 'Owner=Kling'). Если же составить параметр как 'Owner=NonKling', то такой бонус будет запрещён к установке вообще везде.
  Примечание: Строка 'Kling' валидным параметром не является и не проверяется игрой. Вместо неё можно вписывать любой набор букв с точно таким же результатом.
RacialRestriction - блокирует применение бонусов данного ММ/акрина на представителей иных рас, кроме тех, что указаны в параметре Owner этого же бонуса (использовать такие предметы смогут любые расы, но вот получать от них бонусы будут не все): 1 - разрешить применение данных бонусов только для представителей определённых рас;
BlockMM - запрещает устанавливать микромодуль в предмет с данным акрином (только основным акрином, из спецакрина этот запрет работать не будет): 1 - установка микромодуля запрещена;
HullGraphSize - параметр для акрина корпуса в Lang, который меняет визуальный размер этого корпуса (стандартный размер 100, размер флагмана 200);
Fragility - меняет модификатор износа предмета, но имеет обратную зависимость. Fragility=70 (100/70) будет означать замедление скорости износа (предмет получит прочность в 142% от исходной), а Fragility=120 (100/120) - ускорение скорости износа (83% прочности от исходной). При установке бонуса с Fragility в корпус, будет меняться его восприимчивость к урону;
FragilityEnergy - бонус/штраф к восприимчивости к энергетическому урону (только для корпуса);
FragilityMissile - бонус/штраф к восприимчивости к осколочному урону (только для корпуса);
FragilitySplinter - бонус/штраф к восприимчивости к ракетному урону (только для корпуса);
  Примечание: Специализированные Fragility по типам урона записываются в бонус аналогично общему. Если в бонусе для корпуса прописан общий Fragility, то он будет применён сразу на все три типа восприимчивости к урону корпуса. Если в бонусе прописан только специализированный(е) Fragility, то он будет применён только для соответствующего типа сопротивляемости. Если же в бонусе прописан и общий и специализированный Fragility, то для типов урона без указанного специализированного Fragility будет применён общий, а для тех, для которых специализированный указан, специализированный Fragility.
WeaponMods - параметр для добавления дополнительных эффектов в дамагсет оружия через бонусы (ММ или акрины), накладываемые на это орудие (добавлять в виде строки, через запятые и без пробелов):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели;
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм);
  'Shock' (64) - вешает на цель эффект ионизации;
  'Acid' (128) - ослабляет броню цели;
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);

Кастомные параметры для бонусов:
UniqueMM - параметр, обозначающий, что данный бонус является микромодулем, хотя и имеет тэг Special, необходим исключительно для маркировки уникальных микромодулей:
	1 - данный бонус является уникальным микромодулем и может быть получен лишь один раз за всю партию;
	2 - данный бонус является особым микромодулем, но может быть получен неограниченное количество раз за партию (полезно для маркировки особых ММ, которые не должны попадать в стандартную выдачу ЦР);
LockedAcryn - запрещает накладывать/снимать бонус с оборудования в моде ExpScienceRanks:
	1 - запрещено снимать;
	2 - запрещено накладывать;
	3 - запрещено накладывать и снимать;
NotRemovable - параметр только для микромодулей, запрещает извлечение ММ в моде EvoSB:
	1 - данный микромодуль невозможно извлечь (с помощью этого тэга можно создавать модули-затычки);
NotImprovable - запрещает улучшать оборудование/корпус с данным акрином в модах EvoSB и ExpTC:
	1 - улучшение оборудования/корпуса запрещено;
NonSearchable - блокирует занесение этого бонуса в список доступных для автопоиска в моде ExpAutoSearch:
	1 - бонус не будет отображаться в списке поиска (имеет смысл блокировать особые акрины, которые в любом случае никак не могут попасть в магазин);
	2 - акрин, имитирующий отсутствие акрина (предмет с ним будет распознан скриптом ExpAutoSearch как предмет без акрина вовсе);
NonRepairable - блокирует возможность ремонта оборудования/корпуса с данным бонусом на всех базах в моде ExpRepair:
	1 - ремонт запрещён;
NoBridge - параметр только для акринов на корпуса, запрещает добавлять на корпус с данным акрином мостик из мода ExpPilotBridge:
	1 - мостик на корпус с данным акрином добавляться не будет;
BioEquip - параметр, помечающий данное оборудование как биологическое (например, биогенные дроиды), что полезно для блокировки некоторых бонусов:
	1 - оборудование является биологическим объектом;
AcrynSerie - имя, подходящее сразу всей линейке оборудования, имеющего акрины нескольких уровней (I, II, III и т.д.) При установке данного параметра, оборудование будет считаться многоуровневым, что желательно для нормальной работы мода ExpScienceRanks;
SerieLevelN - где N означает номер уровня данного акрина (в разделе бонуса указывать как SerieLevel1, SerieLevel2 и т.д.) SerieLevelN напрямую связан с параметром AcrynSerie. В этом параметре должно быть указано имя раздела Lang, в котором записывается данный бонус.
  Пример: SerieLevel1=374 - соответствует бонусу "Миоплазменный двигатель I";
AcrynLevel - указатель на конкретный уровень акрина в его серии;
LevelsCount - число, обозначающее общее количество уровней данного акрина (2, 3, 4 и т.д.) Все три последних параметра требуются для нормальной работы механики акринации в моде ExpScienceRanks;
  Примечание: Параметр добавляется в общий раздел бонуса, пример: LockedAcryn=3
ImitatedHullType - тэг для акринов на корпуса, отмечающий, какой оригинальный тип корпуса имитирует данный акрин (если нужна имитация), что имеет значение в запросах автопоиска из мода ExpAutoSearch (можно указать сразу несколько подходящих типов через запятую без пробелов):
	'Ranger' - корпус рейнджера;
	'Warrior' - корпус военного;
	'Pirate' - корпус пирата;
	'Transport' - корпус транспорта;
	'Liner' - корпус лайнера;
	'Diplomat' - корпус дипломата;
	'Flagman' - корпус флагмана;


Кастомные функции из мода UtilityFunctionsPack (для использования их в своём скрипте, нужно сперва подключить библиотеку к конкретному скрипту через Main, а для использования в интерфейсном, Act или Use коде, необходимо использовать функцию ImportAll, либо ImportedFunction):
GetParFromString - разбивает строку через разделители и возвращает отрезок под указанным номером (при выходе номера за диапазон вернёт ''):
	1 - строка;
	2 - разделитель;
	3 - номер отрезка, который необходимо вернуть, начиная с 0;
	4 - маркер очистки всех пробелов в возвращаемой строке (0/1);
  Пример: Запрос GetParFromString('A --B --C ', '--', 1, 1) вернёт 'B'.
TrimNumbers - удаляет все числовые символы из строки:
	1 - строка;
RoundUp - округляет дробное число к большему:
	1 - дробное число;
Exponent - возводит число X в степень Y: 1 - число X, 2 - число Y (допустимы дробные);
DistCoords - считает и возвращает расстояние между двумя точками по их координатам:
	1 - координата X первой точки;
	2 - координата Y первой точки;
	3 - координата X второй точки;
	4 - координата Y второй точки;
PortionInDiapason - переводит указанное значение из одного диапазона в другой:
	1 - текущее значение (число);
	2 - начало диапазона, в котором находится текущее значение;
	3 - конец диапазона, в котором находится текущее значение;
	4 - начало диапазона, в который нужно перевести значение;
	5 - конец диапазона, в который нужно перевести значение;
  Пример: PortionInDiapason(3,1,10,1,20); переведёт 3 из диапазона 1-10 в диапазон 1-20 и в итоге вернёт нам 6. А в случае, если текущее значение выйдет за рамки первого диапазона (например, равно 11), вернёт максимальную или минимальную величину второго диапазона (то есть 20, если текущее значение равно 11).
CustomArtCostCalc - функция для определения случайной стоимости кастомного артефакта по заданной формуле с учётом текущей сложности и ГТУ: 1 - базовое значение (рекомендуемый диапазон от 1000 (очень дешёвый арт) до 3000 (очень дорогой арт)), 2 - уровень сложности настройки разброса цен, GalaxyDiffLevels(1), 3 - галактический ТУ, GalaxyTechLevel();
CustomArtSizeCalc - функция для определения случайного веса кастомного артефакта по заданной формуле с учётом текущей сложности игры: 1 - минимальный вес (для сложности в 50%), 2 - уровень сложности настройки оборудования, GalaxyDiffLevels(4);
  Примечание: Обе эти функции не могут вернуть значение ниже 1.
IsShiftCtrlPressed - проверяет, нажаты ли сейчас обе клавиши Shift+Ctrl и возвращает 1, если нажаты, и 0, если нет;
SendStringToClipboard - записывает (удаляя содержимое) указанную строку в системный буфер обмена: 1 - строка;
GetStringFromClipboard - без аргументов, возвращает строку из системного буфера обмена (если в буфере не оказалось строки, то вернёт '');
SetModsCFGValue - записывает указанный параметр и его значение (если параметр с таким именем в конфиге уже есть, то просто изменит его значение) в txt-файл ModsCFG, который расположен в документах, в соответствующей игровой папке: 1 - название параметра строкой, 2 - значение параметра числом;
GetModsCFGValue - возвращает значение определённого параметра из txt-файла ModsCFG: 1 - название параметра строкой;

Вызов скрипта и всё с этим связанное:
GRun - без аргументов, запускает текущий скрипт (работает только из глобал-кода скрипта);
ScriptRun - запускает скрипт с конкретным именем (возвращает 1 при успешном запуске):
	1 - система запуска;
	2 - планета запуска;
	3 - имя скрипта строкой;
GCntRun - возвращает количество запусков данного скрипта за текущую партию:
	1 - имя скрипта строкой;
GLastTurnRun - возвращает ход, когда скрипт был запущен в последний раз:
	1 - имя скрипта строкой;
IsScriptActive - проверяет, существует и активен ли указанный скрипт:
	1 - имя скрипта строкой;
GAllCntRun - без аргумента, возвращает общее количество активных скриптов;
GRunFrom - внутренняя глобальная переменная для определения состояний местонахождения игрока. Используется для запуска глобального кода во всех скриптах (а точнее принимает определённое значение при каждом срабатывании глобального кода) и может быть использована для точного определения времени запуска. Возможные значения переменной:
  0 - выставляется после совершения посадки игроком;
  1 - выставляется перед взлётом игрока;
  2 - выставляется после начала прыжка (на входе в гипер);
  3 - выставляется перед завершением прыжка (на выходе из гипера);
Примечание: Подставляйте эту переменную с проверкой определённого состояния в условие перед стартом скрипта, если вы хотите, чтобы ваш скрипт стартовал в строго определённое время.


Сектор:
ConName - возвращает имя сектора: 1 - сектор;
StarToCon - возвращает сектор системы: 1 - система;
ConNear - проверяет находятся ли сектора, перечисленные начиная со второго аргумента,
рядом с сектором, указанным в первом аргументе: 1 - целевой сектор, 2, 3, 4... сектора для проверки);
ConStars - возвращает количество систем в секторе: 1 - сектор;
GalaxySectors - возвращает количество секторов в Галактике или конкретный сектор из списка, без аргументов возвращает количество: 1 - номер сектора, возвращает сектор с указанным номером из списка секторов;
SectorVisible - проверяет, есть ли у игрока карты указанного сектора, или открывает его: 1 - сектор, 2 (опционально) - если значение !=0 то открыть сектор, если открывается пиратский сектор, то также восстанавливает ранее скрытые границы;


Система:
StarName - возвращает имя системы: 1 - система (тип данных str);
ConStar - возвращает определённую систему сектора: 1 - сектор, 2 - номер системы в списке систем этого сектора;
GalaxyStars - возвращает общее количество систем в Галактике;
GalaxyStar - возвращает определённую систему: 1 - номер системы в списке систем Галактики (возврат системы по её Id осуществляется этой же функцией при подстановке Id минус 1);
StarAngleBetween - угол, образованный тремя системами;
StarAngle - угол, определяющий направление от одной системы, к другой;
Dist2Star - возвращает реальное расстояние между двумя системами (для получения точных парсек необходимо применить формулу: 'round(sqrt(Dist2Star(star1,star2)))'): 1 - первая система, 2 - вторая система;
StarOwner - возвращает или устанавливает текущего владельца системы: 1 - система, 2 (опционально) - установить нового владельца:
	0 - Коалиция;
	1 - доминаторы;
	2 - пираты;
  Примечание: Для полноценной смены владельца системы вручную, нужно также поменять и владельца всех её населённых планет.
StarCustomFaction - возвращает или устанавливает текущего кастомного владельца системы в виде строки (например 'Klissan'): 1 - система, 2 (опционально) - какое имя фракции установить;
StarBattle - проверяет, идёт ли в системе бой: 1 - система;
StarSeries - возвращает или устанавливает серию доминаторов, владеющую системой (ну или владевшую ранее): 1 - система, 2 (опционально) - серия доминаторов (0 - блазер, 1 - келлер, 2 - террон);
StarNearbyStars - возвращает систему на определённом удалении от исходной: 1 - исходная система, 2 - номер по удалённости для возврата другой системы (на нулевом номере находится сама исходная система);
  Примечание: Очень удобно использовать для перебора ближайших к игроку систем.
StarNearbyStarsDist - то же самое, но возвращает не саму звезду, а расстояние до неё в парсеках;
DistToNearestEnemySystem - возвращает расстояние от системы до ближайшей доминаторской системы: 1 - система;
StarEnemyThreatLevel - возвращает текущий уровень угрозы, нависший над системой:
	1 - система:
	  Уровни угрозы:
	    0 - система под контролем Коалиции или пиратов, угрозы нет;
	    1 - система под контролем Коалиции или пиратов, но в гипере к ней уже направляются доминаторы или кастомная раса;
	    2 - система под контролем Коалиции или пиратов и в ней идёт бой (кого и с кем не имеет значения);
		3 - система находится под контролем доминаторов или кастомной расы (будет всегда возвращать 3, пока систему не отобьют Коалиция или пираты);
StarFonImage - установка фона системы: 1 - ссылка на систему, 2 - номер нового фона (брать из CacheData раздел BGO, указывать только номер);
StarSetGraph – установка новой визуальной оболочки звезды: 1 – звезда, 2 – путь к новой звезде в Main.dat по пути 'Data.SE.Star.__';
  Примечание: Оригинальная графика остаётся прежней, но поверх неё догружается дополнительная анимация (нужно подтверждение).


Планеты:
PlanetToStar - возвращает систему планеты: 1 - планета;
AddPlanetNews - добавляет новость в едином инфоцентре: 1 - текст новости;
PlanetNews – возвращает планетарную новость: 1 – номер планетарной новости;
PlanetNewsDate – возвращает дату планетарной новости: 1 – номер планетарной новости;
PlanetNewsType – возвращает тип планетарной новости: 1 – номер планетарной новости;
PlanetNewsText – возвращает текст планетарной новости: 1 – номер планетарной новости;
GetRelationPlanet - возвращает отношение планеты к кораблю: 1 - планета, 2 - корабль;
PlanetName - возвращает имя планеты: 1 - планета (тип данных str);
IdToPlanet - возвращает планету по её Id: 1 - Id планеты;
PlanetGetGraph - возвращает путь к элементу планеты в игровом Main.dat, применять в связке с функцией GetMainData: 1 - планета;
PlanetSetGraph - по идее может менять фон планеты и принимать значения: 1 - путь к планете, полученный через PlanetGetGraph, 2 - путь к новому фону;
FindPlanet - ищет планету в системе по заданным характеристикам:
	1 - система;
	2 - фильтр расы строкой (можно указывать несколько значений через запятую без пробелов, а если фильтр не нужен, просто оставить пустым ''):
	  'NotMaloc' - не малокская;
	  'NotPeleng' - не пеленгская;
	  'NotPeople' - не человеческая;
	  'NotFei' - не фэянская;
	  'NotGaal' - не гаальская;
	  'NotKling' - не доминаторская;
	  'NotPirateClan' - не пиратская;
	  'NotNone' - не незаселённая;
	3 - первая относительная граница расположения планеты внутри системы, где 0 - центр системы, а 100 - самый её край;
	4 - вторая относительная граница расположения планеты внутри системы;
	  Примечание: При указании третьего и четвёртого аргумента как '0,100', поиск будет выбирать любые существующие в системе планеты, а при указании этих же аргументов как, например, '33,66', будут подбираться лишь планеты со средним удалением от звезды, и т.д.
NearCivilPlanet - возвращает ближайшую к кораблю обитаемую планету в системе, где он находится: 1 - корабль;
StarPlanets - возвращает количество планет в системе, или конкретную планету в ней: 1 - система (вернёт количество), 2 (опционально) - номер планеты в списке планет системы (вернёт планету);
GotoGov - принудительно меняет экран, на экран правительства: без аргумента - проверить установлен ли запрет на покидание правительства, 0 - отпустить игрока: 1 - перевести игрока в правительство, 2 - перевести в правительство и установить запрет на его покидание;
PlanetOwner - возвращает текущую расу-владельца планеты или устанавливает его: 1 - планета, 2 (опционально) - какого владельца назначить:
	0 или 'Maloc' - малоки (Коалиция);
	1 или 'Peleng' - пеленги (Коалиция);
	2 или 'People' - люди (Коалиция);
	3 или 'Fei' - фэяне (Коалиция);
	4 или 'Gaal' - гаальцы (Коалиция);
	5 или 'Kling' - доминаторы (Доминаторы);	  
	6 или 'None' - незаселённая;
	7 или 'PirateClan' - пиратский клан (Пираты);
PlanetRace - возвращает или устанавливает коренную расу планеты:
	1 - планета;
  Опционально:
	2 - какую расу установить;
PlanetGov - возвращает или устанавливает форму правления на планете:
	1 - планета;
  Опционально:
	2 - какую форму правления установить:
	   0 - анархия;
	   1 - диктатура;
	   2 - монархия;
	   3 - республика;
	   4 - демократия (на самом деле это больше политический строй, а не форма правления - добавлен в перечень форм правления по ошибке);
PlanetEco - возвращает или устанавливает тип экономики планеты: 1 - планета, 2 (опционально) - какой тип установить, типы экономики:
	0 - аграрная;
	1 - смешанная;
	2 - индустриальная;
PlanetPirateClan - возвращает Роджерию;
GetShipHomePlanet - возвращает родную (домашнюю) планету корабля: 1 - корабль;
PlanetTerrain – возвращает и устанавливает исследуемые территории незаселённой планеты:
	1 - планета;
	2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
	3 - какую площадь указанной местности установить планете;
PlanetTerrainExplored - возвращает или устанавливает уже исследованные территории незаселённой планеты:
	1 - планета;
	2 - тип местности (0 - вода, 1 - равнины, 2 - горы);
  Опционально:
	3 - какую часть территории указанной местности сделать исследованной;
PlanetOrbitRadius - возвращает или устанавливает радиус орбиты планеты: 1 - планета, 2 (опционально) - новый радиус;
PlanetSize - возвращает или устанавливает размер планеты: 1 – планета, 2 (опционально) - новый размер;
CreatePlanet - создаёт новую планету: 1 - система;
PlanetSetGraph - установка другой оболочки для планеты: 1 - планета, 2 - новая оболочка в Main.dat Data.SE.Planet;
PlanetPopulation - возвращает или устанавливает популяцию планеты: 1 - планета, опционально 2 - какую численность населения установить;
PlanetOrbitalVelocity – устанавливает направление вращения планеты: 1 – планета, 2 – направление вращения: 0 – по часовой стрелке, 1 – против часовой;
PlanetWarriors - возвращает число военных кораблей, приписанных планете (даже если они в данный момент находятся на вылете): 1 - планета, 2 (опционально) - конкретный корабль из списка;
FindPlanetByAdncement - ищет среди систем Коалиции (или другой фракции) планету с определённым уровнем развития (где 100 - самая развитая): 1 - уровень развития числом, 2 (опционально) - среди систем какой фракции искать: 0 - Коалиция, 1 - доминаторы, 2 - пираты;
FindPlanetByAdvancement - возвращает планету по степени её технического развития (может быть полезно, например, для спавна кораблей): 1 - степень развития (от 1 до 100), 2 (опционально) - владелец планеты (PlanetOwner);
PlanetCurInvention - возвращает или устанавливает текущий изучаемый планетой проект: 1 - планета, 2 - тип проекта (числом), 3 (опционально) какой проект установить;
PlanetCurInventionPoints - возвращает или устанавливает уровень исследования текущего проекта планеты: 1 - планета, 2 - тип проекта (числом), 3 (опционально) - какой уровень исследования текущего проекта установить (от 0 до 100);
  Примечание: По достижении 100% изучения текущего проекта, его ТУ на данной планете повышается на единицу, после чего планета выбирает себе новый проект для изучения.
PlanetInventionLevel - возвращает или устанавливает текущий технический уровень определённого проекта планеты: 1 - планета, 2 - тип проекта (числом), 3 (опционально) - какой технический уровень проекта установить (от 1 до 8);
  Типы проектов:
	0 (HullAlloy) - ТУ корпусов;
	1 (FuelTanksType) - ТУ топливных баков;
    2 (EngineSpeed) - ТУ двигателей;
	3 (RadarRadius) - ТУ радаров;
    4 (ScanerType) - ТУ сканеров;
	5 (RepairRobotType) - ТУ дроидов;
    6 (CargoHookType) - ТУ захватов;
	7 (TechLevel) - общий ТУ планеты, влияющий на ГТУ и на доступность изучения различных типов орудий (для начала изучения той или иной пушки, ТУ планеты должен быть сперва приравнен к ТУ этой пушки);
    8 (Weapon1) - ТУ промышленного лазера;
	9 (Weapon2) - ТУ осколочного орудия;
	10 (Weapon3) - ТУ лезки;
	11 (Weapon4) - ТУ ракетомёта;
	12 (Weapon5) - ТУ третона;
	13 (Weapon6) - ТУ волнового фазера;
	14 (Weapon7) - ТУ потокового бластера;
	15 (Weapon8) - ТУ электронного резака;
	16 (Weapon9) - ТУ мультирезонатора;
	17 (Weapon10) - ТУ атомного визиона;
	18 (Weapon11) - ТУ дезинтегратора;
	19 (Weapon12) - ТУ турбогравира;
PlanetBoostInventions - разово увеличивает скорость развития проектов на планете: 1 - планета, 2 - сколько дневных норм исследования проектов накинуть;
  Примечание: Каждый день планета получает определённое количество очков к исследованию своего проекта. При захвате системы доминаторами, у планеты появляется 30% шанс не получить очков исследований за текущий день, а при захвате системы пиратами этот же шанс составляет 15%. Функция PlanetBoostInventions позволяет условно промотать время исследований на N дней вперёд, но при этом градация получения очков исследования за день для планеты не изменится.


Станции:
StarRuins - возвращает количество баз в системе, либо конкретную базу из этого списка, либо количество баз определённого типа: 1 - система (вернёт количество), 2 (опционально) - если число, то вернёт базу с указанным номером из списка, а если строка, то вернёт базу указанного типа;
  Оригинальные типы баз:
	'RC' - ЦР;
	'WB' - ВБ;
	'SB' - НБ;
	'BK' - БЦ;
	'MC' - МЦ;
	'PB' - ПБ;
	'CB' - доминион;
	  Примечание: Аналогично может сделать возврат кастомной станции с кастомным строковым типом, однако цель обязательно должна быть станцией, а не кораблём.
RuinsChangeType - изменяет основной тип базы: 1 - база, 2 - новый тип базы (числом или строкой);
  Примечание: Данная функция позволяет сменить не строковый, но основной числовой тип базы, например t_RC на t_CB. Допускается указывать новый тип не числом, а строкой вида 'CB', 'RC' и т.д. в пределах восьми основных типов станций.
BuildRuins - создать базу (возвращает созданную): 1 - система, 2 - тип базы:
  t_RC (6) - центр рейнджеров;
  t_PB (7) - пиратская база;
  t_WB (8) - военная база;
  t_SB (9) - научная база;
  t_BK (10) - бизнес-центр;
  t_MC (11) - медицинский центр;
  t_CB (12) - доминион;
BuildCustomRuins - создать кастомную базу (возвращает созданную): 1 - система, 2 - кастомный тип строкой, 3 - чьей считать данную базу (тип Standing):
  Типы Standing:
	0 - tst_Kling - (доминатор) считается доминатором без серии, а потому всеми другими доминаторами (и вообще всеми) воспринимается враждебно;
	1 - tst_None - (ничейная) полностью безразлична к происходящему в системе, аналогична транклюкатору без хозяина;
	2 - tst_CoalMilitary - (военные) аналогично ВБ, ЦР и военным кораблям (может захватывать системы для Коалиции);
	3 - tst_CoalActive - (военные-нейтралы) почти тоже, что и простые военные, но с пиратами отношение ещё лучше, аналогична НБ и БЦ (может захватывать системы для Коалиции);
	4 - tst_CoalPassive - (гражданские) аналогично транспортам в пиратских системах, не вызывает агрессии пиратов, пока не начнёт атаковать сама;
	5 - tst_Neutral - (нейтралы) соответствует МЦ, перепрограммированному Блазеру и кораблям в тюрьме, игнорирует коалиционные и пиратские тёрки, но к доминаторам враждебна;
	6 - tst_PiratePassive - (вольные пираты) соответствует обычным ПБ и простым пиратам, терпимо относящимся к Коалиции;
	7 - tst_PirateActive - (пираты-нападающие) соответствует атакующим пиратам (может захватывать системы для клана);
	8 - tst_PirateMilitary - (пираты-военные) соответствует пиратским доминионам и запрещает посадку коалиционных кораблей;
	9 - tst_Custom - будет враждебна всему, что не имеет той же кастомной фракции и абсолютно всему, если кастомная фракция у станции не установлена;
  Примечание: Добавление кастомной (t_UB) станции в кастомную фракцию (функция ShipCustomFaction) автоматически переведёт её в категорию tst_Custom, которая сохранится, даже если впоследствии кастомная фракция будет снята. Данное ограничение не распространяется на станции с оригинальными типами (t_SB, t_PB и т.д.).


Корабль (также данные функции работают для станций):
ShipStar - возвращает систему, в которой находится корабль:
	1 - корабль;
GetOwner - возвращает расу корабля:
	1 - корабль;
GiveReward - выдаёт кораблю случайную медаль по её типу;
	1 - корабль;
	2 - кем выдана (раса);
	3 - тип медали числом;
CountReward - возвращает общее количество медалей корабля или количество медалей определённого типа:
	1 - корабль;
  Опционально:
	2 - тип медали числом (за что выдана);
	  Типы медалей:
	    0 (ForLiberationSystem) - за освобождение системы или за победу над боссами (просто потому что);
	    1 (ForAccomplishment) - за выполнение задания, освобождение системы или за победу над боссами;
	    2 (ForSecretMission) - за выполнение задания;
	    3 (ForCowardice) - за провал задания;
	    4 (ForPerfidy) - различные позорные метки;
	    5 (ForPlanetBattle) - за победу в планетарном бою;
CountRewardByNom - возвращает общее количество медалей корабля или количество медалей под определённым номером в Lang: 1 - корабль, 2 (опционально) - номер медали в Lang;
GiveRewardByNom - выдаёт кораблю определённую медаль по её номеру в Lang: 1 - корабль, 2 - номер медали;
DeleteRewardByNom - удаляет у корабля определённую медаль по её номеру в Lang и возвращает число удалённых медалей: 1 - корабль, 2 - номер медали, 3 (опционально) - сколько медалей с данным номером удалить (по умолчанию удалит 1);
DropItem - заставляет корабль выбросить рандомный предмет по типу: 1 - корабль, 2 - тип предмета, 3 (опционально) - (0 - из трюма, 1 - экипированное), 4 - скриптовый объект в который будет занесён выброшенный предмет (функция, на мой взгляд, спорная, лучше использовать более предсказуемые аналоги);
DeleteEquipment - удаляет оборудование с корабля: 1 - корабль, 2 - тип предмета;
ShipTypeN - возвращает основной числовой тип корабля (можно подставлять переменные типа t_Pirate, t_PB): 1 - корабль;
	0 (t_Kling) - доминатор;
	1 (t_Ranger) - рейнджер;
	2 (t_Transport) - гражданский (не только транспорт);
	3 (t_Pirate) - пират (в т.ч. и клановый);
	4 (t_Warrior) - военный;
	5 (t_Tranclucator) - транклюкатор;
	6 (t_RC) - центр рейнджеров;
	7 (t_PB) - пиратская база;
	8 (t_WB) - военная база;
	9 (t_SB) - научная база;
	10 (t_BK) - бизнес-центр;
	11 (t_MC) - медицинский центр;
	12 (t_CB) - доминион;
	13 (t_UB) - кастомная база (создаётся функцией BuildCustomRuins);
  Примечание: Числовые типы кораблей являются оригинальными основными типами для большого количества кастомных типов судов. Они не поддерживают добавления кастомных типов и служат сугубо внутренним игровым функциям. Определять по ним корабли можно лишь в очень широких диапазонах. Для более точного определения типа корабля, используйте кастомные строчные типы и функцию ShipType.
ShipType - возвращает строковое имя типа корабля (дипломат, рейнджер, доминатор и т.д.): 1 - корабль, 2 (опционально) – сменить имя типа корабля на другое:
  Оригинальные имена типов (модами можно добавить свои):
	'Ranger' - рейнджер;
	'FemRanger' - спецагентка;
	'Pirate' - пират;
	'Transport' - транспорт;
	'Liner' - лайнер;
	'Diplomat' - дипломат;
	'Warrior' - военный;
	'WarriorBig' - флагман;
	'Tranclucator' - робот;
	'Kling' - доминатор;
	'Ruins' - станция;
  Оригинальные типы станций:
	'RC' - центр рейнджеров;
	'RCSmall' - ЦР;
	'SB' - научная база;
	'SBSmall' - НБ;
	'WB' - военная база;
	'WBSmall' - ВБ;
	'MC' - медицинский центр;
	'MCSmall' - МЦ;
	'BK' - бизнес-центр;
	'BKSmall' - БЦ;
	'PB' - пиратская база;
	'PBSmall' - ПБ;
	'CB' - доминион;
	'CBSmall' - ДМ;
	  Примечание: Типы станций с приставкой Small используются в некоторых окнах для подстановки сокращённых названий (например, при улучшении станции игроком). Проверять станции на такие типы в скрипте не нужно, они используются только в Lang для указания сокращённого имени.
  Кастомные типы кораблей:
	'Militiaman1' - ополченец, первый тип (ExpPilotBridge);
	'Militiaman2' - ополченец, второй тип (ExpPilotBridge);
	'Militiaman3' - ополченец, третий тип (ExpPilotBridge);
	'Rebel' - повстанцы (ExpPilotBridge и ShuRebellion);
	'PirateRunner' - пират-загонщик (ExpPilotBridge);
	'AbandonedShip' - покинутый корабль, остающийся после запуска спасательной шлюпки (фактически лайнер, ExpTC);
	'RangerPirate' - рейнджер изменник (ExpTraitors);
	'RangerPiratePlayer' - тип игрока, когда он переходит на сторону пиратов (ExpTraitors);
	'RangerExplorer' - рейнджер с фиксированным именем характера "Исследователь" (ExpExplorers);
	'RangerPirateExplorer' - рейнджер-изменник с фиксированным именем характера "Авантюрист" (ExpExplorers);
	'Smuggler' - рядовой контрабандист (ShuSmugglers), а также тип одного скриптового контрабандиста для события получения доступа к ЧР (ExpBlackMarket);
	'EliteWarrior' - элитный военный с акриновым корпусом (ShuWarriors);
	'Merc' - наёмник (ShuMercs);
	'Freelancer' - фрилансер (ShuMercs);
	'RedLeader' - варлорд Бордюрг Ебрын (ShuMercs);
	'AtlantLeader' - лидер Кайло Норт (ShuMercs);
	'FeiLeader' - гендир Элайма Фэй (ShuMercs);
	'DomTrank' - доминаторский транклюкатор (ShuDomiks);
	'Superdominator' - супердоминатор (ShuDomiks);
	'DomRuins' - верфь, а точнее эквентор, имитирующий станцию (ShuDomiks);
	'KellerClone' - клон Келлера (ShuDomiks);
	'Dreadnought' - дредноут (ShuMiniBoss);
	'Han' - хан (ShuMiniBoss);
	'Headhunter' - головорез (ShuMiniBoss);
	'Pillager' - пиратская баржа (ShuMiniBoss);
	'Superdominator' - супердоминатор (ShuMiniBoss);
	'Klissan' - клисанский корабль, когда он пират? (ShuKlissan);
	'Klissan1' - клисан эгемон (ShuKlissan);
	'Klissan2' - клисан нондус (ShuKlissan);
	'Klissan3' - клисан катаури (ShuKlissan);
	'Klissan4' - клисан рогит (ShuKlissan);
	'Klissan5' - клисан мутенок (ShuKlissan);
	'None' - неизвестный корабль (ShuKlissan);
	'Badass' - изменник (ShuKlissan);
  Кастомные типы станций:
	'TC' - технологический центр (номерной тип 13 - кастомка, ExpTC);
	'TCSmall' - ТЦ;
	'SSB' - подпространственная база (номерной тип 11 - МЦ, ExpSSB);
	'SSBSmall' - ППБ;
	'BM' - чёрный рынок (номерной тип 7 - ПБ, ExpBlackMarket);
	'BMSmall' - ЧР;
	'MB' - центр наёмников (номерной тип 13 - кастомка, ShuMercs);
	'MBSmall' - ЦН;
	'Manaan' - свободный порт, а точнее центр наёмников после уничтожения всех главарей наёмников (номерной тип 13 - кастомка, ShuMercs);
	'ManaanSmall' - СП;
	'Inhibitor' - ингибитор (номерной тип 13 - кастомка, ShuDomiks);
	'InhibitorSmall' - Ингибитор;
	'KB' - нейролинк (номерной тип 13 - кастомка, ShuKlissan);
	'KBSmall' - НЛ;
	'Handler' - секретный объект Хандлер (номерной тип 13 - кастомка, ShuKlissan);
	'HandlerSmall' - СО;
	'Machpella' - Махпелла (номерной тип 13 - кастомка, ShuKlissan);
	'MachpellaSmall' - '';
ShipSubType - возвращает или устанавливает имя подтипа корабля:
	1 - корабль (вернёт текущий подтип);
  Оционально:
	2 - задать подтип (не проверял, работает ли второй аргумент):
	  Доминаторы:
		0 - босс (Блазер, Келлер или Террон);
		1 - эквентор;
		2 - ургант;
		3 - смерш;
		4 - менок;
		5 - штип;
		6 - бертор;
		7 - клиг;
	  Гражданские корабли (ShipTypeN = 2):
		0 - транспорт;
		1 - лайнер;
		2 - дипломат;
	  Военные:
		0 - обычный;
		1 - флагман;
	  Пираты:
		0 - вольный пират (не из клана);
		1, 2, 3 - виды клановых пиратов, отличающихся только предпочтениями в эквипе (для разнообразия);
ShipCustomFaction - возвращает или устанавливает кастомную фракцию для корабля:
	1 - корабль;
  Опционально:
	2 - имя кастомной фракции строкой;
  Примечание: Если имя кастомной фракции начинается с 'SubFaction' (например, 'SubFactionKlissan'), то корабли с такой фракцией не станут по умолчанию враждебными всем окружающим, но сохранят свою стандартную логику поведения. Также наличие обязательной скриптовой группы для кораблей с кастомной фракцией не обеспечивает им защиту от астероидов.
IdToShip - возвращает корабль по его Id: 1 - Id корабля;
ShipName - возвращает не полное (для возврата полного используйте Name) имя корабля: 1 - корабль (пример - из "Лякуша Лошарик" вернёт "Лошарик");
ShipPilotRace - возвращает/устанавливает расу пилота корабля: 1 - корабль, 2 (опционально) - на какую установить;
	0 - малоки;
	1 - пеленги;
	2 - люди;
	3 - феяне;
	4 - гаальцы;
ShipCanJump - проверяет, может ли корабль совершить прыжок (по умолчанию проверяет только по дальности двигателя) из одной системы в другую(ие) систему(ы): 1 - корабль, 2 - система откуда прыгать, 3, 4, 5 и т.д. - следующие системы которые нужно проверить на возможность прыжка (фактически, проверяется маршрут), минимум одна система (3) должна быть указана, далее количество систем для проверки не ограничено. Помимо системы, следующим аргументом в очереди можно указать маркер 1, чтобы функция проверила возможность прыжка не только по двигателю, но и по топливу для всего выстроенного маршрута;
ShipInStar - проверяет не находится ли корабль в определённой системе: 1 - корабль, 2 - система;
ShipInPlanet - проверяет не находится ли корабль на планете: 1 - корабль, 2 - планета;
ShipFind - ищет в системе, в которой находится игрок, корабль определённого типа: 1 - тип корабля;
ShipDestroy - уничтожает определённый корабль или принудительно отменяет его уничтожение: 1 - корабль, 2 (опционально) - уничтожить/отменить уничтожение (1 или 0);
Player - без аргументов, возвращает корабль игрока;
CountTurn - возвращает количество ходов, которое потребуется кораблю, чтобы достигнуть определённого объекта: 1 - корабль, 2 - объект (возможные типы объектов: скриптовое место, планета, корабль/станция);
ShipTurnBeforeEndOrder - аналог CountTurn, но без второго аргумента, просто считает сколько будет выполняться текущий приказ;
ShipGetBad - возвращает текущий объект враждебности корабля: 1 - корабль (проверять враждебность только по отношению Relation для игрока некорректно, т.к. даже при враждебном поведении отношение корабля может быть выше 10);
ShipSetBad - назначить кораблю/станции текущего врага:
	1 - корабль;
	2 - враг (другой корабль или станция);
ShipInGameEvent - проверяет не участвует ли ВБ или военный корабль в операции по освобождению системы: 1 - корабль или база;
ShipInNormalSpace - проверяет, что корабль в обычном космосе (не в гиперпространстве, не в АБ, не на планете и т.д.): 1 - корабль;
ShipInHole - проверяет не находится ли корабль в ЧД: 1 - корабль;
  Примечание: Фактически представляет собой две последовательные проверки: ShipInHyperSpace(ship) и ShipOrder(ship)==4 (приказ на прыжок в ЧД), так что может возвращать 'True' параллельно с функцией ShipInHyperSpace.
ShipIsTakeoff - проверяет не взлетает ли корабль с планеты/станции: 1 - корабль;
StarShips - возвращает количество кораблей в системе (но иногда не учитывает военные корабли на планетах), или конкретный корабль в ней: 1 - система (вернёт количество), 2 (опционально) - номер корабля в списке кораблей системы (вернёт корабль);
GetShipPlanet - возвращает планету, на которой находится корабль: 1 - корабль (если корабль не на планете вернёт 0);
GetShipRuins - возвращает базу, на которой находится корабль: 1 - корабль, вернёт 0 (если корабль не на станции вернёт 0);
  Примечание: Если игрок находится на экране мостика, для возврата планеты или станции, на которой возможно сидит его корабль, необходимо применить функцию возврата станции повторно, пример: GetShipRuins(GetShipRuins(Player())) или GetShipPlanet(GetShipRuins(Player())).
GetTalkShip - во время разговора в космосе вернёт корабль собеседника;
ShipInHyperSpace - проверяет не находится ли корабль в гиперпространстве: 1 - корабль;
OrderJump - заставляет корабль совершить прыжок в другую систему игнорируя возможности двигателя и бака: 1 - корабль, 2 - система назначения, 3 (опционально) - степень важности приказа (нескриптовые корабли всё равно могут проигнорить, но по ерунде отвлекаться не будут);
ShipDestination - переносит корабль в другую систему при взлёте со станции (выставлять только пока корабль находится на станции), функция, воссоздающая портальный прыжок с пиратских доминионов: 1 - корабль (с одним аргументом вернёт текущую систему назначения), 2 (опционально) - установить систему назначения (пропуск хода станет невозможен);
OrderLanding - заставляет корабль приземлиться: 1 - корабль, 2 - объект для посадки (планета или станция), 3 (опционально) - степень важности приказа;
OrderTakeOff - отдать кораблю приказ на взлёт: 1 - корабль;
OrderLock - блокировать/разблокировать возможность отдавать любые приказы (кроме скриптовых) для конкретного корабля: 1 - корабль, 2 (опционально) - блокировать/разблокировать отдачу приказов: 1/0 (также активация этого лока позволяет игнорировать обнуления приказов от стейткода и может быть полезна, если вам, к примеру, нужно вручную переместить корабль или станцию, находящуюся в стейте с типом перемещения None);
OrderNone - отменяет текущий приказ и боевые цели корабля: 1 - корабль;
OrderMove - приказ кораблю двигаться к указанным координатам: 1 - корабль, 2 - X координата, 3 - Y координата;
OrderTeleport - приказ кораблю/станции телепортироваться в указанную систему в указанные координаты:
	1 - корабль или станция;
	2 - целевая система;
	3 - X координата в целевой системе;
	4 - Y координата в целевой системе;
  Опционально:
	5 - важность приказа (в данном случае бесполезно);
	6 - длительность нахождения корабля/станции в гипере в днях (допустимо выставлять 0 для мгновенного переноса);
OrderFollowShip - приказ кораблю следовать за другим кораблём: 1 - корабль, 2 - целевой корабль, 3 - тип следования: простое следование (0) или выход на дистанцию выстрела (1), 4 (опционально) - важность приказа;
OrderJumpHole - приказ кораблю залететь в ЧД: 1 - корабль, 2 - ЧД, 3 - приоритет приказа;
ShipOrder - возвращает или устанавливает действие для корабля:
	1 - корабль;
	2 (опционально) - какое действие назначить:
	   -1 - автобой (только для игрока);
		0 - без приказа;
		1 - движение;
		2 - посадка;
		3 - прыжок;
		4 - прыжок в ЧД;
		5 - взлёт;
		6 - следование (обычное, либо приближение на расстояние выстрела);
		7 - телепортация;
ShipOrderData1 - первая половина переменной, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка: 1 - корабль, 2 (опционально) - задать новую длительность;
  Примечание: Если у корабля установлен приказ "следование", то у ShipOrderData1 будут три значения: 0 - t_FollowNear (простое следование), 1 - t_FollowMin (на расстоянии выстрела), 2 - t_FollowMax (на расстоянии выстрела самой дальнобойной пушки (по умолчанию в игре не используется));
ShipOrderData2 - вторая половина переменной, хранящая в себе длительность прыжка/телепорта/ЧД-прыжка: 1 - корабль, 2 (опционально) - задать новую длительность;
  Примечание: Общая длительность прыжка хранится в переменной типа dword и определяется по следующей формуле: ShipOrderData1*ShipOrderData2. При этом максимально допустимое значение длительности будет достигнуто, если одновременно установить кораблю ShipOrderData1(Ship,65535) и ShipOrderData2(Ship,65535). При установлении длительности прыжка в функции самого приказа (например, OrderTeleport), переданное значение длительности будет разбито по двум ShipOrderData автоматически, что необходимо учитывать, если в дальнейшем вы захотите изменить длительность данными функциями.
ShipOrderObj - возвращает или изменяет объект действия текущего приказа корабля (если корабль ведёт автобой, то объектом будет его цель, если совершает прыжок, то целевая система и т.д.): 1 - корабль, 2 (опционально) - на какой объект заменить объект действия корабля;
MakeShipEnterStar - форсирует вход корабля в систему, как будто он совершил полноценный прыжок:
	1 - корабль;
	2 - система в которую нужно совершить прыжок;
	3 - система из которой совершается прыжок (определяет точку выхода из гипера);
	4 - время нахождения корабля в гипере перед выходом;
AutoBattle - функция активации автобоя для игрока: 1 - корабль с которым игрок должен вести автобой или 0 - отмена автобоя (допустимо вести автобой с самим собой);
ShipAddDropItem - заставить корабль дропнуть некоторый предмет при гибели (в трюме предмет не отображается, место не занимает): 1 - корабль, 2 - предмет;
ChanceToWin - возвращает (в виде int от 0 до 100) шанс победы одного корабля над другим: 1 - один корабль, 2 - другой корабль, 3 - опциональный флаг (любое число выше 0), чтобы функция вернула расчёт не в процентах, а в оригинальном виде с типом float, где все значения от 4 целых и выше уже будут считаться игрой 100% шансом на победу;
	Примечание: Клиги будут таранить игрока только при получении ChanceToWin < 0.2, а иначе будут просто атаковать его как обычные корабли.
IsChameleon - проверяет, применён ли хамелеон (не камуфляж, а именно "хамелеон", то есть визуальная смена внешнего вида корпуса) к кораблю в настоящий момент: 1 - корабль;
Chameleon - меняет визуальный облик кораблю:
	1 - корабль или база (если это единственный аргумент, то сбрасывает шкурку на базовый вид для текущего корпуса или акрина);
  Опциональные:
	2 - путь в main.dat/Data/SE к нужной шкурке (например, строка вида 'Ship.Gaal.Transport' поменяет шкурку на гаальский транспорт) или строка 'GraphName' для возврата полного пути к уже установленной на корабле шкурке;
	3 - если значение больше 0, то выполнится автоматический перезаход на форму StarMap для моментальной визуальной смены шкурки корпуса. Имеет смысл применять данный маркер только если игрок находится на форме StarMap и имеет прямой визуальный контакт на корабль, меняющий шкурку. Во всех остальных случаях просто игнорируйте этот аргумент.
  Примечание: Если вы повесили на корпус корабля акрин и хотите автоматически обновить его облик, команды Chameleon(ship) для этого вполне достаточно.
PlayerChameleonCharges - проверяет или устанавливает количество доступных активаций камуфляжа у игрока: 1 - серия, 2 (опционально) - сколько активаций задать;
PlayerChameleonDetected - проверяет, устанавливает и снимает детект доминаторами камуфляжа игрока: 1 - серия камуфляжа, 2 (опционально) включить/отключить детект;
PlayerChameleonCurType - возвращает или устанавливает номер доминаторского камуфляжа на корабле игрока, без аргумента - возвращает номер камуфляжа:
   Аргументы:
   -1 - снять камуфляж;
	0 - блазер;
	1 - келлер;
	2 - террон;
  Примечание: Сама по себе данная функция "хамелеон" не накладывает, а просто устанавливает игроку режим камуфляжа. То есть без дополнительной команды внешний вид игрока не изменится, но доминаторы будут считать его за своего.
PlayerLogicChameleon - особая скриптовая маскировка, позволяющая активировать функцию, аналогичную игровому камуфляжу, но с новыми дополнительными возможностями (внешний вид корабля доминатора не накладывается, а дружественные корабли не считают игрока доминатором):
	1 аргумент - серия доминаторов: 0 - блазер, 1 - келлер, 2 - террон (обязательный);
	2 аргумент - статус (опциональный, стандартная схема получения/выставления);
  Статусы:
	0 - всё как обычно;
	1 - доминаторы не атакуют, пока не заметят обман (PlayerChameleonDetected, если он уже стоит, то скрипт должен почистить сам), общий флаг и правила с обычным камуфляжем;
	2 - доминаторы не атакуют совсем, игрок не может на них нападать;
  Примечание: Запреты в обе стороны не включаются, если бой уже идет (по ShipBad, опять же чистит скрипт, когда надо), т.е. игрок в любом случае может защищаться. Диалоги с кораблями не меняются (кроме, возможно, вариаций диалогов домиков при обнаружении/без него). Боссы в состоянии 2 или 1 без детекта не запускают скриптовый диалог, а выдают камуфляжную реплику (как и при обычном камуфляже), которую можно перебить оверрайдом.
ShipChangeStar - меняет систему к которой приписан корабль в данный момент, в основном для игрока она нужна, чтобы, например, перенаправить его в другое место, когда он через ЧД прыгает (evilcoward): 1 - корабль, 2 - система;
ShipRefit - обновляет оборудование на корабле (заставляет корабль провести реинвентаризацию из своего источника/магазина), если он находится на планете или станции (иначе не сделает ничего):
	1 - корабль;
  Опционально:
	2 - минимальный размер корпуса, который нужно установить кораблю (автоматически поднимет и число HP);
	3 - минимальная сумма денег, которую нужно установить кораблю;
ShipStatusEffect - проверяет и изменяет мощность эффектов, наложенных на корабль в текущий момент (0 - эффекта нет):
	1 - корабль;
	2 - тип эффекта:
	  0 (steShock) - эффект ионизации;
	  1 (steAcid) - эффект ослабления брони (коррозия);
	  2 (steMagnetic) - эффект ЭМ-помех;
	  3 (steWeaponBlock) - эффект блокировки орудий;
	  4 (steDroidBlock) - эффект блокировки дроида;
	  5 (steBWBuff) - эффект усиления от флагмана;
	  6 (steBWRepairDebuff) - эффект ослабления последовательных ремонтов от флагмана (если корабль чиниться от флагмана, либо сам флагман применяет на себя особый ремонт, с каждым разом эффективность ремонта будет становиться всё слабее и слабее);
  Опционально:
	3 - на какое значение изменить мощность эффекта, также напрямую влияющую на продолжительность этого эффекта (суммируется с уже существующим значением, может быть отрицательным);
	4 - корабль/станция, которая будет считаться наложившей эффект (будет применено, только если мощность эффекта была увеличена);


Группа кораблей:
SetRelationGroup - устанавливает отношение скриптовой группы кораблей к скриптовой группе кораблей рейнджеров:
	1 - группа кораблей, которым задаём отношение;
	2 - группа рейнджеров;
	3 - какой уровень отношения установить (0-4);
SetRelationPlanet - устанавливает отношение планеты к скриптовой группе кораблей рейнджеров:
	1 - группа рейнджеров;
	2 - планета;
	3 - какой уровень отношения установить (0-4);
	  Уровни отношения:
	    0 (ReWar) - враждебное отношение, фактическое значение 5;
	    1 (ReBad) - плохое отношение, фактическое значение 20;
	    2 (ReNormal) - нормальное отношение, фактическое значение 45;
	    3 (ReGood) - хорошее отношение, фактическое значение 70;
	    4 (ReBest) - отличное отношение, фактическое значение 90;
ShipGroup - возвращает скриптовую группу корабля: 1 - корабль;
GroupToShip - возвращает первый корабль в выбранной группе текущего скрипта: 1 - название группы;
GroupCount - считает количество кораблей в определённой скриптовой группе: 1 - название группы;
GroupShip - возвращает конкретный корабль из скриптовой группы: 1 - название группы, 2 - номер корабля в скриптовой группе;
GroupIn - проверяет не находится ли скриптовая группа в определённом месте (необходимо присутствие там всех кораблей группы): 1 - название группы, 2 - место, возможные типы мест:
	- Конкретная система;
	- Конкретная планета;
	- Конкретное скриптовое место;
CountIn - количество кораблей группы в определённом месте;
NearestGroup - проверяет какая из перечисленных скриптовых групп ближе к определённому кораблю: 1 - корабль, 2 - минимальная дистанция для проверки, 3, 4, 5 и т.д. - номера групп для проверки;
GroupSetBad - назначить всем кораблям группы текущего врага: 1 - название группы, 2 - корабль врага;
GroupIs - проверяет не является ли группа корабля указанной(ыми) группой(ами): 1 - корабль, 2, 3, 4 и т.д - названия групп для проверки;


Создание кораблей:
BuyPirate - создаёт пирата: 1 - планета для спавна корабля, 2 (опционально) - множитель стартового капитала (в процентах);
BuyTransport - создаёт гражданское судно: 1 - планета для спавна корабля, 2 (опционально) - тип гражданского (0 - транспорт, 1 - лайнер, 2 - дипломат), 3 (опционально) - множитель стартового капитала (в процентах);
GalaxyShipId - Id, которое будет присвоено следующему родившемуся кораблю;
BuyRanger - спавнит рейнджера: 1 - планета для спавна, 2 (опционально) - множитель стартового капитала (в процентах);
BuyWarrior - спавнит военный корабль или кланового пирата-защитника (зависит от овнера планеты): 1 - планета для спавна, 2 (опционально) - множитель стартового капитала (в процентах);
BuyBigWarrior - спавнит флагман: 1 - планета для спавна, 2 (опционально) - множитель стартового капитала (в процентах);
BuyDomik – спавнит доминатора, устаревший алгоритм: 1 - планета для спавна;
BuyDomikExtremal - спавнит доминатора, стандартный алгоритм: 1 - планета для спавна, 2 (опционально) подтип ShipSubType доминатора;
BuyTranclucator - спавнит транклюкатора: 1 - планета для спавна, 2 (опционально) - сила транклюкатора;
TransferShip - перемещает (не телепортирует, а просто переносит) корабль на заданный объект: 1 - корабль, 2 - объект, куда переместить корабль, возможные типы объектов: система (появится в новой системе по своим текущим координатам), планета, база;


Игрок и другие рейнджеры и объекты:
StatusPlayer - возвращает статус игрока: 1 - торговец, 0 - воин, -1 - пират;
ShipStrengthInBestRanger - возвращает относительную силу корабля по сравнению с лучшим рейнджером: 1 - корабль;
ShipStrengthInAverageRanger - возвращает относительную силу корабля по сравнению со средним рейнджером: 1 - корабль;
RangerStatus - возвращает статус рейнджера: 1 - корабль;
IsPlayer - проверяет, не является ли корабль игроком (аналогично можно проверить как if(ship==Player())): 1 - корабль;
ShipJoinsClan - корабль вступает в пиратский клан: 1 - корабль;
ShipInPirateClan - проверяет, состоит ли корабль в пиратском клане, а для игрока - вступал ли он в клан в этой партии вообще: 1 - корабль;
ShipOnSidePirateClan - проверяет, состоит ли корабль в пиратском клане в настоящий момент (также можно проверить через ShipOwner(ship)==7): 1 – корабль;
ShipRank - возвращает текущее военное звание корабля числом (от 0 до 7):
	1 - корабль;
	  Звания:
	   0 - новичок;
	   1 - кадет;
	   2 - пилот;
	   3 - капитан;
	   4 - истребитель;
	   5 - лётчик;
	   6 - командор;
	   7 - адмирал;
GetShipPirateRank - возвращает текущее пиратское звание корабля числом (от 0 до 7):
	1 - корабль;
	  Звания:
	   0 - салага;
	   1 - юнга;
	   2 - рейдер;
	   3 - шкипер;
	   4 - головорез;
	   5 - атаман;
	   6 - хан;
	   7 - барон;
ShipRankPoints - возвращает или устанавливает текущее количество очков коалиционного (военного) рейтинга: 1 - корабль, 2 (опционально) – какое количество очков установить;
ShipNextRankPoints - возвращает количество очков коалиционного рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько ему нужно всего): 1 - корабль;
ShipPirateRankPoints - возвращает или устанавливает текущее количество очков пиратского рейтинга: 1 - корабль, 2 (опционально) – какое количество очков установить;
ShipNextPirateRankPoints - возвращает количество очков пиратского рейтинга, необходимое для получения следующего звания (не сколько осталось кораблю, а сколько нужно всего): 1 - корабль;
ShipRaiseRank - увеличивает коалиционное звание корабля на 1 (сработает только если у корабля хватает очков): 1 - корабль;
RaisePirateRank - увеличивает пиратское звание корабля на 1 (сработает только если у корабля хватает очков): 1 - корабль;
ShipSkill - возвращает или устанавливает значение определённого навыка корабля: 1 - корабль, 2 - номер навыка, 3 (опционально) - какое значение навыка установить:
  Навыки для подстановки вторым аргументом:
	'Accuracy' (0) - точность;
	'Mobility' (1) - манёвренность;
	'Technical' (2) - техника;
	'Trader' (3) - торговля;
	'Charm' (4) - обаяние;
	'Leadership' (5) - лидерство;
  Только для запроса значения:
	'AccuracyCur' - точность с учётом всех бонусов/штрафов;
	'MobilityCur' - манёвренность с учётом всех бонусов/штрафов;
	'TechnicalCur' - техника с учётом всех бонусов/штрафов;
	'TraderCur' - торговля с учётом всех бонусов/штрафов;
	'CharmCur' - обаяние с учётом всех бонусов/штрафов;
	'LeadershipCur' - лидерство с учётом всех бонусов/штрафов;
  Примечание: Обратите внимание, что запрос числом работает только для получения бонусов реального навыка игрока, без учёта бонусов и штрафов.
ShipFace - возвращает или устанавливает кораблю портрет: 1 - корабль, 2 (опционально) - номер портрета в списке;
ShipFreeExp - возвращает или устанавливает количество нераспределённого опыта корабля: 1 - корабль, 2 (опционально) - какое количество установить;
GetShipExpByType - возвращает количество заработанного опыта определённого типа: 1 - корабль, 2 - тип опыта, типы: 0 - сумма всех типов (вообще всех, а не тех, что опционально), 1 - убийство доминаторов, 2 - убийство пиратов, 3 - прочие убийства, 4 - торговля;
ShipStatus - возвращает или устанавливает статус рейнджера (от 0 до 100):
	1 - корабль
	2 - тип статуса
  Опционально:
	3 - задать статус (от 0 до 100) типы статусов:
	  0 - торговец;
	  1 - пират;
	  2 - воин;
RelationToRanger - возвращает отношение объекта к рейнджеру или устанавливает его:
  Обязательно:
	1 - объект (корабль, станция или планета);
	2 - корабль рейнджера;
  Опционально:
	3 - какое отношение установить (от 0 до 100):
	  80-100 - отличное;
	  60-79 - хорошее;
	  30-59 - нормальное;
	  10-29 - плохое;
	  0-9 - враждебное;
  Примечание: Военные корабли не имеют своего собственного отношения к кораблям, так что выставлять им его бесполезно. Их отношение к кораблю наследуется от их родной планеты. Также не имеют своего отношения и все пиратские планеты (вернее имеют, но не используют до освобождения от пиратов), а потому наследуют его от Роджерии (для смены отношения всех пиратских планет, отношение нужно менять у Роджерии).
ConChangeRelationToRanger - меняет отношение к рейнджеру на всех планетах указанного сектора: 1 - сектор, 2 - корабль, 3 - на сколько изменить (+20,-45 и т.д.);
  Примечание: Изменение отношения сработает только для коалиционных планет (если только не применить эту функцию для Тортугаца/Нифигаца), поскольку пиратские планеты наследуют отношение от Роджерии. Имейте в виду, что изменение отношения для пиратских планет все равно сработает, но увидеть это изменение игрок сможет только после их освобождения от пиратов.
GalaxyRangers - возвращает количество рейнджеров в Галактике, или конкретного рейнджера с указанным номером из этого списка, без аргументов возвращает количество: 1 (опционально) - номер в списке рейнджеров (возвращает конкретный корабль);
ExtremalTakeOff - форсировать взлёт корабля игрока (запустит следующий ход);
TruceBetweenShips - корабли мирятся: 1 - первый корабль, 2 - второй корабль;
ShipSetPartner - назначает кораблю напарника: 1 - корабль-наёмник, 2 - корабль-наниматель, 3 - длительность контракта в днях (для разрыва деловых отношений просто подставить 0 вместо 2 и 3 аргументов);
ShipPartners - возвращает количество рейнджеров-партнёров у корабля, или конкретный корабль из этого списка:
	1 - корабль нанимателя (возвращает количество);
  Опционально:
	2 - номер партнёра в списке (возвращает корабль партнёра);
PlayerPirates - возвращает количество пиратов-партнёров у игрока:
	Без аргументов - возвращает количество пиратов-партнёров;
  Опционально:
	1 - номер партнёра в списке (возвращает корабль партнёра);
ShipIsPartner - проверяет, не находится ли корабль в подчинении у другого, возвращает корабль нанимателя:
	1 - корабль;
ShipInFear - проверяет, не находится ли корабль в данный момент в состоянии испуга:
	1 - корабль;
PirateType - возвращает тип пирата:
	1 - корабль пирата:
	   0 - обычный не клановый (вольный) или странствующий клановый пират;
	 Далее идут подтипы клановых воинов, отличающихся лишь предпочтениями в эквипе и поведении:
	   1 - пират-танк (самый бронированный пират, принимает на себя урон);
	   2 - пират-снайпер (предпочитает дальнобойный пушки и держится на расстоянии);
	   3 - пират-шустрик (использует небольшой корпус ради скорости и предпочитает пушки с большим количеством накладываемых дебафов);
PlayerMayTakeSubCrack - без аргументов, проверяет, может ли игрок купить сабмодем на ПБ;
SubCrackCost - возвращает стоимость сабмодема;
ShipCalcParam - заставляет корабль принудительно пересчитать все свои параметры: 1 - корабль (имеет смысл добавлять, например, после искусственного обвеса бота и перед запуском ShipFreeSpace, т.к. до обработки трюма корабля тёрн-кодом, он сам ещё пока не в курсе, что получил обвес);
ShipFreeSpace - возвращает свободное место в трюме корабля (в том числе с отрицательным значением, если имеется перевес): 1 - корабль;
ShipFreeFlight - разово запускает собственную логику корабля, позволяя ему выбрать свой план действий (полезно, если ранее мы вмешались в его приказы, а сейчас нужно вновь вернуть корабль к самостоятельным действиям или просто узнать, что бы в текущей ситуации захотел сделать он сам): 1 - корабль;
RangerPlaceInRating – место рейнджера в рейтинге рейнджеров: 1 - корабль, только для рейнджеров;
RangerExcludedFromRating - возвращает есть ли корабль в рейтинге рейнджеров: 1 - рейнджер, 2 (опционально) - 0/1 вернуть/удалить из рейтинга;


Доминаторы:
Blazer - без аргументов, возвращает Блазера (если он жив, иначе 0);
Keller - без аргументов, возвращает Келлера (если он жив, иначе 0);
Terron - без аргументов, возвращает Террона (если он жив, иначе 0);
HaveProgramm - проверяет есть ли у игрока определённая программа:
	1 - номер программы;
GetProgramm - возвращает количество программ определённого типа у игрока:
	1 - номер программы;
SetProgramm - устанавливает количество программ определённого типа у игрока:
	1 - номер программы;
	2 - количество;
DomikProgramm – применяет к кораблю доминатора указанную антидоминаторскую программу (программа будет активирована в тот же день):
	1 – корабль доминатора;
	2 – номер программы;
DomikProgrammDate – устанавливает длительность действия текущей активной программы на доминаторе (сперва необходимо применить к нему одну из программ):
	1 – корабль доминатора;
	2 – до какого числа должна действовать текущая активная программа;
	  Номера программ:
	    0 - progKellerCall - iКеллер;
	    1 - progLogicalNegation - Противодействие;
	    2 - progDematerial - Дематериализатор;
	    3 - progEnergotron - Энерготрон;
	    4 - progSabCrack - Сабмодем;
	    5 - progIntercom - Интерком;
	    6 - progShipwreck - Аварийный сигнал (не сработает при установке функцией DomikProgramm);
	    7 - progWeaponBlocking - W-Кодер;
	    8 - progInsanity - Гатрикс матрица;
	    9 - progShock - Шоккер-5300;
	    10 - progSelfDestruction - Абсолютное оружие (не сработает при установке функцией DomikProgramm, но имеет эффект идентичный ShipDestroy);
	    11 - progDisconnection - Системное отключение (бессрочная программа, доминатор выключается навсегда);
NoComeKlingToStar - проверяет, устанавливает или снимает запрет доминаторам атаковать конкретную систему:
	1 - система;
  Опционально:
	2 - если значение больше 0, то запретить атаковать систему;
ShipDestroyType - без аргументов, уничтожает всех блазероидов в Галактике, создана специально для скрипта Блазера, чтобы быстро уничтожить все его корабли при использовании антидоминаторской программы;
TerronWeaponLock - без аргументов, отключает всё оружие Террона (результат срабатывания Сабмодема);
TerronGrowLock - без аргументов, отключает спавн новых доминаторов Террону;
TerronLandingLock - без аргументов, позволяет совершить посадку на Террона для проведения планетарного боя;
TerronToStar - без аргументов, отправляет Террона преобразовывать звезду;
KellerLeave - без аргументов, отправляет Келлера к клиссанам;
KellerNewResearch - без аргументов, Келлер сотрудничает с пиратами в новых исследованиях: 1 - Id системы для исследований;
KellerKill - без аргументов, уничтожает Келлера в АБ;
BlazerLanding - приземляет Блазера для сотрудничества с Коалицией: 1 - Id планеты;
BlazerSelfDestruction - без аргументов, Блазер самоуничтожается;
DomiksDefeated - проверяет, не побеждены ли доминаторы:
	Без аргументов - общая проверка, побеждены ли все доминаторы (0/1);
  Опционально:
	1 - вернёт тип победы над конкретным боссом:
		0 - Блазер:
		   0 - не побеждён;
		   1 - уничтожен в бою;
		   2 - самоуничтожился;
		   3 - сотрудничает с Коалицией;
		1 - Келлер:
		   0 - не побеждён;
		   1 - уничтожен программой или как-либо ещё в космосе;
		   2 - улетел к клисанам;
		   3 - изучает пиратов;
		2 - Террон:
		   0 - не побеждён;
		   1 - уничтожен в бою;
		   2 - преобразовывает звезду;
		   3 - побеждён в наземном бою;
CoalitionDefeated - проверяет не побеждена ли Коалиция, или изменяет это: без аргументов просто проверяет, 1 (опционально) - если значение = 1, то коалиция считается побеждённой, иначе - наоборот;


Сообщения и тексты:
NewsAdd - добавляет новость (идентична функции Ether(0,'','text')): 1 - текст новости;
MsgAdd - добавляет на панель заметок сообщение о переговорах между игроком и одним из кораблей указанной скриптовой группы: 1 - текст сообщения, 2 - номер группы, также проверяет, успешно ли выполнена операция, условия успеха:
	- В указанной группе есть корабль;
	- Корабль в той же системе, что игрок;
	- Игрок не в гиперпространстве;
Ether - добавляет сообщение определённого типа на панель уведомлений:
	1 - тип сообщения, подставлять числом:
	   0 - mp_Galaxy, общая галактическая новость (захваты систем и т.д.);
	   1 - mp_Ether, переговоры других кораблей между собой;
	   2 - mp_ShipPlus, что-то на корабле было отремонтировано (введено в строй после полной поломки) Нанитоидами;
	   3 - mp_Quest, задание в процессе (не удаляется игроком);
	   4 - mp_QuestOk, задание выполнено;
	   5 - mp_QuestCancel, задание провалено;
	   6 - mp_Tips, подсказка, как в обучении;
	   7 - mp_User, информация, которую игрок решил сохранить;
	   8 - mp_ShipMinus, что-то на корабле поломалось;
	   9 - mp_Storage, список вещей вне корабля (не удаляется игроком);
	   10 - mp_Ether2, переговоры других кораблей как-либо касающиеся игрока (не исчезает автоматически при пропуске хода);
	2 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
	3 - текст сообщения;
  Опционально:
	4, 5, 6 - корабли, станции или планеты, на которые будет происходить центровка камеры при клике на Ether;
CustomEther - добавляет сообщение определённого типа на панель заметок с изменённым изображением сообщения,
	1 - название кастомного изображения из папки 'Bm.MsgPlayer';
	2 - тип сообщения, подставлять числом:
	  0 - mp_Galaxy;
	  1 - mp_Ether;
	  2 - mp_ShipPlus;
	  3 - mp_Quest;
	  4 - mp_QuestOk;
	  5 - mp_QuestCancel;
	  6 - mp_Tips;
	  7 - mp_User;
	  8 - mp_ShipMinus;
	  9 - mp_Storage;
	  10 - mp_Ether2;
	3 - уникальный идентификатор сообщения (если в нём нет необходимости, то оставить пустую строку '');
	4 - текст сообщения;
  Опционально:
	5, 6, 7 - корабли, на которые будет происходить центровка при клике на Ether;
EtherDelete - удаляет Ether по его идентификатору: 1 - идентификатор строкой;
EtherIdAdd - добавляет в скрипт новый уникальный идентификатор сообщения: 1 - идентификатор;
EtherIdDelete - удаляет из скрипта уникальный идентификатор: 1 - идентификатор;
EtherState - возвращает тип сообщения по его идентификатору: 1 - идентификатор (если сообщение с таким идентификатором отсутствует, вернёт -1);
Dialog - запустить разговор с игроком (работает только в космосе). Для начала разговора необходимо указать как минимум корабль вызывающего игрока NPC: 1 - корабль, который должен начать разговор с игроком (можно вызывать, в том числе, из акткода), 2 (опционально) - название диалога без кавычек (сработает только при вызове из конкретного скрипта);
  Примечание: Если вам необходимо инициировать диалог из акткода, используйте для указателя на конкретный диалог в скрипте глобальную переменную или данные предмета/инфошки. При таком варианте, в скрипте диалог нужно ловить как обычный диалог с кораблём в космосе, но с проверкой значения соответствующей переменной/данных.
SkipGreeting - для скриптовых диалогов на базах/планетах/кораблях, пропускает стандартное приветствие (без аргументов);
Tips - зеленые эзеры-подсказки (?);
TipsState - состояние подсказки, игра запоминает, какая уже выдавалась, какая - еще нет;
DeleteTags - удаляет все тэги из строки, например тэги цветов: 1 - исходная строка;
DChange - используется для перевода диалога не определённую реплику собеседника:
	1 - номер реплики собеседника DialogMsg (идентично прямому указателю стрелки на нужную реплику);
  Примечание: При использовании данной функции в коде, сразу после неё обычно подставляется оператор exit, чтобы прервать дальнейшее исполнение кода после смены реплики.
DText - отображает текст в текущем пустом диалоговом окне (вызывается из кода реплики DialogMsg):
	1 - текст;
DAddText - добавляет дополнительный текст в уже заполненное диалоговое окно (вызывается из кода реплики DialogMsg только после DText):
	1 - текст;
DAdd - добавляет ответ по его номеру в скриптовом диалоге:
	1 - номер ответа DialogAnswer (идентично прямому указателю стрелки на нужный ответ);
AddDialogOverride - заменяет стандартную стартовую реплику собеседника в диалоге на скриптовый диалог: 1 - название скриптового диалога, которым будет заменён стандартный, 2 - приоритет (имеет значение, если к стартовой реплике применяется сразу несколько этих операций, чтобы выбрать, какая будет выполнена);
AddDialogInject - добавляет новые варианты ответа в стандартный стартовый диалог, добавляет в приветственную реплику собеседника нужный текст, удаляет из приветственной реплики собеседника весь стандартный (не трогая текста других инжектов) текст:
  Обязательные:
	1 - скриптовый диалог, который последует после выбора добавленного варианта ответа;
	2 - текст, который будет добавлен к приветственной реплике собеседника (если не нужно, просто оставьте пустую строку '');
	3 - текст добавляемого варианта ответа;
	4 - приоритет (чем больше число, тем выше диалог в списке относительно других инжектов, стандартные ответы из игры приоритета не имеют вовсе);
  Опциональные:
	5 - флаг (если больше 0), очищающий весь стандартный (игровой) приветственный текст;
	6 - значение, которое будет присвоено глобальной внутренней переменной GAnswerData;
InjectAnswer - добавляет ответ к скриптовому (!!!сперва необходим AddDialogInject или диалоговый объект!!!) диалогу:
	1 - диалог, который последует при нажатии;
	2 - текст ответа;
	3 - значение, которое будет присвоено глобальной внутренней переменной GAnswerData (используется для передачи нужных значений или для определения, какой ответ был выбран);
  Функциональные диалоговые тэги для поля Name в ответах:
	block - блокирует указанный ответ, автоматически перекрашивая его в серый цвет;
	snap - при клике по указанному ответу, положение вертикального скролла в диалоге не изменится (полезно при создании меню опций, когда выбор ответа не переключает диалог);
	planet - ответ автоматически переводит игрока из диалога с планетарным правительством на общий экран планеты (исполняет прикреплённый код);
	shop - ответ автоматически переводит игрока в магазин оборудования, если он есть (исполняет прикреплённый код);
	goods - ответ автоматически переводит игрока в магазин товаров, если он есть (исполняет прикреплённый код);
	hangar - ответ автоматически переводит игрока в ангар, если он есть (исполняет прикреплённый код);
	takeoff - ответ инициирует взлёт корабля (исполняет прикреплённый код);
	restart - делает рестарт текущего диалога (исполняет прикреплённый код);
	exit - выходит из текущего диалога (исполняет прикреплённый код);
	fastexit - выходит из текущего диалога (не исполняет прикреплённый после себя код и добавляет крестик для быстрого закрытия скриптовых диалогов в космосе);
DAnswer - функция добавления ответа, по умолчанию используемая компилятором в RScript: 1 - текст добавляемого ответа;
  Примечание: Допускается добавлять к тексту ответа флаги типа restart, exit, hangar и т.д. Флаги добавляются прямо в текст, но с разделителем в виде ~ то есть запись ответа с флагом должна выглядеть примерно вот так DAnswer('restart~'+"Текст ответа"). Использовать данную функцию для добавления НЕ завершающих диалог реплик (то есть всех кроме restart и exit) неудобно, т.к. придётся вручную указывать номер следующего объекта, на который должен переводить ответ.
  DAnswer('main') - данная конструкция используется для создания стандартной "выходной" реплики в космическом диалоге. То есть сбросит диалог в самое начало, сохранив при этом последний текст ответа собеседника (подставлять в "Op" сразу после "выходной" реплики);
AddDialogBlock - ищет в вариантах ответа ответ с определённым текстом и на выбор удаляет или блокирует его: 1 - текст ответа для поиска, 2 - что сделать:
	0 - вариант станет обычным (кликабильным);
	1 - вариант станет серого цвета и будет некликабильным;
	2 - вариант пропадёт;
  Примечание: Добавлять данный блок необходимо ДО подстановки блокируемого ответа, а не после.
TalkByAI - проверка, что диалог с игроком инициировал NPC (если 1 - да, если 0 - нет);
  Примечание: Если вы "искусственно" инициируете разговор NPC с игроком посредством функции Dialog(NPC) (например, через акткод), то проверка TalkByAI будет возвращать 0.
GetTalkType - возвращает тип диалога с NPC (при вызове, исходящем от самого NPC) в космосе, варианты: 0 - TalkMoney, 1 - TalkGoods, 2 - TalkTruce, 3 - TalkAttack, 4 - TalkBreakPartner, 5 - TalkPartnerTheEnd, 6 - TalkPartnerRiot;
MessageBox - вызывает сообщение с кнопкой (как, например, при включении форсажа) может быть вызвана из диалога, стэйт кода или OnUseCode: 1 - текст сообщения, 2 (опционально) - флаг внешнего вида;
MessageBoxYesNo - вызывает сообщение с выбором да/нет (при выборе да возвращает 1, при нет 0): 1 - текст сообщения, 2 (опционально) - сет внешнего вида;
  Функции вывода сообщений могут визуально меняться в зависимости от суммы установленных флагов, ниже приведены значения, которые нужно суммировать во второй аргумент для получения той или иной комбинации визуального интерфейса сообщения (задать сет):
	1 - Ok - кнопка ОК (с галочкой);
	2 - Cancel - кнопка отмены (с крестиком);
	4 - IconInfo - бэкграунд с информационным сообщением (i) (как в большинстве месседжей);
	8 - IconWarning - бэкграунд с предупреждающим сообщением (!) (как на планетах с плохим отношением);
	16 - IconQuestion - бэкграунд с вопросительным сообщением (?) (как в стандартных месседжах вида YesNo);
	32 - IconError - бэкграунд с сообщением об ошибке (x) (как при попытке передвинуть корабль с нулевой скоростью);
	64 - AlignLeft - выравнивание текста по левому краю;
  По умолчанию (без флагов) выводятся стандартный информационный месседж с кнопкой отмены и стандартный вопросительный меседж YesNo с вопросительным сообщением.
CountBox - вызывает интерфейс с ползунком и выбором да/нет (как при выбросе товаров в космос или покупке\продаже товаров, при "Нет" возвращает 0, при "Да" - значение ползунка):
	1 - строка пути к изображению в CacheData.dat (например строка вида 'Bm.Items.2Minerals' добавит в интерфейс изображение минералов);
	2 - текст, отображаемый над счётчиком;
	3 - минимальное значение;
	4 - максимальное значение (опционально);
	5 - цена за единицу, если !=0, то появится ещё и счётчик стоимости (опционально);
	6 - шаг изменения величины, по умолчанию 1 (опционально, но в любом случае не работает (видимо, пережиток из КР1, где шаг был кратен 5));
	7 - максимальное значение единиц, после которого блокируется утвердительный выбор (опционально);
	8 - максимальное значение единиц, после которого счётчик единиц становится красным (опционально);
	9 - максимальное значение кредитов, после которого счётчик кредитов становится красным (опционально);
	10 - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
NumberBox - аналогичен CountBox, однако все числовые аргументы и возвращаемое значение теперь dword вместо int, а отображаемый счётчик значения центрирован. Также кнопки увеличения и уменьшения значения счётчика NumberBox имеют свойство увеличивать и понижать скорость накрутки счётчика в зависимости от продолжительности нажатия:
	1 - путь к иконке, например: 'Bm.Items.2Minerals';
	2 - текст, отображаемый над счётчиком;
	3 - минимальное значение;
	4 - максимальное значение;
	5 (опционально) - максимальное разрешенное для выбора значение (при превышении утвердительный ответ блокируется и счётчик становится красным);
	6 (опционально) - кастомная картинка полоски, на которой распологается счётчик (при добавлении этого аргумента, счётчик теряет центровку и принимает вид обычного счётчика из CountBox), оставлять пустой строкой '', если замена не требуется;
	7 (опционально) - по умолчанию предзаданное число на счётчике (в диапазоне минимального и максимального значений);
TextBox - вызывает интерфейс для ввода текста, возвращает строку с введённым текстом: 1 (опционально) - текст заголовка интерфейса, 2 - предзаданный текст в поле ввода, 3 - максимальное количество символов для ввода (по умолчанию 30, но можно делать и больше);
ListBox - вызывает панель со списком, созданным из элементов указанного массива. После выбора конкретного варианта и нажатия "Да", возвращает индекс соответствующего элемента массива (если был выбран ответ "Нет", вернёт -1): 1 - текст заголовка панели, 2 - массив, из которого будет сформирован список;


Объекты:
SetName - назначает имя кораблю или объекту: 1 - корабль, планета, система или предмет, 2 - строка нового имени;
Name - возвращает имя объекта: 1 - объект:
	- Система;
	- Сектор;
	- Планета;
	- Корабль (вернёт полное имя);
	- Предмет (вернёт имя без приписок всяких бонусов);
ShortName - аналог Name, в случае если объект – корабль, возвращает короткое имя: 1 - объект;
Id - возвращает ID любого объекта с Id: 1 - объект;
ChangeGlobalRelationsShips - изменяет глобальное отношение кораблей к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта;
ChangeGlobalRelationsPlanets - изменяет глобальное отношение планет к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта;
GlobalRelationsShips - возвращает глобальное отношение кораблей к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта;
GlobalRelationsPlanets - возвращает глобальное отношение планет к рейнджеру, либо общее отношение в секторе или у какого-то конкретного объекта: 1 - корабль, 2 (опционально) - конкретный сектор или объект (???), 3 - сет рас (надо просто суммировать нужные цифры), общее отношение планет которых нужно вернуть (пример - общее отношение планет малоков и гаальцев будет равно 17):
	1 - глобальное отношение всех малокских планет;
	2 - глобальное отношение всех пеленгских планет;
	4 - глобальное отношение всех человеческих планет;
	8 - глобальное отношение всех фэянских планет;
	16 - глобальное отношение всех гаальских планет;
	31 - глобальное отношение планет всех рас Коалиции (1+2+4+8+16);
	128 - глобальное отношение всех пиратских планет;
	159 - глобальное отношение вообще всех заселённых свободных планет (31+128);
Dist - возвращает расстояние между двумя объектами в системе: 1 - первый объект, 2 - второй объект, возможные типы объектов: корабль, скриптовый предмет, предмет, скриптовое место, планета, звезда, астероид, ракета;
StarMissiles - возвращает количество ракет в системе, или конкретную ракету в ней: 1 - система (вернёт количество), 2 (опционально) - номер ракеты в списке ракет системы (вернёт ракету);
StarAsteroids - возвращает количество астероидов в системе, или конкретный астероид в ней: 1 - система (вернёт количество), 2 (опционально) - номер астероида в списке астероидов системы (вернёт астероид);
CoordX - возвращает значение X координаты для указанного объекта: 1 - объект, возможные типы: корабль, предмет в космосе, скриптовое место, планета, система (координаты звезды), астероид, ракета, 2 (опционально) - новое значение X координаты;
CoordY - возвращает значение Y координаты для указанного объекта: 1 - объект, возможные типы: корабль, предмет в космосе, скриптовое место, планета, система (координаты звезды), астероид, ракета, 2 (опционально) - новое значение Y координаты;
ShipSetCoords - установить координаты корабля/станции (фактически может работать как мгновенный телепорт внутри системы): 1 - корабль, 2 - координата X, 3 - координата Y;
  Примечание: Аналогично можно менять координаты и другим объектам, включая системы на галакарте (не точно), но для этого нужно пользоваться отдельными функциями CoordX и CoordY. Если изменить координаты корабля, находящегося на планете или станции, то в космос он не перенесётся, однако координаты местонахождения в системе изменит.
ShipAngle - возвращает/устанавливает угол направления носа корабля: 1 - корабль, 2 (опционально) - угол (градусы);
ObjectType - возвращает тип объекта: 1 - объект:
   1 - звезда;
   2 - ЧД;
   3 - планета;
   4 - станция;
   5 - корабль;
   6 - предмет;
   7 - ракета;
   8 - астероид;
AsteroidMinerals - возвращает или устанавливает количество минералов в астероиде: 1 - астероид (вернёт значение), 2 (опционально) - какое количество минералов установить (вернёт первоначальное значение);
AsteroidGraph - возвращает или устанавливает внешний вид астероида: 1 - астероид, 2 - анимация астероида в Main, 'Data.SE';


Скриптовые объекты:
	Примечание: Создаются в RScript, посредством объекта Item. Предмет в скриптовом объекте использовать намного удобнее, кроме того он получает полную защиту от авторасстрела NPC в космосе и не может быть по собственному желанию дропнут ими из трюма. В каждый скриптовый объект одновременно можно занести лишь один предмет.
ItemExist - проверяет, существует ли предмет в скриптовом объекте: 1 - скриптовый объект (название без кавычек, т.к. это переменная);
ItemIn - проверяет, не находится ли предмет в скриптовом объекте в определённом месте: 1 - скриптовый объект, 2 - место:
	- Конкретная система (предмет болтается в качестве лута в определённой системе);
	- Конкретный корабль (предмет в трюме у определённого корабля);
	- Конкретная планета (предмет находится на планете);
LinkItemToScript - занести предмет в скриптовый объект: 1 - предмет, 2 - скриптовый объект;
ReleaseItemFromScript - удалить предмет из скриптового объекта: 1 - скриптовый объект или предмет в нём;
ItemInScript - проверяет не занесён ли предмет в скриптовый объект: 1 - предмет;
ScriptItemData - возвращает/устанавливает числовые данные для скриптового объекта (не предмета в нём): 1 - скриптовый объект или предмет в нём, 2 - поле для записи (Data1, Data2, Data3), какое значение установить;
ScriptItemTextData - возвращает/устанавливает текстовые данные для скриптового объекта: 1 - скриптовый объект или предмет в нём, 2 - поле для записи (TextData1, TextData2, TextData3), какое значение установить;
ScriptItemToItem - возвращает непосредственно предмет, занесённый в скриптовый объект: 1 - скриптовый объект;
DropScriptItem - заставляет корабль выбросить за борт предмет в скриптовом объекте: 1 - корабль, 2 - скриптовый объект или предмет в нём;
ItemOnActCode - возвращает строчку OnActCode скриптового объекта (!!!) или устанавливает её (при установке старая строчка акткода затирается): 1 - скриптовый объект или предмет в нём, 2 (опционально) - строка с кодом, для установки объекту в качестве OnActCode;
ItemOnUseCode - возвращает строчку OnUseCode скриптового объекта (!!!) или устанавливает её (при установке старая строчка юзкода затирается): 1 - скриптовый объект или предмет в нём, 2 (опционально) - строка с кодом, для установки объекту в качестве OnUseCode;
  Примечание: Для назначения предмету строка кода должна быть предварительно сформирована функцией GenerateCodeStringFromBlock.
CanSellItem - проверяет/включает/отключает возможность продажи предмета в скриптовом объекте (по умолчанию продавать нельзя): 1 - скриптовый объект или предмет в нём, 2 (опционально) - установить разрешение для продажи 0/1;


Предметы:
IdToItem - возвращает предмет по его Id: 1 - Id предмета;
ItemDestroy - уничтожает предмет в космосе: 1 - предмет, 2 - тип взрыва (0 не взрывать (отменяет уничтожение), 1 - маленький взрыв, 2 - взрыв как у бочки с горючим (урон по области есть, но дистанция от эпицентра взрыва никак не учитывается), также данный взрыв не сработает, если в предмет до взрыва попадёт ракета или торпеда;
ItemCount - возвращает количество предметов указанного типа на корабле: 1 - корабль, 2 - тип предмета;
UselessItemCreate - создаёт ошмёток (предположительно, устаревшая функция);
CreateQuestItem - создаёт UselessItem (ошмёток, квестовые предметы и прочие юзлесы): 1 - системное название предмета строкой (список находится в lang.dat\UselessItems\), 2 (опционально) - раса-производитель (по умолчанию устанавливается доминаторская);
UselessItemText - возвращает/устанавливает описание для UselessItem: 1 - предмет, 2 (опционально) - какое описание установить;
UselessItemData - возвращает/устанавливает числовые данные Useless предмета: 1 - предмет, 2 - номер данных (от 1 до 3), 3 - (опционально) какие данные установить (при подстановке тэга вида <Data1> в текст данного предмета, автоматически подставляет в то место значение соответствующей ячейки данных);
ShipItems - возвращает общее количество, или конкретный предмет из трюма: 1 - корабль, 2 (опционально) - номер предмета в списке предметов корабля (учтите, что под номером 0 всегда находится и всегда должен находиться корпус корабля);
ItemType - возвращает тип предмета: 1 - предмет (список типов в конце документа);
ItemName - возвращает общее название предмета, например для любого двигателя вернёт строку 'Двигатель': 1 - предмет;
ItemFullName - возвращает полное имя предмета, в том числе с установленным ММ: 1 - предмет;
ItemSize - вернёт текущий размер предмета или задаст его: 1 - предмет (вернёт размер), 2 (опционально) - какой размер установить (вернёт размер до изменения);
ContainerFuel - возвращает/устанавливает количество топлива в баке/цистерне: 1 - бак/цистерна, 2 (опционально) - какое количество топлива установить;
ItemCharge - возвращает/устанавливает заряд для предметов с зарядом, например для трансфакторных маяков: 1 - предмет, 2 - заряд, который необходимо установить;
ItemOwner - вернёт производителя предмета или установит его:
	1 - предмет (вернёт производителя);
  Опционально:
	2 - какого производителя установить (вернёт производителя до изменения):
	  0 или Maloc - малокский производитель;
	  1 или Peleng - пеленгский производитель;
	  2 или People - человеческий производитель;
	  3 или Fei - фэянский производитель;
	  4 или Gaal - гаальский производитель;
	  5 или Kling - доминаторский производитель;	  
	  6 или None - неизвестный производитель;
	  7 или PirateClan - пиратский производитель;
ItemSubrace - вернёт доминаторскую серию предмета или установит её:
	1 - предмет (вернёт серию);
  Опционально:
	2 - какую серию установить (вернёт серию до изменения):
	  0 - Блазер;
	  1 - Келлер;
	  2 - Террон;
  Примечание: На данный момент единственная функция для определения серии доминаторов. Серия корабля определяется по серии его корпуса.
EqCustomFaction - возвращает или устанавливает кастомную фракцию для любого предмета: 1 - предмет, 2 (опционально) - системное название фракции, которую надо установить предмету (иконка фракции будет взята из Data.Race.Emblem.2your_faction_name в мейне, аналогично её нужно будет прописать и для кэша, формат Png);
ItemCost - вернёт текущую цену предмета или установит её: 1 - предмет (вернёт стоимость), 2 (опционально) - какую цену установить (вернёт стоимость до изменения);
ItemIsInUse - проверяет, надет ли предмет на корабль/станцию, либо надевает его:
	1 - предмет;
  Опционально:
	2 - корабль (вернёт номер слота в котором установлен предмет, что актуально для оружия (1-5) и артефактов (1-4));
	3 - 0/1 снять/надеть данный предмет;
	4 - номер слота, в который нужно надеть предмет (актуально для оружия (1-5) и артефактов (1-4));
	  Примечание: Надевать можно не только оборудование, но и, например, UselessItem, который пропадёт из трюма, но останется висеть на корабле в "невидимом" состоянии. Таким образом можно полностью скрывать присутствие на корабле определённых вещей. Правда, для сокрытия счетчика занятого трюмного пространства придётся также прибегнуть к несколько большим ухищрениям с подменой самого счетчика на кастомный Label.
ItemIsInSet - проверит используется ли предмет в любом из сетов:
	1 - предмет;
  Опционально:
	2 - к какому сету прикрепить предмет;
PlayerEqSet - возвращает текущий активный сет:
	Без аргументов - вернёт номер активного сета;
  Опционально:
	1 - номер конкретного сета для получения информации по нему:
	  0 - если такого сета ещё нет;
	  1 - если сет есть, но он не активен;
	  2 - если сет есть и именно он сейчас активен;
ItemIsBroken - проверяет, не сломан ли предмет (0 - не сломан, 1 - сломан):
	1 - предмет;
HullType - возвращает или устанавливает тип указанного корпуса:
	1 - сам корпус или корабль его использующий;
  Опционально:
	2 - какой тип установить:
	   0 - корпус рейнджера;
	   1 - корпус военного;
	   2 - корпус пирата;
	   3 - корпус транспорта;
	   4 - корпус лайнера;
	   5 - корпус дипломата;
	 Вероятно, приведут к крашу:
	   6 - корпус доминатора;
	   7 - корпус транклюкатора;
	   8 - корпус станции;
	   9 - корпус с любым акрином (внутренний тип, автоматически подставляется любому стандартному корпусу при его акринации);
	   10 - корпус флагмана (а этот не приведёт, однако в оригинальной игре таким корпусам не хватает "складских" пикчей);
CreateHull - создаёт стандартный корпус и возвращает на него ссылку:
	1 - тип корпуса;
	2 - размер;
	3 - ТУ;
	4 - раса-производитель;
  Опционально:
	5 - номер серии (без серии: -1);
	6 - флаг (0/1) о том, что корпус нужно считать клановым (появится символ клановой эмблемы с цветом расы-производителя);
SeriesCount - без аргументов, возвращает общее число доступных корпусных серий;
FindSeriesByName - поиск номера серии по её имени:
	1 - имя нужной серии;
HullSeries - возвращает/устанавливает серию корпуса:
	1 - корпус;
  Опционально:
	2 – номер серии, которую нужно установить (-1 - снять серию);
SeriesNumInCfg - возвращает раздел Lang, в котором прописана определённая серия:
	1 - номер серии;
CreateEquipment - создаёт оборудование/оружие (только оригинальное) или цистерну и возвращает на него ссылку:
	1 - тип оборудования/оружия (полный перечень в конце списка);
	2 - размер оборудования;
	3 - ТУ оборудования (или текущее количество топлива для цистерны, если создаёте цистерну);
	4 - раса-производитель;
CreateEquipmentWithSpecial - создаёт оборудование/оружие (только оригинальное) с указанным акрином, при этом тип создаваемого оборудования будет автоматически взят из раздела акрина в Lang (если акрин может висеть на нескольких типах оборудования, выбирается случайный тип из этого списка):
	1 - номер бонуса (при подстановке бонуса, рассчитанного только для кастомных орудий, вернёт 0);
	2 - размер оборудования;
	3 - ТУ оборудования;
	4 - раса-производитель;
  Примечание: Данная функция используется для упрощения создания оборудования с произвольным акрином, без необходимости перебирать типы пригодного для акринации оборудования функцией MayAddBonusToEq.
GetEquipmentStats - возвращает определённый параметр предмета: 1 - предмет, 2 - параметр;
	1 - предмет;
	2 - параметр:
	   Доступные для запроса параметры:
		 Корпус:
		    0 - броня;
		    1 - количество слотов оружия;
		    2 - количество слотов артефактов;
		    3 - слот радара;
		    4 - слот сканера;
		    5 - слот дроида;
		    6 - слот захвата;
		    7 - слот ГЗП;
		    8 - имеется ли форсаж (слоты возвращаются с учётом всех применённых к корпусу бонусов и его серии);
		 Оружие:
		    0 - максимальный урон;
		    1 - минимальный урон;
		    2 - дальность;
		    3 - базовый тип урона (0 - энергетический, 1 - осколочный, 2 - ракетный);
		    4 - количество выстрелов за ход;
		    5 - количество залпов (например, ракет) в выстреле;
		    6 - полный дамагсет с учётом всех бонусов;
		 Двигатель:
		    0 - скорость;
			1 - дальность прыжка;
		 Топливный бак:
		    0 - ёмкость;
			1 - текущее количество топлива;
		 Радар:
		    0 - дальность;
		 Сканер:
		    0 - мощность;
		 Дроид:
		    0 - эффективность ремонта;
		 Захват:
		    0 - размер захватываемых объектов;
			1 - дальность захвата;
			2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
			3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
		 Генератор защитного поля (ГЗП):
		    0 - процент поглощения урона;
		 Исследовательский зонд:
		    0 - вода;
			1 - равнина;
			2 - горы;
			3 - надёжность (Fragility) зонда в виде float;
		 Цистерна:
		    0 - ёмкость;
			1 - текущее количество топлива;
SetEquipmentStats - по аналогии с GetEquipmentStats, устанавливает значения параметрам предмета:
	1 - предмет;
	2 - новое значение;
	3 - параметр (!!!Обратите внимание, что очерёдность аргументов здесь дебильная!!!):
	  Доступные для изменения параметры:
		 Корпус:
		    0 - броня;
		 Оружие:
		    0 - максимальный урон;
		    1 - минимальный урон;
		    2 - дальность;
		 Двигатель:
		    0 - скорость;
			1 - дальность прыжка;
		 Топливный бак:
		    0 - ёмкость;
			1 - текущее количество топлива;
		 Радар:
		    0 - дальность;
		 Сканер:
		    0 - мощность;
		 Дроид:
		    0 - эффективность ремонта;
		 Захват:
		    0 - размер захватываемых объектов;
			1 - дальность;
			2 - скорость притяжения захвата на дальней дистанции (наименьшая) в виде float;
			3 - скорость притяжения захвата на ближней дистанции (наибольшая) в виде float;
		 Генератор защитного поля (ГЗП):
		    0 - процент поглощения урона;
		 Исследовательский зонд:
		    0 - вода;
			1 - равнина;
			2 - горы;
			3 - надёжность (Fragility) зонда в виде float;
		 Цистерна:
		    0 - ёмкость;
			1 - текущее количество топлива;
	Примечание: Если значение параметра не равно базовым статам для текущего ТУ данного типа предмета (с учётом вставленных ММ), то такой предмет будет считаться улучшенным.
EquipmentImageName - возвращает или изменяет системное имя (из Lang), а попутно и картинку предмета, работает с предметами или кораблём транклюкатора, для кастомных артефактов меняет тип артефакта:
	1 - предмет;
  Опционально:
	2 - новое системное имя;
DropItemInSystem - выбрасывает (не обязательно из трюма или из хранилища) предмет в космосе в определённой системе по определённым координатам:
	1 - система;
	2 - предмет;
	3 - начальная X координата (точка появления предмета, откуда он начнёт движение);
	4 - начальная Y координата;
	5 - конечная X координата (точка завершения движения предмета, место, где он остановится);
	6 - конечная Y координата;
StopMovingItem - останавливает движущийся по системе предмет:
	1 - система;
	2 - предмет (желательно использовать сразу после DropItemInSystem (если последняя не была задействована из акткода), чтобы предмет появился в своих конечных координатах сразу, а не с началом анимации);
StarItems - возвращает количество лута в системе, или конкретный предмет из списка лута:
	1 - система;
  Опционально:
	2 - номер предмета из списка лута;
StorageItems - возвращает количество предметов на складе (общего для всех планет и баз в Галактике) или конкретный предмет:
	Без аргумента - возвращает количество предметов;
  Опционально:
	1 - номер предмета в списке (возвращает предмет);
StorageItemLocation - возвращает местоположение предмета на складе (планету или базу): 1 - номер предмета в списке предметов склада;
ShopItems - возвращает количество предметов в магазине оборудования или конкретный предмет из этого списка: 1 - магазин (планета или станция), 2 (опционально) - номер предмета в списке;
FindItemInShip - ищет определённый предмет/артефакт на корабле, и при успехе возвращает его номер (при неудаче вернёт -1) в списке предметов/артефактов корабля: 1 - корабль, 2 - предмет;
PlanetItems - возвращает количество предметов на поверхности планеты или конкретный предмет из этого списка: 1 - планета (возвращает количество), 2 (опционально) - номер предмета в списке (возвращает предмет);
CreateZond - создаёт зонд и возвращает на него ссылку:
	1 - ТУ (в оригинале от 0 до 5, в моде EvoSB до 7);
	2 - раса-производитель;
  Опционально:
	3 - скорость исследования воды;
	4 - скорость исследования равнин;
	5 - скорость исследования гор;
  По умолчанию берёт базовые характеристики из Lang с 20% шансом на +1 к одной случайной (20% вода, 20% равнины и 20% горы), и с 40% шансом не выдать доп. стат вовсе.
  В оригинале, обновление продающегося на станции зонда может происходить хоть каждый день с шансом 1 к 17.
ExistingZonds - без аргумента возвращает общее количество зондов у игрока:
	1 - возвращает зонд по номеру (начиная с 0), если он в данный момент работает на планете, а все нерабочие зонды всегда будут в конце "списка" с возвратом 0;
	2 - маркер (если больше 0), для возврата планеты, на которой сейчас работает зонд (если он работает);
CreateCustomCountableItem - создаёт кастомный сыпучий предмет: 1 - системное имя предмета из Lang строкой, 2 – количество, 3 (опционально) – анимация в космосе, если предмет будет добавляться непосредственно туда;
AddItemToShop - добавляет предмет в магазин: 1 - магазин (планета или станция), 2 - предмет (по умолчанию работает только для оборудования, но можно добавить графических ресурсов для отображения в магазине любого другого предмета):
	Принцип определения фона под предметом (с изображением уровней) работает следующим образом. Игра проверяет тип предмета, и составляет строку вида '2SlotCargoHook_4' - где последняя цифра - это ТУ оборудования, либо, например, '2ArtRadar' для любых предметов, у которых уровней нет. Если по данному имени игра найдёт графику в папке FormShop2, то подставит соответствующий фон, иначе подставит стандартный фон с уровнем для любого оборудования, и фон по имени '2SlotArtefact' для любого артефакта (в т.ч. любого кастомного). Для всех прочих предметов по умолчанию будет взят фон '2SlotLevel0'.
  Список возможных названий фона:
	'2SlotFood' - еда;
	'2SlotMedicine' - медикаменты;
	'2SlotTechnics' - техника;
	'2SlotLuxury' - роскошь;
	'2SlotMinerals' - минералы;
	'2SlotAlcohol' - алкоголь;
	'2SlotArms' - оружие;
	'2SlotNarcotics' - наркотики;
      Примечание: Попытка добавить товары в магазин оборудования, скорее всего, приведёт к крашу.
    '2SlotHull_N' - корпус с номером уровня;
	'2SlotFuelTanks_N' - топливный бак с номером уровня;
	'2SlotEngine_N' - двигатель с номером уровня;
	'2SlotRadar_N' - радар с номером уровня;
	'2SlotScaner_N' - сканер с номером уровня;
	'2SlotRepairRobot_N' - дроид с номером уровня;
    '2SlotCargoHook_N' - захват с номером уровня;
	'2SlotDefGenerator_N' - ГЗП с номером уровня;
	'2SlotWeapon_N' - любое оружие (в т.ч. кастомное) с номером уровня;
    '2SlotArtHull', '2SlotArtFuel', '2SlotArtSpeed', '2SlotArtPower', '2SlotArtRadar', '2SlotArtScaner', '2SlotArtDroid', '2SlotArtNano', '2SlotArtHook', '2SlotArtDef', '2SlotArtAnalyzer', '2SlotArtMiniExpl', '2SlotArtAntigrav', '2SlotArtTransmitter', '2SlotArtBomb', '2SlotArtTranclucator', '2SlotArtDefToEnergy', '2SlotArtEnergyPulse', '2SlotArtEnergyDef', '2SlotArtSplinter', '2SlotArtDecelerate', '2SlotArtMissileDef', '2SlotArtForsage', '2SlotArtWeaponToSpeed', '2SlotArtGiperJump', '2SlotArtBlackHole', '2SlotArtDefToArms1', '2SlotArtDefToArms2', '2SlotArtArtefactor', '2SlotArtBio', '2SlotArtPDTurret', '2SlotArtFastRacks' - индивидуальные типы оригинальных артефактов, расшифровка имён внизу списка функций;
	'2SlotArtefact' - любой кастомный артефакт, либо оригинальный артефакт без индивидуального фона;
	'2SlotUselessItem' - любой квестовый предмет;
    '2SlotUselessCountableItem' - квестовый сыпучий;
	  Примечание: Для всех предметов, имеющий системное имя типа в Lang (артефакты, юзлесы и т.д.), возможно добавление индивидуальной иконки фона по её имени (пример: '2SlotYourArtName'), которая будет считаться приоритетной по отношению к иконке общего типа данного предмета.
	'2SlotNod_1' - ММ третьего уровня;
	'2SlotNod_2' - ММ второго уровня;
	'2SlotNod_3' - ММ первого уровня;
    '2SlotProtoplasm' - ноды;
	'2SlotCistern' - цистерна;
	'2SlotSatellite' - зонд;
	'2SlotTreasureMap' - карта сокровищ;
GetItemFromShop - изымает предмет из магазина: 1 - магазин (планета или база), 2 - номер предмета в списке предметов магазина;
GetArtFromShip - аналогично GetItemFromShip, изымает артефакт из трюма корабля, т.к. они хранятся на корабле отдельным списком: 1 - корабль, 2 - номер артефакта в списке артефактов корабля;
AddItemToStorage - добавляет предмет на склад: 1 - склад (планета или база), 2 - предмет;
GetItemFromStorage - изымает предмет со склада: 1 - номер предмета в списке склада игрока (склад игрока это единый массив, где каждому предмету дополнительно присваивается его местонахождение (планета или база));
FindItemInStorage - возвращает номер предмета в списке предметов хранилища: 1 - предмет;
PutItemInVault - помещает предмет в невидимое хранилище: 1 - текстовая строка, обозначающая предмет, 2 - предмет (если предмет на складе или в трюме, необходимо сперва его извлечь);
GetItemFromVault - изымает предмет из невидимого хранилища: 1 - текстовая строка, обозначающая предмет;
AddItemToPlanet - добавляет предмет на поверхность планеты, по идее добавить может и на заселённую, только смысла в этом нет: 1 - планета, 2 - предмет;
GetItemFromPlanet - изымает предмет с поверхности планеты: 1 - планета, 2 - номер предмета в списке предметов планеты;
AddItemToShip - добавляет предмет в трюм корабля: 1 - корабль, 2 - предмет;
GetItemFromShip - изымает предмет из трюма корабля: 1 - корабль, 2 - номер предмета в списке предметов корабля;
FreeItem - удаляет предмет из игры: 1 - предмет (важно!!! нельзя удалить предмет сразу из трюма, с планеты, из космоса и т.д., для начала его нужно оттуда изъять, для чего существуют специальные функции Get****, а без последствий удалить предмет, находящийся в космосе, невозможно в принципе);
FormShipCurItem - позволяет взаимодействовать с предметом, находящимся в руке (поднятом). Без аргумента вернёт предмет в руке игрока: 1 - тип проверки или действия:
	0 или 'MoveType' - вернёт тип того, что находится в руке: 0 - ничего, 1 - сыпучий предмет (в т.ч. товары), 2 - просто предмет, 3 - артефакт;
	1 или 'StackableType' - вернёт конкретный тип сыпучего предмета (для товара взятого из трюма предмет не существует, поэтому чекнуть можно только так);
	2 или 'StackableCount' - вернёт количество сыпучего предмета, находящегося в руке;
	3 или 'StackableCost' - вернёт цену сыпучего предмета, находящегося в руке;
	4 или 'PutBack' - не вернёт ничего, но положит предмет из руки на место;
	5 или 'Destroy' - не вернёт ничего, но уничтожит предмет в руке (уничтожить через FreeItem его в данный момент нельзя);
	6 или 'Detach' - уберёт предмет из руки, но не вернёт его на корабль. Возвращает ссылку на убранный из руки предмет, если это возможно.

ArrangeItems - заставляет корабль проинспектировать свою оборудку (чтобы он сразу надел выданный ему предмет, к примеру): 1 - корабль;
CustomWeaponType - возвращает строчный тип кастомного оружия: 1 - кастомное оружие в виде предмета;
CustomWeaponTypes - возвращает общее количество существующих в Галактике кастомных пушек: 1 - номер орудия в списке, вернёт строчный кастомный тип;
GetCustomWeaponPrimaryDamageType - возвращает базовый тип урона для конкретного типа кастомного оружия: 1 - тип кастомного оружия (возвращает int от 0 до 2);
GetCustomWeaponData - возвращает различные параметры для конкретного типа кастомного или оригинального (!) оружия:
  1 - тип оружия (для получения информации об оригинальном оружии, необходимо подставлять сюда его числовой тип в виде int, а для кастомного - строчный в виде str);
  2 - запрашиваемый параметр:
	'TechLevel' - технологический уровень оружия;
	'AverageSize' - средний размер;
	'AverageRadius' - средний радиус;
	'SecondaryDamageRadius' - радиус сплеша (актуально для орудий с типом выстрела Splash или Exploder);
	'MaxDamage' - максимальный урон;
	'MinDamage' - минимальный урон;
	'kCost' - ценовой коэффициент (определяет стоимость);
	'ShotType' - тип выстрела:
	   'Normal' - обычная стрельба по одиночной цели;
	   'Splash' - попадание также наносит урон по области вокруг основной цели;
	   'Chain' - цепная атака, как у Волнового фазера;
	   'Exploder' - цепная реакция в случае уничтожения цели, как у Турбогравира;
	   'AreaDamage' - атака по области вокруг корабля, как у Вертикса;
	   'Rocket' - обычная ракета (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Rocket3);
	   'Missile' - ракета, имеющая сплеш (изменение числа ракет в одной атаке производится добавлением цифры в конце, например: Missile3);
	   'Torpedo' - обычная торпеда;
	'DamageType' - стандартный дамагсет для указанного типа оружия;
	'AttackCount' - число залпов за ход;
	'ShotCount' - число выстрелов/ракет в залпе (или количество целей, например, для волнового фазера);
	'Availability' - возвращает тип магазинов, в которых можно приобрести это оружие:
	   'Free' - оружие продаётся в любых магазинах;
	   'CoalitionOnly' - только на планетах/станциях Коалиции;
	   'PirateOnly' - только на пиратских планетах/станциях;
	   'MalocOnly' - только на малокских планетах/станциях;
	   'PelengOnly' - только на пеленгских планетах/станциях;
	   'PeopleOnly' - только на человеческих планетах/станциях;
	   'FeiOnly' - только на фэянских планетах/станциях;
	   'GaalOnly' - только на гаальских планетах/станциях;
	   'NotSold' - это оружие нельзя купить в магазинах;
	   'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
GetCustomWeaponInfo - возвращает указатель на раздел со статами кастомной пушки: 1 - имя типа кастомного оружия;
CreateCustomWeapon - создать кастомное оружие: 1 - тип кастомного оружия, 2 - размер, 3 - уровень, 4 - раса-производитель;
CustomMissileType - возвращает тип кастомного оружия из которого выпущена ракета: 1 - ракета;
InventNewCustomWeapon - создаёт новый тип оружия с указанным именем и прописывает его в сейве, возвращает указатель на него:
	1 - имя;
  Опционально:
	2 - тип базовой пушки с которой будут изначально скопированы статы (по умолчанию - пром. лазер);
SetCustomWeaponShotData - устанавливает тип выстрела кастомной пушки:
	1 - раздел кастомного оружия;
	2 - тип выстрела (строка: 'Normal', 'Splash', 'Exploder', 'AreaDamage', 'Torpedo', 'Missile', 'Rocket', 'Chain') если в залпе больше 1 выстрела, то можно увеличить число (например 'Rocket3' (не работает для торпед));
  Опционально:
	3 - скорость произведения выстрела (от 0 до 100, где 0 - скорость Ракетомёта и Лирекрона, а 100 - скорость Турбогравира);
	4 - средний радиус;
	5 - вторичный средний радиус (радиус сплеша);
	6 - сколько руды останется после выстрела по астероиду;
	7 - число выстрелов за ход;
  Примечание: Параметр скорости выстрела можно установить сколь угодно высоким, однако после наложения всех возможных бонусов, фактическая скорость выстрела будет всё равно рассчитана из диапазона 0-100. Значения скорости выше сотни имеет смысл устанавливать лишь для снижения отрицательных эффектов бонусов, влияющих на скорость.
SetCustomWeaponDamageData - устанавливает параметры урона кастомной пушки:
	1 - раздел кастомного оружия;
	2 - минимальный урон;
	3 - максимальный урон;
	4 - дамагсет в виде числа, либо строки, аналогичной оригинальному виду: 'Splinter,Acid,NoDelta' (без пробелов и с учётом регистра);
  Опционально:
	5 - первый аргумент float из списка, либо сразу целая строка вида: '1.00,1.10,1.15,1.20,1.25,1.30,1.35,1.40' без пробелов (все уровни указывать не обязательно);
	6, 7, 8, 9, 10, 11, 12 - прочие параметры mWeaponDamage в виде float (по одному аргументу на уровень, подставлять все 8 также не обязательно);
SetCustomMissileWeaponStats - устанавливает статы ракеты/торпеды для кастомного оружия ракетного типа:
	1 - раздел кастомного оружия;
	2 - радиус ракеты;
	3 - максимальная скорость;
	4 - минимальная скорость;
	5 - шанс на сбитие ракеты при выстреле по ней (от 0 до 100);
SetCustomWeaponPrimaryData - устанавливает данные о продаже кастомного оружия:
	1 - раздел кастомного оружия;
	2 - ГТУ разблокировки возможности использования/починки и начала появления пушки в магазинах (в магазинах планет начинает появляться по достижении самой планетой указанного в аргументе ТУ);
	3 - номер ванильного орудия, технологический уровень которого будет наследован для повышения ТУ данной кастомной пушки на планетах;
	  Примечание: А конкретно, насколько рано начнут повышаться ТУ кастомной пушки в магазинах.
	  У каждого оригинального оружия для этого имеется свой индивидуальный технический планетарный проект, который открывается для изучения планетой не раньше, чем открывается для покупки базовое орудие без повышенных уровней ТУ (A, B, C и т.д.). Далее, получив необходимый уровень ПТУ, планета может начать изучать проект определённого оружия, что в итоге приведёт к повышению технического уровня данного орудия при его продаже на конкретной планете. Поскольку у кастомного оружия индивидуального планетарного проекта нет, проект будет наследован ею от проекта указанной в данном аргументе оригинальной пушки и, следовательно, уровень ТУ кастомного орудия будет повышен на конкретной планете одновременно с уровнем родительской оригинальной пушки.
	4 - номер ванильного орудия, эффект которого будет наследован кастомной пушкой в АБ;
  Примечание: В третьем аргументе необходимо указывать оригинальный тип, т.к. планеты не могут изучать кастомное оружие и будут зависеть от этой привязки. Кастомная пушка будет повышать уровни в магазинах планет одновременно с повышением уровней родительского оружия.
SetCustomWeaponSizeAndCost - устанавливает цену и вес кастомной пушки (очерёдность аргументов не совпадает с названием!!!):
	1 - раздел кастомного оружия;
	2 - коэффициент стоимости (допустимы значения float);
	3 - средний вес;
SetCustomWeaponAvailability - устанавливает место продажи кастомной пушки:
	1 - раздел кастомного оружия;
	2 - строка:
	  'Free' - оружие продаётся в любых магазинах;
	  'CoalitionOnly' - только на планетах/станциях Коалиции;
	  'PirateOnly' - только на пиратских планетах/станциях;
	  'MalocOnly' - только на малокских планетах/станциях;
	  'PelengOnly' - только на пеленгских планетах/станциях;
	  'PeopleOnly' - только на человеческих планетах/станциях;
	  'FeiOnly' - только на фэянских планетах/станциях;
	  'GaalOnly' - только на гаальских планетах/станциях;
	  'NotSold' - это оружие нельзя купить в магазинах;
	  'NotSoldAndNodeRepair' - это оружие нельзя купить в магазинах, а его ремонт доступен только за ноды;
SetCustomWeaponSE - устанавливает графические эффекты кастомного оружия:
	1 - раздел кастомного оружия;
	2 - анимация выстрела;
	3 - анимация сплэша;
	4 - анимация подрыва ракеты;
	5 - номер палитры для анимации выстрела;


Артефакты:
ShipArts - аналогично ShipItems, только для артефактов, т.к. они находятся на корабле отдельным списком, возвращает количество артов в трюме, или конкретный арт из трюма: 1 - корабль (возвращает количество), 2 (опционально) - номер арта в списке артов корабля (возвращает конкретный артефакт);
CreateArt - создаёт оригинальный артефакт:
  1 - тип артефакта;
  2 - раса-производитель;
CreateCustomArt - создаёт кастомный артефакт:
  1 - системное название кастомного артефакта (строкой);
  2 - размер;
  3 - цена;
  4 - раса-производитель;
CustomArtData - создаёт три поля для хранения переменных типа integer, с возможностью их подстановки в описание Data1, Data2, Data3: 1 - артефакт, 2 - номер поля (от 1 до 3), 3 - (опционально) какое значение установить;
CustomArtTextData - три поля для хранения текстовой инфы кастомного арта <TextDataN>, где N – номер поля: 1 - артефакт, 2 - номер поля (от 1 до 3), 3 (опционально) - какой текст установить;
ArtefactTypeInUse - возвращает количество экипированных на корабле и не сломанных артефактов определённого типа: 1 - корабль, 2 - тип артефакта или сам артефакт, тип которого нужно проверить (можно проверять кастомные типы);
  Примечание: При установленном Артефакторе, для "информационных" артефактов из трюма, вроде Биомира, эта функция также вернёт "true" во время событий t_OnEnteringForm и t_OnReEnteringForm, но не во время событий t_OnStep, что вообще нихера не удобно учитывать в коде, но просто примите как факт. Всякие Биомиры в трюме при установленном Артефакторе считаются рабочими только в тот момент, когда игрок захочет посмотреть свои статы. И, более того, с ТН на установку множества однотипных артефактов, при установке в слоты сразу двух Артефакторов, всякие Биомиры будут полноценно работать из трюма (увеличивать длительность действия стимуляторов) на постоянной основе, возвращая "true" даже во время t_OnStep.
ArtefactTypeBoosted - возвращает текущий статус совместимости (0/1) экипированных на корабле артефактов определённого типа: 1 - корабль, 2 - тип артефакта или артефакт, тип которого нужно проверить;
	Примечание: Под "совместимостью" понимается разблокировка дополнительных свойств артефакта, в случае наличия на корабле установленного "совместимого" с ним, то есть оборудования от неизвестного производителя (ItemOwner(item)==6). Пример: Железные жупи и корпус неизвестной расы.


Оружие:
WeaponTarget - возвращает или устанавливает цель орудия: 1 - орудие, 2 (опционально) - какую цель установить;
MissileType - возвращает тип оружия из, которого была выпущена данная ракета: 1 - ракета;
MissileOwner - возвращает или устанавливает выпустивший ракету корабль: 1 - ракета, 2 (опционально) - корабль, который будет считаться хозяином ракеты;
MissileTarget - возвращает или устанавливает цель ракеты: 1 - ракета, 2 (опционально) - новая цель ракеты;
SpawnMissile - спавнит ракету в системе:
	1 - система;
	2 - цель;
	3 - координата X;
	4 - координата Y;
	5 - угол нацеливания;
	6 - минимальный урон;
	7 - максимальный урон;
	8 - скорость;
	9 - оружие из которого стреляем (строка, например, t_Weapon4);
  Опционально:
	10 - акриновый бонус;
	11 - ММ бонус;
MissileLive - возвращает/изменяет время полёта ракеты/торпеды, по умолчанию составляющее 1000 (5 дней): 1 - ракета, 2 (опционально) - на какое значение изменить время полёта ракеты/торпеды;
  Пояснение: Изначальное время полёта ракеты составляет 0, а по достижению 1000, то есть 5 дней, ракета самоуничтожается. Функция MissileLive позволяет изменять это время, при этом значение, которое игрок устанавливает через функцию, будет отниматься от той самой 1000. Таким образом, если, например, задать MissileLive при запуске ракеты (событие t_OnMissileShot), то время полёта ракеты сместиться в минус и будет составлять 0-value, пример: при MissileLive(missile,200) на старте ракеты, её начальное время полёта уже будет составлять как бы 1 день (-200), как раз тот день, в который ракета вылетает из установки, набирает скорость и врубает самонаведение. То есть при MissileLive(missile,200) на старте, ракета вылетит из установки уже на максимальной скорости и моментально направится к цели. Учтите, что при данном подходе время реальной жизни ракеты после пуска также сократиться до 800 (4 дней).
  Если же устанавливать MissileLive для уже вылетевшей ракеты, то значение будет отниматься из фактически проделанного её пути, пример: ракета пролетела 3 дня, её срок жизни составляет 600, а установка MissileLive(missile,200) отнимет 200 из этого значения, по сути "омолодив" ракету на один день. Таким образом, можно продлять срок жизни нужной ракеты до бесконечности.
  Примечание: Выставлять отрицательное значение в функции MissileLive также возможно, но тогда ракета будет получать буст ко времени вывода на цель. То есть просто будет лететь по прямой на минимальной скорости, ни на что не реагируя. Подробно эту возможность не тестировал.
MissileSpeed - возвращает/устанавливает текущую скорость ракеты: 1 - ракета, 2 (опционально) - какую скорость установить;
MissileAngle - возвращает/устанавливает угол ракеты: 1 - ракета, 2 - значение;
LaunchMissile - добавляет дополнительные ракеты к залпу (только для типа 'Rocket');
WeaponAmmunition - возвращает/устанавливает текущее количество зарядов в ракетном оружии: 1 - оружие, 2 (опционально) - установить новое значение;
WeaponMaxAmmunition - возвращает/устанавливает максимальное число зарядов в ракетном оружии: 1 - оружие, 2 (опционально) - установить максимальное число зарядов;
MissileMaxDamage - возвращает/устанавливает макисмальный урон ракеты: 1 - ракета, 2 (опционально) - установить новое значение;
MissileMinDamage - возвращает/устанавливает минимальный урон ракеты: 1 - ракета, 2 (опционально) - установить новое значение;
MissileWeaponID - возвращает Id ракеты, который равен Id выпустившего ракету орудия (ракеты, рождённые через SpawnMissile, имеют нулевой Id);


Микромодули и акрины:
CreateMM - создаёт микромодуль в виде предмета и возвращает на него ссылку:
	1 - номер бонуса для создания ММ;
BonusCount - возвращает общее количество всех ММ и акринов в игре (а точнее всех загруженных в Галактику);
  Примечание: Оригинальные номера всех бонусов в Lang (в модах могут подставляться строкой, но в оригинале только цифры): от 0 до 545.
FindBonusByName - ищет по названию и при успехе возвращает номер бонуса:
	1 - название бонуса (при неудаче вернёт -1);
FindBonusByCustomTag - ищет бонус по особому тэгу (параметр CustomTag в разделе бонуса в Lang) и при успехе возвращает его номер:
	1 - тэг бонуса строкой (при неудаче вернёт -1);
FindBonusByNameInCfg - ищет бонус по имени его раздела в Lang (все разделы оригинальных бонусов имеют сугубо числовые имена), что делает эту функцию крайне полезной при поиске бонусов из оригинальной игры, которые, в своём большинстве, не имеют кастомных тэгов:
	1 - имя раздела бонуса в Lang (при неудаче вернёт -1);
  Важно! Внутренняя игровая нумерация бонусов автоматически выстраивается при запуске игры из всех бонусов в разделе MicroModuls. Данная нумерация никак не привязана к названиям разделов конкретных бонусов, так что называть это разделы можно как угодно, лишь бы для разных бонусов они не повторялись.
BonusNumInCfg - возвращает имя раздела Lang, в котором прописана информация о конкретном бонусе строкой:
	1 - номер бонуса;
BonusPriority - возвращает приоритет бонуса (от 0 до 100): 1 - номер бонуса;
	Priority - параметр для акриновых бонусов от 0 до 100, определяющий, на каком ГТУ акрин станет доступен для появления в игре. Определяется по формуле 8*N, где N - прописанный в Lang параметр Priority, умноженный на 0.01. Результат (например: 8 * 0.60 = 4.8) округляется всегда в большую сторону и означает точный ГТУ, с которого бонус станет доступным для наложения на предметы (в приведённом примере это будет 5 ГТУ).
  Отдельные (противоположные) значения данного параметра прописываются для микромодулей:
	0-30 - микромодуль первого уровня, цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
	31-69 - микромодуль второго уровня, цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
	70-100 - микромодуль третьего уровня, цифра приоритета (чем меньше, тем дороже) в данном диапазоне также определяет стоимость микромодуля в нодах и кредитах;
BonusIsSpecial - проверяет, что бонус это акрин:
	1 - номер бонуса;
BonusName - возвращает название бонуса:
	1 - номер бонуса;
BonusCustomTag - возвращает тэг акринового бонуса:
	1 - номер бонуса;
HullSpecial - возвращает/накладывает акрин на корпус (вернёт -1, если акрина нет):
	1 - сам корпус или использующий его корабль
  Опционально:
	2 - какой акрин наложить (-1 - снять акрин);
	  Примечание: Данная функция лишь добавляет корпусу бонус, но не меняет его тип на акриновый. Следовательно, при наложении акрина данной функцией на не акриновый корпус его внешний вид изменён не будет. То же самое касается и функции EqSpecial. Для полноценного наложения акрина на корпус используйте функцию SpecialToEquipment.
SpecialToEquipment - накладывает или снимает акрин с оборудования с учётом модификаторов на размер и стоимость (если прописаны в бонусе):
	1 - номер бонуса (если -1, то снять акрин);
	2 - оборудование (при повторной акринации акринированного предмета, наложит модификаторы размера и стоимости поверх уже изменённых статов);
ModuleToEquipment - аналогично SpecialToEquipment, только для установки/изъятия ММ, а также реально меняющая статы предмета согласно бонусу (нормальная установка ММ):
	1 - номер бонуса (если -1, то изъять ММ);
	2 - оборудование;
EqSpecial - возвращает (-1, если акрина нет), накладывает или снимает акрин с оборудования без учёта модификаторов на размер и стоимость:
	1 - оборудование;
  Опционально:
	2 - номер бонуса (если -1, то снять акрин);
EqModule - аналогично EqSpecial, только для проверки/установки/изъятия ММ, однако не меняющая статы предмета, но блокирующая дальнейшие улучшения на НБ (игра будет думать, что статы занижены относительно "нормального" бонусного значения):
	1 - оборудование;
  Опционально:
	2 - номер бонуса (если -1, то изъять ММ);
  Примечание: Если вам необходимо полностью заменить текст в карточке предмета с определённым акрином, то в разделе бонуса данного акрина необходимо использовать параметры TextReplace по числу оригинальных строчек Text данного предмета. В этом случае строчки с TextReplace автоматически заменят собой все оригинальные строчки Text. Также с помощью акрина имеется возможность добавить дополнительный текст в описание любого артефакта, для чего нужно просто добавить ему соответствующий акрин или спецакрин. Акрин не окажет на артефакт иного влияния, кроме замены текста.
ItemExtraSpecials - возвращает общее количество всех спецакринов на предмете или конкретный спецакрин:
	1 - предмет;
  Опционально:
	2 - номер спецакрина на предмете (вернёт спецакрин);
ItemExtraSpecialsCountByType - возвращает количество конкретных спецакринов на предмете:
	1 - предмет;
	2 - спецакрин, количество которых необходимо вернуть;
ItemExtraSpecialsAddByType - добавляет спецакрин на предмет:
	1 - предмет;
	2 - спецакрин;
  Опционально:
	3 - сколько указанных спецакринов добавить;
ItemExtraSpecialsDeleteByType - удаляет спецакрин с предмета:
	1 - предмет;
	2 - спецакрин;
  Опционально:
	3 - сколько указанных спецакринов удалить;
  Примечание: Фактически спецакрины ничем не отличаются от обычных, кроме способа наложения на предмет и возможностью накладывать сразу множество спецакринов, вместо одного основного. Количество одинаковых спецакринов на предмете хранится в виде числа, поэтому путём наложения нужного числа "пустых" спецакринов вы можете, фактически, записывать в любое оборудование числовую информацию. А для добавления дополнительного текста в карточку оборудования со спецакрином, в разделе бонуса этого спецакрина необходимо использовать параметры ExText, а не просто Text, как обычно.
MayAddBonusToEq - проверяет, можно ли установить бонус на указанное оборудование (учитываются тип и раса-производитель оборудования):
	1 - номер бонуса;
	2 - оборудование;
BuildListOfMMByPriority - записывает в массив список номеров бонусов ММ (бонусы с тэгом Special=1 микромодулями не считаются) в указанном диапазоне значений их приоритета, после чего возвращает размер получившегося массива, по умолчанию не добавляет ММ с установленным параметром RacialRestriction:
	1 - массив (будет очищен автоматически);
	2 - стартовый приоритет модулей для добавления;
	3 - конечный приоритет модулей для добавления;
	  Примечание: От того как вы расставите аргументы, от 100 до 0 или от 0 до 100 будет зависеть последовательность занесения модулей в массив. От 100 до 0 будут заноситься модули от худших (3-го уровня) до лучших (1-го уровня), и наоборот.
  Опционально:
	4 - маркер (0/1) для разрешения добавления в массив модулей с RacialRestriction;
SwitchToMirrorImage - используется для плавной смены анимации корабля/станции прямо на глазах у игрока:
	1 - корабль/станция;
	2 - номер акрина, на анимацию которого необходимо переключится (также будет заменён и сам корпусной акрин);
  Примечание: Если одна Hai анимация (Gai не подходит) использована сразу в нескольких корпусных акринах, и при этом в каждом акрине указан свой отдельный отрезок этой анимации, то при смене акрина корабля/станции на другой акрин с той же анимацией с помощью данной функции будет произведён плавный переход кадров (сперва завершится предыдущая анимация, а затем начнёт воспроизводиться следующая, уже с нового акрина). Если же переключать акрин корабля/станции на акрин, имеющий какую-то другую анимацию, то переход кадров будет резким, без плавного завершения предыдущей анимации (просто сразу же начнёт воспроизводиться анимация с нового акрина).
BonusText - возвращает описание из параметров Text указанного бонуса:
	1 - номер бонуса;
BonusValue - величина какого-то конкретного усиления/штрафа в бонусе:
	1 - номер бонуса;
	2 - значение какого усиления/штрафа вернуть (например, bonSpeed);


Операции с товарами:
UpsurgeGoods - на планете начинается распродажа определённого товара (если указанный товар закончился, может автоматически подкинуть на склады ещё 200-300 единиц, пока продолжается распродажа), автоматически отменяет его дефицит, если он есть:
	1 - планета;
	2 - тип товара;
DecayGoods - на планете начинается дефицит определённого товара, автоматически отменяет его распродажу, если она есть:
	1 - планета;
	2 - тип товара;
GoodsRuinsForBuy - станция предлагает много определённого товара по дешёвке:
	1 - станция;
	2 - тип товара;
PlanetSetGoods - устанавливает количество определённого товара на планете:
	1 - планета;
	2 - тип товара;
	3 - какое количество установить;
GoodsAdd - добавляет некоторое количество определённого товара в магазин (возвращает общее количество товара после изменения):
	1 - планета или станция;
	2 - тип товара;
	3 - на сколько изменить количество товара в магазине (если подставить 0, то вернёт имеющееся количество без изменения);
ShipGoods - аналог GoodsAdd, но для трюма корабля (возвращает общее количество товара после изменения):
	1 - корабль;
	2 - тип товара;
	3 - на сколько изменить количество товара в трюме (если подставить 0, то вернёт имеющееся количество без изменения);
  Опционально:
	4 - какую стоимость установить данному товару (по умолчанию выставляет среднюю галактическую);
GoodsCount - возвращает количество определённого товара в трюме корабля:
	1 - корабль;
	2 - тип товара;
GoodsDrop - заставляет корабль выбросить товар:
	1 - корабль (не работает с кораблём игрока);
	2 - тип товара;
	3 - сколько выбросить;
  Опционально:
	4 - скриптовый объект (выброшенный товар будет занесён в указанный скриптовый объект);
GoodsSellPrice - цена, за которую планета продаёт определённый товар:
	1 - планета;
	2 - тип товара;
GoodsBuyPrice - цена, за которую планета покупает определённый товар:
	1 - планета;
	2 - тип товара;
CreateGoods - создаёт товар:
	1 - тип товара;
	2 - количество;
ShipGoodsIllegalOnPlanet - проверяет легальность определённого товара на планете для конкретного корабля:
	1 - корабль;
	2 - тип товара;
	3 - планета;


Оборудование и корабль (характеристики и параметры):
BuildListOfNewShips - делает перебор Галактики и заполняет массив только кораблями и станциями, родившимися с определённого момента, а в случае, если таковых нет, оставит массиву один пустой элемент. Функция заполняет массив, начиная с элемента под нулевым номером, и в конце возвращает число записанных в массив кораблей (при отсутствии таковых вернёт 0):
	1 - массив для заполнения (будет очищен автоматически);
	2 - Id самого старого корабля, с которого начнётся занесение новых кораблей в массив;
  Опционально:
	3 - сет номерных типов кораблей (если 0 или отсутствует, то ищет всех, кроме транклюкаторов, т.к. искать последних для хардкода трудоёмко):
		t_Kling - 1
		t_Ranger - 2
		t_Transport - 4
		t_Pirate - 8
		t_Warrior - 16
		t_Tranclucator - 32
		t_RC - 64
		t_PB - 128
		t_WB - 256
		t_SB - 512
		t_BK - 1024
		t_MC - 2048
		t_CB - 4096
		t_UB - 8192
	4 - сет рас (если 0 или отсутствует, то ищет всех):
		Maloc - 1
		Peleng - 2
		People - 4
		Fei - 8
		Gaal - 16
		Kling - 32 (доминаторы)
		None - 64 (неизвестная раса)
		PirateClan - 128
	5 - добавлять 1 или нет 0 скриптовые корабли (корабли с OrderLock будут также считаться скриптовыми);
	6 - фильтр кастомных фракций вида: 'S1,S2,S3' в котором пустая строка '' будет считаться как фильтр на добавление кораблей без кастомной фракции (можно также составить фильтр вида ',S1,S2');
	7 - фильтр строковых типов кораблей (ShipType), работающий аналогично фильтру фракций: ',Ranger,Pirate,Klissan';
  Важно: При установке строкового фильтра, все оригинальные корабли будут проходить в нём под значением ''. То есть если вы не хотите исключать оригинальные типы кораблей, обязательно оставьте в вашем фильтре место под пустую строку: '', 'CustomType1,,CustomType2' или ',CustomType1,CustomType2'
ShipSpeed - возвращает текущую скорость корабля: 1 - корабль;
ShipFuel - возвращает и устанавливает количество топлива в установленном топливном баке: 1 - корабль, 2 (опционально) - какое количество топлива установить, если количество топлива изменено, то вернёт количество до изменения;
ShipFuelLow - проверяет, не отсутствует ли на корабле топливный бак, или количество топлива в нём меньше максимального: 1 - корабль;
  Игровая формула расчёта стоимости топлива:
	За основу берётся текущий ход, а оригинальная формула имеет вид: Количество*PortionInDiapason(Galaxy.FTurn,1000,15000,1,10);
	Это означает, что для хода 1000 и ниже - стоимость единицы топлива составит 1 кредит, а для хода 15.000 и выше - 10 кредитов. Весь диапазон цены между данными значениями (от 1 до 10 кредитов) меняется линейно.
	Далее, на полученный округлённый результат, от стоимости общего количества пополняемого топлива, накладываются модификаторы. Модификатор расы накладывается, только если игрок заправляется на планете, а модификатор сложности накладывается в любом случае. Вне зависимости от результатов вычислений, одна единица топлива не может стоить дешевле 1 кредита. Округление итогового значения осуществляется, как обычно, функцией round(), в самом конце расчетов и после наложения всех возможных модификаторов.
  Модификаторы от расы планеты:
	0 (малоки) - 0.7;
	1 (пеленги) - 0.9;
	2 (люди) - 1.0;
	3 (фэяне) - 1.15;
	4 (гаальцы) - 1.30;
	7 (пираты) - 0.8;
  Модификаторы от сложности настройки удачи GalaxyDiffLevels(7):
     -30% на сложности 50%;
	   0% на сложности 100%;
     +30% на сложности 150%;
     +60% на сложности 200%;
     +90% на сложности 250%;
	+120% на сложности 300%;
	+150% на сложности 350%;
	+180% на сложности 400%;
	+210% на сложности 450%;
	+240% на сложности 500%;
ShipCntWeapon - количество экипированных на корабле пушек:
	1 - корабль;
ShipWeapon - возвращает экипированное на корабле орудие:
	1 - корабль;
	2 - номер орудийного слота (1-5);
ShipEqInSlot - возвращает установленное в слоте оборудование/оружие:
    1 - корабль;
    2 - тип слота:
	  t_Artefact - слот артефакта;
	  t_Hull - слот корпуса;
	  t_FuelTanks - слот топливного бака;
	  t_Engine - слот двигателя;
	  t_Radar - слот радара;
	  t_Scaner - слот сканера;
	  t_RepairRobot - слот дроида;
	  t_CargoHook - слот захвата;
	  t_DefGenerator - слот ГЗП;
	  t_Weapon1 - орудийный слот;
  Опционально:
    3 - номер слота (для оружия 1-5, для артефактов 1-4);
  Примечание: Не пользуйтесь прямой нумерацией при указании слотов/типов оборудования, т.к. при её смещении (в связи с обновлениями хардкода) в коде появится неочевидная ошибка. Вместо этого используйте общие переменные типа t_Engine.
EnginePower - возвращает перегрев двигателя (от 0 до 100): 1 - конкретный двигатель или корабль, 2 (опционально) - какое значение перегрева установить;
ShipJump - возвращает расстояние максимального прыжка корабля (только по двигателю!) с учётом всех бонусов: 1 - корабль;
ShipArmor - возвращает броню корабля с учётом всех бонусов: 1 - корабль;
ShipProtectability - возвращает % блокировки урона ГЗП корабля с учётом всех бонусов: 1 - корабль;
ShipDroidRepair - возвращает эффективность дроида корабля с учётом всех бонусов: 1 - корабль;
ShipRadarRange - возвращает радиус радара корабля с учётом всех бонусов: 1 - корабль;
ShipScanerPower - возвращает мощность сканера корабля с учётом всех бонусов: 1 - корабль;
ShipHookPower - возвращает мощность захвата корабля с учётом всех бонусов: 1 - корабль;
ShipHookRange - возвращает радиус захвата корабля с учётом всех бонусов: 1 - корабль;
ShipAverageDamage - возвращает средний урон корабля по одной цели с учётом всех орудий и всех бонусов: 1 - корабль, 2 (опционально): 0 - средний минимальный урон, 1 - средний максимальный урон;
ShipOwner - возвращает или устанавливает расу корабля (но не пилота):
	1 - корабль
  Опционально:
	2 - на какую расу заменить:
	  0 или 'Maloc' - малок;
	  1 или 'Peleng' - пеленг;
	  2 или 'People' - человек;
	  3 или 'Fei' - фэянин;
	  4 или 'Gaal' - гаалец;
	  5 или 'Kling' - доминатор;	  
	  6 или 'None' - неизвестный;
	  7 или 'PirateClan' - клановый пират;
OrderForsage - проверяет не влючен ли у корабля форсаж, либо включает/выключает его: 1 - корабль, 2 (опционально) - если значение больше 0, то включить форсаж;
HullHP - возвращает или устанавливает запас прочности корпуса: 1 - сам корпус или корабль, использующий этот корпус, 2 (опционально) - какое количество HP установить корпусу;
HullDamage - возвращает процент повреждений корпуса корабля (от 0 до 100, где 0 - полностью целый корпус): 1 - корабль;
Hitpoints - возвращает текущий запас прочности корпуса корабля: 1 - корабль;
HullDamageSuspectibility - возвращает восприимчивость корпуса к урону: 1 - корпус/корабль, 2 - тип воспримчивости (0 - En, 1 - Sp, 2 - Mi или дамагсет для автоматического определения "входящего" урона);
ShipSlots - возвращает количество открытых слотов определённого типа в корпусе корабля (с учётом всех применённых штрафов и бонусов): 1 - корабль, 2 - номер типа слота:
  1 - st_Weapon;
  2 - st_Artefact;
  3 - st_Radar;
  4 - st_Scaner;
  5 - st_RepairRobot;
  6 - st_CargoHook;
  7 - st_DefGenerator;
  8 - st_Forsage;
ShipRefuel - восполняет запас топлива в установленном баке корабля до максимума: 1 - корабль;
ShipRepairEq - полностью чинит всё установленное на корабле оборудование (но не структуру корпуса и артефакты): 1 - корабль;
ShipImproveItems - улучшает оборудование на корабле: 1 - корабль, 2 - сколько раз улучшить (один заход на корабль - улучшение одного случайного предмета или вставка в него случайного ММ);
ItemImprovement - проверяет улучшен ли предмет или улучшает его: 1 - предмет (проверяет), 2 (опционально) - степень улучшения (0 - стажёры, 1 - обычные спецы, 2 - лучшие спецы, >= 3 случайные спецы), 3 - упор в параметр, если предмет имеет не одну характеристику (0 - рандом, 1 - первая характеристика, 2 - вторая характеристика);
ItemCanBeBroken - проверяет есть ли у предмета шкала износа: 1 - предмет;
ItemDurability - возвращает текущий износ предмета в проценатх (от 0 до 100, где 0 полностью изношенный предмет) или устанавливает этот процент: 1 - предмет, 2 (опционально) - какой процент износа установить;
ItemLevel - возвращает\устанавливает ТУ оборудования: 1 - оборудование (корпус в том числе), 2 (опционально) - какой ТУ установить (от 1 до 8);
MissilesToRearm - возвращает сколько зарядов не хватает ракетному оружию до полного комплекта или пополняет боезапас: 1 - оружие, 2 (опционально) - на сколько пополнить боезапас (для разрядки орудия нужно указать отрицательное значение);
  Стоимость пополнения одного заряда (любого) зависит от ГТУ (сама функция MissilesToRearm деньги не списывает):
	ГТУ 1 - 10 cr.
	ГТУ 2 - 10 cr.
	ГТУ 3 - 28 cr.
	ГТУ 4 - 46 cr.
	ГТУ 5 - 64 cr.
	ГТУ 6 - 82 cr.
	ГТУ 7 - 100 cr.
	ГТУ 8 - 100 cr.
ShipSpecialBonuses - возвращает величину акринового бонуса определённого типа для указанного корабля или устанавливает эту величину:
	1 - корабль;
	2 - тип бонуса числом (пример: bonSpeed - это игровая числовая переменная);
	3 (опционально) - какое значение бонуса установить (это значения дополнительных скриптовых бонусов на весь корабль, а не тех, что даются акриновым оборудованием);


Задания:
StartTextQuest - начать ТК: 1 - имя квеста строкой, 2 - текст при победе, 3 - текст при поражении;
StartRobots - запускает ПБ:
	1 - название файла карты ПБ вместе с расширением (пример: 'SeaBattle.cmap');
	2 - стартовый текст;
	3 - текст при победе;
	4 - текст при поражении;
  Опционально:
	5 - место проведения строкой (на случай, если в текстах используется подстановка названия планеты);
	6 - дополнительные настройки строкой (подставлять можно и в виде числа) из трёх цифр вида '621':
	  Первая цифра - раса правителя в текстовых сообщениях (по умолчанию 6):
	    1 - малоки;
		2 - пеленги;
		3 - люди;
		4 - фэяне;
		5 - гаальцы;
		6 - без портрета;
	  Вторая цифра - сложность карты (по умолчанию 2):
	    1 - 50%;
		2 - 100%;
		3 - 150%;
		4 - 200%;
	  Третья цифра - дополнительный бонус (по умолчанию 1):
	    1 - без бонуса;
		2 - поддержка с воздуха;
		3 - усиленная броня;
  Примечание: Оригинальные номера карт в Lang: с 01 по 74 с учётом пиратских сюжетных.
MarkRobotsMapAsUsed - помечает конкретный планетарный бой, как уже выполненный игроком: 1 - имя карты (пример: 'something.cmap'), 2 (опционально) - маркер для ресета таймера выдачи ПБ (чтобы в правительстве в тот же ход не выдавали задание на новый бой);
 Примечание: Для карт, имеющих возможность повторного прохождения за игру (параметр Reiteration), необходимо запускать MarkRobotsMapAsUsed несколько раз. Столько, сколько указано в Reiteration, так как один запуск этой функции равен одному прохождению конкретной карты.
PlayerQuestInProgress - проверяет есть ли у игрока неоконченные правительственные задания;
BuildListOfQuestPossibleLocations - записывает в массив список коалиционных систем, находящихся на определённом расстоянии от указанной системы пропускает системы, где идет бой или куда летят доминаторы: 1 - массив для записи результатов (будет очищен автоматически), 2 - система, 3 - минимальное расстояние, 4 - максимальное расстояние;


Деньги:
GalaxyMoney - возвращает текущую среднюю галактическую сумму денег (результат пропорционален среднему капиталу рейнджеров), условно заданную разработчиками в градациях от незначительной до огромной:
	1 - размер суммы:
	  0 - Galaxy.MiniMoney(own);
	  1 - Galaxy.SmallMoney(own);
	  2 - Galaxy.AverageMoney(own);
	  3 - Galaxy.BigMoney(own);
	  4 - Galaxy.HugeMoney(own);
	2 (опционально) - модификатор расы, от малоков (минимальный модификатор) до гаальцев (максимальный модификатор), по умолчанию выставлен на людей;

function TGalaxy.MiniMoney(Owner:TOwner=People):integer;
begin
  Result:=Round(FRangersAverageCapital * kMoneyMini * mOwner[Owner].kMargin);
  if Result>MiniItemCost then Result:=MiniItemCost+Round((Result-MiniItemCost)*0.3);
end;

  kMoneyMini    = 1 / 100;
  kMoneySmall   = 1 / 65;
  kMoneyAverage = 1 / 40;
  kMoneyBig     = 1 / 25;
  kMoneyHuge    = 1 / 15;

  MiniItemCost    = 000250;
  SmallItemCost   = 001000;
  AverageItemCost = 005000;
  BigItemCost     = 010000;
  HugeItemCost    = 025000;

FirstGiveMoney - возвращает деньги игрока на момент старта игры;
ShipMoney - возвращает и устанавливает (опционально) текущее количество денег корабля: 1 - корабль, 2 (опционально) - какое количество денег установить, если количество денег изменено, то вернёт количество денег до изменения;
RangersCapital - возвращает суммарный общегалактический капитал всех рейнджеров (используется во многих внутриигровых расчётах), аргументов нет;
ShipWealth - возвращает текущий капитал конкретного корабля: 1 - корабль, капитал состоит из:
  - Текущая наличность;
  - Стоимость оборудования на корабле;
  - Стоимость оборудования на складах;
  - Депозит;
PlayerDebt - возвращает или устанавливает долг игрока по кредиту: без аргумента - возвращает долг игрока, 1 (опционально) - установить сумму долга (1 или 0);
PlayerDebtDate - возвращает или устанавливает дату возврата кредита: без аргумента - возвращает дату, 1 (опционально) - устанавливает дату;
PlayerDebtCnt - возвращает или устанавливает количество просрочек по кредитам: без аргумента - возвращает количество, 1 (опционально) - устанавливает количество;
PlayerDeposit - возвращает или устанавливает изначальную (целую) сумму на депозите игрока: без аргумента - возвращает сумму, 1 (опционально) - какую сумму установить;
PlayerDepositDate - возвращает или устанавливает дату открытия депозита: без аргумента - возвращает дату, 1 (опционально) - устанавливает дату;
PlayerDepositDay - возвращает или устанавливает сколько дней прошло с открытия депозита: без аргумента - возвращает количество дней, 1 (опционально) - устанавливает количество дней;
  Примечание: Дни, в которые процент находился под кредитной заморозкой, игра вычитает автоматически.
PlayerDepositPercent - возвращает или устанавливает % депозита: без аргумента - возвращает процент (в виде целого, например 30, которое следует понимать как 3.0%), 1 (опционально) - устанавливает процент (также в виде целого);
  Примечание: Сам по себе депозит является статичной переменной integer, а накопленный процент рассчитывается только при запросе к этому числу. Если вы собираетесь самостоятельно менять сумму на депозите, то необходимо сперва рассчитать накопленный процент по оригинальной игровой формуле: round(FDeposit * Power(1 + 0.01 * FDepositPercent / BKkDepositPercentPeriod, FDepositDay / 365 * BKkDepositPercentPeriod)) - где функция Power - это возведение первого аргумента X в степень второго Y (скриптовыми функциями может быть записана как exp(Y*ln(X))). После этого необходимо изменить сумму депозита с учетом процента, и под конец переустановить дату открытия счёта на день его изменения.
  Пример готовой кастомной функции расчёта процентов в скрипте мода ExpBK:
  //Функция расчёта накопленных процентов для текущего состояния депозитного счёта
  function DepositPercentCalc()
  {
	temp_float=1.0+0.0001*PlayerDepositPercent()/12;//Считаем X
	temp_float=exp((1.0*PlayerDepositDay()/365*12)*ln(temp_float));//Считаем Y и возводим X в степень Y
	result=round(temp_float*PlayerDeposit());//Применяем получившийся процент к сумме на счету и округляем результат
  }


Здоровье:
ShipHealthFactor - возвращает/устанавливает срок действия болезни/стимулятора:
	1 - корабль, либо 0, если нужно просто вернуть стандартную длительность для данного типа болезни/стимулятора;
	2 - № болезни/стимулятора;
  Опциональные:
	3 - какой срок установить (число ходов), либо установить стандартную длительность для данного типа болезни/стимулятора (если подставлен -1);
PlayerMedPolicy - возвращает или устанавливает количество дней до завершения действия медицинского полиса у игрока: без аргументов - возвращает количество дней, 1 (опционально) - устанавливает количество дней;
ShipHealthFactorStatus - возвращает срок болезни (вирусный период): 1 - корабль, 2 - тип болезни, 3 (опционально) - какой вирусный период установить (0 - нету вируса, 1-99 есть вирус, 100 - полноценная болезнь (Чекумаш, Слепота и Святой фанатизм моментально накидываются на игрока при любом положительном значении вируса, но только при нахождении корабля на планете);
PlayerImmunity - текущая устойчивость (иммунитет) игрока к болезням (меняется со временем и при лечении на МЦ), 0 - минимум, 100 - максимум: 1 - какое значение установить;
Номера болезней:
  0 - Лучевая болезнь (все расы: снижает получаемый опыт (штраф накапливается, но если повесить болезнь скриптом, то будет составлять 50%));
    Примечание: Лучевая болезнь больше не применяется в КР:HD.
  1 - Ослепление (все расы: делает все силуэты космических объектов полупрозрачными, точность, манёвренность, техника и торговля по -3);
  2 - Чекумаш (все расы: появляются различные глюки в космосе);
  3 - Святой фанатизм (все расы: все корабли и оборудование начинают казаться доминаторскими, точность и манёвренность по +1, обаяние -1, лидерство +2);
  4 - Комплексный иммуноцид (все расы: практически моментальное заражение чем угодно, если в организм попадёт вирус);
  5 - Загадочная луатанция (все расы: невозможность заниматься рэкетом, периодические выплаты из фонда (только для игрока), точность -2, обаяние +3);
  6 - Наркозависимость (все расы: повышает износ оборудования в 2 раза (только для игрока), точность и манёвренность по -3, техника -2);
  7 - Вихревая контузия (все расы: накладывает скрытый дебаф* (только для игрока), точность -2, манёвренность -5, торговля -10);
  8 - Мышечное растяжение (все расы: накладывает скрытый дебаф* (только для игрока), точность, манёвренность и торговля по -2, обаяние и лидерство по -1);
  9 - Великий Малососус (только малоки: увеличивает массу корабля на 20% (только если заболевший - малок, но иное в нормальных условиях и невозможно), лидерство и торговля по +3);
  10 - Горькая пеленоша (только пеленги: повышает износ оборудования в 3 раза (исключая износ в бою) и накладывает скрытый дебаф* (только для игрока), техника -10);
  11 - Ака Сециянка (только фэяне: шанс случайных дропов товара из трюма в космосе (только для игрока), точность -1, техника -2, торговля +2);
  12 - Новый молизон (только гаальцы: торговля медикаментами и едой на планетах считается контрабандой, точность и манёвренность по +1);
Номера стимуляторов:
  13 - Малокская сижа (точность +4, манёвренность +3);
  14 - Одноглазый Хамас (любой рэкет всегда будет успешен (только для игрока), обаяние и лидерство по -1);
  15 - Звёздная пыль (точность, манёвренность, техника и торговля по +1);
  16 - Супер техник (снижает износ оборудования на 60% (только для игрока), техника +5);
  17 - Гаалистра времени (повышает скорость корабля на 30%, точность +4, манёвренность +2);
  18 - Кровяной джогар (повышает иммунитет);
  19 - Рагобамский шёпот (обаяние +10 (а ещё можно есть рагобамских жаб, лол));
  20 - Ведущий Шахманду (увеличивает срок найма других кораблей в 2 раза (только для игрока), обаяние +1, лидерство +4);
  21 - Психотропный кэш (увеличивает дальность радара в 2 раза (только для игрока), мощность сканера +12, обаяние -3);
  22 - Торговая маркировка (увеличивает получаемый торговый опыт в 1,5 раза (для игрока, транспортов и рейнджеров), торговля +8);
  23 - Дубльплекс (увеличивает награду за правительственные задания в 1.3 - 2.3 раза (только для игрока), точность и манёвренность по -1);
  24 - Абсолютный статус (сроки исполнения правительственных заданий становятся в 1,5 раза мягче (только для игрока), обаяние +2);
    *Важно: Если игрок (и только игрок) болеет вихревой контузией, мышечным растяжением или горькой пеленошей (эффект не суммируется), то наносимый им урон получает скрытый дебаф и случайно умножается (в момент атаки) на значение от 0% до 100%.


Ход (даты):
GameDateTxtByTurn - возвращает строку с датой указанного хода (к примеру - 21 апреля 3301): 1 - ход;
CurTurn - без аргументов, возвращает текущий ход: 1 (опционально) - установить номер хода;
ForceNextDay - без аргументов, принудительный запуск следующего хода;
IsFilm - проверяет проигрывается ли сейчас отображение хода (т.е. летают/стреляют ли по экрану корабли), если летают, то операции со сменой шкурок могут работать некорректно
(а могут и корректно, после последнего рефакторинга, но я не проверял);
FilmFlags - проверяет и выставляет различные условия для автоматического прерывания фильма (отображения хода) между ходами:
	1 - тип флага, либо система, в которой нужно его установить (систему имеет смысл ставить лишь ту, в которой находится игрок, так что её указывать не обязательно);
	2 - включить/выключить флаг (0 или 1), либо тип флага;
	3 - только включить/выключить флаг (0 или 1);
  Примеры:
	- FilmFlags(N) - проверяет установленный флаг (N в данном случае пустые скобки по идее);
	- FilmFlags(N,val) - устанавливает нужный флаг на следующий ход, например FilmFlags(3,1);
	- FilmFlags(star,N) - аналогично проверяет флаг, но для определённой системы;
	- FilmFlags(star,N,val) - устанавливает флаг для определённой системы;
  Типы флагов:
	0 FilmBuild, film is being made for this star, can't set value
	1 - данный флаг прерывает фильм с началом боевых действий (игрок получил урон, либо нанёс урон сам);
	2 - данный флаг прерывает фильм если игрок подобрал предмет, форсаж износил двигатель ниже предельно допустимого значения, либо другой NPC инициировал разговор с игроком;
	3 - данный флаг не прерывает фильм вообще никогда (не используется в оригинальной игре);
	Все значения флагов проверяются кодом в конце хода и автоматически сбрасываются с началом следующего. То есть если вам нужен непрерывный полёт корабля из точки А в точку Б, то нужно будет каждый ход задавать глобальный (или конкретно для данной системы) флаг типа 3. Любой из установленных флагов сам игрок может прервать нажатием кнопки "Конец хода";
	//star - no reason normally to set flags 1..3 for stars other than player's location, but can be used to skip checking

Транклюкаторы:
UseTranclucator - активирует и возвращает адрес одного транклюкатора на любом корабле: 1 - корабль (корабль, запустивший транклюкатора, автоматически становится его хозяином), 2 (опционально) - артефакт-транклюкатор, который нужно активировать;
PlayerTranclucators - возвращает количество активных транклюкаторов игрока, или корабль конкретного активного транклюкатора:
	Без аргументов - возвращает количество;
  Опционально:
	1 - номер транклюкатора, начиная с 0;
!!!Для возврата конкретного транка функция PlayerTranclucators делает перебор всех кораблей в Галактике. Имейте это ввиду, когда будете работать над оптимизацией кода!!!
ArtTranclucatorToShip - возвращает корабль транклюкатора из артефакта: 1 - артефакт (неактивный транклюкатор);
TranclucatorData - возвращает или устанавливает определённый параметр транклюкатора: 1 - транклюкатор, 2 - параметр (строкой или номером), 3 (опционально) - новое значение параметра;
  Параметры:
	0 или 'Proprietor' - хозяин транклюкатора;
	1 или 'ArtSize' - размер артефакта, в который превратится транклюкатор после сворачивания;
	2 или 'ArtSysName' - системное имя артефакта, в который превратится транклюкатор после сворачивания;
	3 или 'Docking' - маркер (0/1), при котором транклюкатор, имеющий приказ простого следования, залетит в трюм после сближения с хозяином;
	4 или 'SeekItems' - маркер, при котором транклюкатор будет заниматься сбором вещей;
	5 или 'AutoArrange' - маркер, при котором транклюкатор будет автоматически менять оборудование на более качественное из своего трюма;
	6 или 'LandStorage' - маркер, при котором транклюкатор после совершения посадки на любую планету или станцию, автоматически свернётся на склад в виде артефакта;
	7 или 'LandPermitPlanets' - маркер, при котором транклюкатору разрешены автоматические посадки на планеты при сборе вещей;
	8 или 'LandPermitRuins' - маркер, при котором транклюкатору разрешены автоматические посадки на станции при сборе вещей;
	9 или 'SeekPermitNone' - маркер, при котором транклюкатору разрешён сбор зондов, цистерн, карт сокровищ и корпусов (в оригинальной игре не используется);
	10 или 'SeekPermitArtefact' - маркер, при котором транклюкатору разрешён сбор артефактов (в т.ч. кастомных);
	11 или 'SeekPermitMicromodule' - маркер, при котором транклюкатору разрешён сбор микромодулей;
	12 или 'SeekPermitEquipment' - маркер, при котором транклюкатору разрешён сбор оборудования;
	13 или 'SeekPermitUseless' - маркер, при котором транклюкатору разрешён сбор ошмётков и прочих "юзлесов";
	14 или 'SeekPermitGoods' - маркер, при котором транклюкатору разрешён сбор товаров;
	15 или 'SeekPermitNode' - маркер, при котором транклюкатору разрешён сбор нодов и кастомных сыпучих;


Чёрные дыры:
GABStatus - общая глобальная переменная, отвечающая за заказ скриптами аркадных боёв, значения:
	0 - АБ не заказан ни одном скриптом;
	1 - какой-то скрипт заказал АБ;
	2 - заказанный АБ завершён и заказавший его скрипт получает внеплановое срабатывание тернкода (сразу же в день завершения АБ, а не в день вылета игрока из ЧД/гипера);
  Примечание: По умолчанию тернкод во всех скриптах срабатывает перед началом АБ для игрока, так что можно поймать любой "залёт" в ЧД проверкой функции ShipInHole().
HoleCreate - создаёт и возвращает чёрную дыру:
	1 - место для создания входа в ЧД;
	2 - место для создания выхода из ЧД, тип места должен быть Free, Near Planet, To Star, From Group;
HoleCreate2 - создаёт и возвращает чёрную дыру по упрощённой схеме, если нет необходимости задавать её точные координаты:
	1 - система со входом в ЧД;
	2 - система с выходом из ЧД, остальное будет подобрано случайно (возвращает созданную ЧД);
HoleMap - возвращает или устанавливает карту аркадного боя для ЧД:
	1 - чёрная дыра;
  Опционально:
	2 - путь и название карты АБ ('ABMap.Map_name'), либо особый маркер:
	  'SkipAB' - автоматически пропустит аркадный бой при влёте игрока в данную ЧД;
	  'NoEntry' - запрещает игроку вход в данную ЧД, а также такая ЧД будет невидима на карте;
HoleTurnCreate - возвращает или устанавливает ход создания ЧД (фактически определяет день, когда она закроется):
	1 - чёрная дыра;
  Опционально:
	2 - какой ход создания установить;
  Примечание: Срок жизни обыкновенной ЧД (по умолчанию) составляет 200 дней со дня открытия.
HoleStar1 - возвращает или устанавливает систему со входом в конкретную ЧД: 1 - ЧД, 2 (опционально) - система, куда переместить точку входа;
HoleStar2 - возвращает или устанавливает систему с выходом из конкретной ЧД: 1 - ЧД, 2 (опционально) - система, куда переместить точку выхода из ЧД;
StarHoles - возвращает количество ЧД в системе, или конкретную ЧД из этого списка: 1 - система, 2 (опционально) - номер ЧД в списке;
GalaxyHoles - возвращает количество ЧД в галактике, либо конкретную ЧД из этого списка, без аргументов возвращает количество: 1 - номер ЧД в списке, вернёт конкретную ЧД;
HoleX1 - возвращает или устанавливает X координату входа в ЧД: 1 - ЧД, 2 (опционально) - новая X координата;
HoleY1 - возвращает или устанавливает Y координату входа в ЧД: 1 - ЧД, 2 (опционально) - новая Y координата;
HoleX2 - возвращает или устанавливает X координату выхода из ЧД: 1 - ЧД, 2 (опционально) - новая X координата;
HoleY2 - возвращает или устанавливает Y координату выхода из ЧД: 1 - ЧД, 2 (опционально) - новая Y координата;


Аркадный бой (все функции из данного списка применяются из тернкода, в момент влёта игрока в ЧД):
CreateABShip - создаёт (и возвращает указатель для изменения модификаторов) стандартный корабль для аркадного боя:
	1 - путь к анимации корабля в 'Main.dat\Data\SE' (например, 'Ship.Fei.Liner' создаст в АБ фэянский лайнер, а 'Ruins.Blazer' – Блазера);
  Опционально:
	2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
	3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
	4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
	5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
	6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ConvertToABShip - создаёт (и возвращает указатель для изменения модификаторов) корабль для АБ по шаблону реального игрового корабля:
	1 - корабль-шаблон;
  Опционально:
	2 - на чьей стороне будет сражаться корабль (1 - союзники игрока, 0, 2, 3, 4 и т.д. - враждебные игроку стороны);
	3 - процентный модификатор максимального количества HP корабля (по умолчанию 100%);
	4 - процентный модификатор наносимых повреждений (по умолчанию 100%);
	5 - строковая метка для корабля (чтобы можно было отследить его уничтожение/выживание через галактические события LabeledShipKilledInAB/LabeledShipSurvivedInAB);
	6 - что выпадет из этого корабля при его уничтожении, указатель на предмет, либо -1, чтобы задать стандартный дроп, как в оригинальной игре (по умолчанию не падает ничего);
ABShipModifiers - возвращает или устанавливает кораблю модификаторы для аркадного боя:
	1 - корабль;
	2 - модификатор строкой:
	  'damage' - наносимый урон (базовое значение 100);
	  'recharge' - скорость перезарядки орудий (базовое значение 100);
	  'speed' - скорость корабля (базовое значение 100);
	  'gravity' - то, как сильно на корабль будут действовать различные притягивающие объекты (базовое значение 100);
	  'regen' - скорость восстановления здоровья (базовое значение 0);
	    - Дроид младший: +100 (за каждого младшего дроида в слоте);
		- Бонус-аптечка: +1000;
		  Примечание: Все перечисленные бонусы суммируются;
	  'fragility' - модификатор получаемого урона (базовое значение 100);
	  'luck' - шанс выпадения вещей из противников (базовое значение 100);
  Опционально:
	3 - какое значение установить (в теории принимает даже отрицательные значения, но как с ними будет работать код АБ неизвестно);
  Примечание: В обычной ситуации менять модификаторы можно самому игроку по событию t_OnStartAB или кораблям, создаваемым функцией CreateABShip. Однако, принимать в качестве корабля указатель на игрока (Player()) функция  может в любой момент, но если игрок при этом не находится в ЧД (или не сработало t_OnStartAB), то изменить модификатор она не сможет (вернёт 0). Может быть полезно для того, чтобы менять игроку модификатор от кастомного артефакта уже в процессе идущей аркадной битвы, если, например, игрок решит его снять или надеть.
StartAB - запускает аркадный бой с установленными выше условиями:
	1 - имя АБ карты, номер или строка пути в CacheData вида 'ABMap.Map_name';
  Опционально:
	2 - используемый фон в виде номера (от 1 до 4, где 4 - небесный фон) или полный адрес в CacheData строкой;
  Примечание: После вызова данной функции, стандартный заданный игрой бой в ЧД будет заменён на установленный игроком вариант, с учётом всех созданных ранее АБ кораблей и применённых модификаторов. Данная функция запускает аркадный бой, попутно выставляя маркер GABStatus=1, так что все настройки этого боя должны быть заданы непосредственно перед вызовом функции.


Операции с нодами:
CreateNodes - создаёт ноды и возвращает ссылку на них:
	1 - количество;
  Опционально:
	2 - серия доминатора (0 - 2);
	3 - вид в космосе (0 - контейнер, 1 - ноды);
GetNodesFromShip - возвращает общее количество нодов на корабле или удаляет некоторое их количество:
	1 - корабль (возвращает количество);
	2 (опционально) - сколько нодов изъять;
GetNodesFromStorage - возвращает общее количество нодов на складе или удаляет некоторое их количество:
	Без аргументов - возвращает общее количество на всех складах;
	1 - планета или база, возвращает количество на конкретной базе/планете;
	2 (опционально) - сколько нодов изъять со склада планеты/базы;
RangerBaseNodes - возвращает или изменяет состояние нод-счёта рейнджера:
	1 - корабль (обязательно рейнджер) - возвращает состояние нод счёта;
	2 (опционально) - какое состояние установить;


Запреты:
NoDropToShip - запрет кораблю дропать любые предметы при гибели:
	1 - корабль;
	2 (опционально) - запретить/разрешить дроп;
NoTargetToShip - проверяет, устанавливает и снимает запрет атаковать корабль:
	1 - корабль;
	2 (опционально):
	  0 - разрешить атаковать корабль;
	  1 - запретить атаковать корабль (включая нацеливание пушек);
	  2 - запретить ботам по своей инициативе нападать на этот корабль с целью ограбления;
NoTalkToShip - проверяет, устанавливает и снимает запрет разговаривать с кораблём:
	1 - корабль;
	2 (опционально) - запретить/разрешить переговоры;
NoScanToShip - проверяет, устанавливает и снимает запрет сканировать корабль:
	1 - корабль;
	2 (опционально) - запретить/разрешить сканировать корабль;
	  Примечание: Две вышеперечисленные функции могут ставить запрет на вызовы других кораблей (игрок не сможет самостоятельно вызывать/сканировать другие корабли) непосредственно для игрока. Для этого необходимо указать маркер 1 - установить запрет, или 2 - снять запрет, в качестве первого и единственного аргумента (пример: NoTalkToShip(1)). Соответственно, при вызове этих функций без аргумента, они вернут состояние конкретно данного запрета для игрока.
NoJump - проверяет, устанавливает и снимает запрет на совершение прыжков игроком:
	Без аргумента - проверяет наличие запрета;
	1 (опционально) - запретить/разрешить игроку совершать прыжки;
NoLanding - проверяет, устанавливает и снимает запрет совершать посадку на конкретное место игроком:
	1 - планета/станция (проверяет состояние запрета);
	2 (опционально) - запретить/разрешить игроку посадку на планету/станцию;
NoShopUpdate - проверяет, устанавливает и снимает запрет на автоматическое обновление магазина (одновременно оборудования и товаров) игрой:
	1 - магазин (планета или база);
	2 (опционально) - запретить/разрешить (1/0) автообновление ассортимента;
NoDropItem - проверяет, устанавливает и снимает запрет выбрасывать/перемещать предмет:
	1 - предмет;
	2 (опционально) - запретить/разрешить выбрасывать;
RuinsAllowModernization - проверяет или устанавливает разрешение у игрока на модернизацию базы:
	1 - база (проверяет наличие разрешения);
	2 (опционально) - разрешить/запретить игроку модернизацию базы;


Статистические данные:
DomikKilledInCurSystem - количество домиков, убитых в текущей системе (обнуляется при прыжке):
	1 - корабль;
ShipKillFactionInCurSystem - сколько кораблей уничтожено в текущей системе:
	1 - корабль;
	2 - тип кораблей (коалов/домиков/пиратов);
ShipStatistic - возвращает/изменяет указанные статистические данные корабля:
	1 - корабль;
	2 - тип статистики:
	  0 - убил всего;
	  1 - убил пиратов;
	  2 - убил доминаторов;
	  3 - освободил систем;
	  4 - убил мирных;
	  5 - убил военных;
	  6 - убил рейнджеров;
	  7 - убил врагов в ЧД;
	  8 - убил врагов в гипере (гиперпираты при перелётах между системами);
	  9 - текущее "торговое пенальти" игрока (накапливается при торговле в убыток и до тех пор, пока не будет полностью компенсировано прибылью, опыт и рейтинг за торговлю игроку начисляться не будет);
  Опционально:
	3 - новое значение выбранной статистики;
PlayerDominatorStatistic - возвращает/изменяет число доминаторов определённой серии, уничтоженных игроком:
	1 - серия доминаторов:
	  0 - блазероиды;
	  1 - келлероиды;
	  2 - терроноиды;
  Опционально:
	2 - новое число уничтоженных доминаторов указанной серии;
PlayerQuestsCompleted - возвращает число выполненных игроком заданий определённого типа;
	1 – тип задания:
	  0 – доставка грузов;
	  1 – убийства кораблей;
	  2 - текстовые квесты;
	  3 – защита систем;
	  4 – защита кораблей;
PlayerPlanetaryBattlesCompleted - без аргументов, возвращает число выполненных игроком планетарных боёв;
QuestsStatusByNom - принимает тип и номер правительственного задания (включая несюжетные ТК), и возвращает его статус:
	1 - тип квеста:
	  0 - SendLetter;
	  1 - KillShip;
	  2 - PlanetQuest;
	  3 - DefSystem;
	  4 - DefShip;
	2 - номер квеста (есть в Lang в разделе Quest);
	   Возвращаемые типы статусов:
	      0 - not taken;
		  1 - taken;
	  	  2 - completed;
		  3 - completed and got reward;
		  4 - failed;
GalaxyDominatorResearchPercent - возвращает процент исследования доминаторов НБ: 1 (опционально) – число, вернет процент исследования конкретной расы доминатора, 2 - установить новое значение;
GalaxyDominatorResearchMaterial - возвращает количество материалов для исследования доминаторов НБ: 1 (опционально) – число, вернёт количество материалов для исследования конкретной расы доминатора, 2 - установить новое значение;
GalaxyTechLevel - возвращает текущий ГТУ;
GalaxyDiffLevels - возвращает среднюю сложность игры, либо значение одной из конкретных настроек (от 50 до 500), без аргументов возвращает общую сложность, номера отдельных настроек:
  0 - пираты;
  1 - разброс цен;
  2 - учёные;
  3 - поломки;
  4 - оборудование;
  5 - задания;
  6 - чёрные дыры;
  7 - удача;


Стандартные операторы:
unknown - объявляет переменную неопределённого типа (нужна для последующего объявления/зачистки массивов или внешних функций);
  Примечание: Если приравнять значение unknown переменной любой другой (при помощи функции copy()), то вторая переменная также получит значение unknown. Это может быть полезно, если необходимо, например, зачистить массив без удаления его структуры (что особенно актуально для многомерных массивов) для последующей перезаписи его значениями другого типа.
int - объявляет переменную типа integer;
dword - объявляет переменную типа dword;
str - объявляет переменную типа string;
float - объявляет переменную типа double (название не соответствует фактическому типу в дабоязыке);
  Примечание: При объявлении переменных в скрипте, переменные, объявленные визуальным объектом, равны по валидности переменным, объявленным внутри кода, однако для улучшения читабельности и во избежание путаницы, все скриптовые переменные желательно объявлять как визуальные объекты. В прочих кодах (Act, Use и т.д.) объявлять переменные возможно только в коде, однако место их объявления не имеет никакого значение для определения переменной, поскольку компилятор запоминает все объявленные переменные в момент своего первого прохода по коду, благодаря чему конструкции вида: if(!var){int var=1;} - не приведут к крашу.
if - стандартный оператор условия;
else - стандартный оператор, исполняющий условие, если предыдущий if исполнен не был, всегда должен стоять после if и допускает конструкции вида:
  if(...)
  { ... }
  else if(...)
  { ... }
for - стандартный цикл перебора по определённому счётчику с условием: 1 - начальное значение числа (например, i=0); 2 - условие с числом (например, i<=3), 3 - операция с числом после каждого прохода цикла (например i=i+1);
  Примечание: Аргументы цикла for разделяются символом ';'.
while - стандартный цикл перебора до тех пор, пока исполняется указанное в нём условие: 1 - условие (например, i != 0);
exit - вызывается без скобок, прерывает дальнейшее исполнение кода в текущем операторе;
continue - вызывается без скобок, прерывает дальнейшее исполнение текущего круга цикла - переводит цикл на следующий круг;
break - вызывается без скобок, прерывает дальнейшее исполнение текущего цикла, завершает его;
function - объявляет функцию, которая будет доступна только внутри конкретного скрипта, пример: function MyFun(X,Y){ ... }
  Примечание: По умолчанию все переменные функции имеют тип unknown, однако при желании можно указать им определённый жесткий тип. Переменные функции существуют лишь внутри самой функции, однако внешние глобальные переменные и переменные скрипта функция может использовать без каких-либо ограничений.
result - обозначает возврат внутренней скриптовой функции и записывается внутри неё, пример: result=X+Y;
throw - выбрасывает эксепшен и вызывает краш игры, выносит в лог указанный текст: 1 - текст или число для вывода в лог (пример: throw 'No, no, no!';);
== - равно;
!= - неравно;
> - больше;
>= - больше или равно;
< - меньше;
<= - меньше или равно;
% - делит число на указанное значение и возвращает только остаток от такого деления, пример: 123 % 10 = 3;
& - побитовое сравнение И;
| - побитовое сравнение ИЛИ;
&& - логическое сравнение И;
|| - логическое сравнение ИЛИ;
<< - побитовый сдвиг на определённую позицию вперёд (запись 1<<N в данном случае будет эквивалентна 2^N (2 в степени N), а 4<<N эквивалентна 4*2^N);
>> - побитовый сдвиг на определённую позицию назад (запись 1>>N в данном случае будет эквивалентна 1/2^N с отбрасыванием дробной части);
\\ - комментирование строки;
\ - экранирование символа " ;
\\\ - экранирование символа ' ;

Служебные:
Rnd - возвращает псевдослучайное целое число из диапазона: 1 - нижняя граница, 2 - верхняя граница (могут быть отрицательными) (без включения тонкой настройки на полный рандом, данная функция использует заранее определённое галактическое зерно, что гарантирует идентичность бросков даже после перезагрузки игры);
rnd - возвращает псевдослучайное целое число, начиная с нуля: 1 - верхняя граница диапазона минус один (то есть rnd(5) будет возвращать результаты только от 0 до 4);
  Примечание: В отличие от Rnd(), rnd() всегда возвращает случайный результат, т.к. зерно определяется рандомно.
randomize - автоматически перемешивает зерно для rnd();
randseed - позволяет указать зерно или узнать текущее (тоже для rnd()), если вызывается без аргумента: 1 - новое зерно;
loadlibrary - загружает в память dll-библиотеку и записывает её адрес в переменную dword, которую потом можно использовать в функции libraryfunction: 1 - путь загрузки относительно папки с игрой (строкой);
  Пример: dword lib=loadlibrary('Mods\YourMod\YourLib.dll');
freelibrary - очищает память, занятую под dll-библиотеку, и возвращает int с результатом: 1 - dword с адресом dll-библиотеки;
libraryfunction - загружает из переменной с адресом dll-библиотеки в указанную переменную функцию, и устанавливает ей значение скрытого типа LibraryFun, поэтому присваивать функцию нужно всегда переменной с типом unknown:
	1 - dword с адресом dll, полученный через функцию loadlibrary;
	2 - тип возвращаемого загружаемой функцией значения строкой (доступны только int, dword, str и float), а если возврата нет, то без разницы;
	3 - название функции в dll, которую необходимо загрузить в переменную;
	4, 5, 6, и т.д. - типы аргументов загружаемой функции (также строкой) по порядку;
  Пример: unknown fun=libraryfunction(lib,'dword','FunctionName','str','dword','dword');
  В результате, объявленную переменную с функцией можно будет использовать в качестве обычной функции: fun(arguments);
  Примечание: Возврат значения из данных функций возможен только для переменных типа int, dword, str (получение str в C++ должна производиться типом wchar_t* с типом самой функции const wchar_t*, подробности в примере ниже) и float (получение и передача float в C++ должна производиться типом unsigned int, подробности в примере ниже). Передавать в качестве аргументов можно переменные любых типов.
    Пример функции в C++ для получения, изменения и возврата строки скрипту:
		//Для использования типа string
		#include <string>
		//Для конвертации wstring
		#include <locale>
		#include <codecvt>

		//Для записи всех необходимых функций внутрь самой библиотеки необходимо использовать следующую настройку:
		//Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded(/ MT) (для релиза)
		//Configuration Properties > C/C++ > Code Generation > Runtime Library > Multi - threaded Debug(/ MTd) (для дебага)
		//Подробнее: https://stackoverflow.com/questions/3162325/after-building-exe-using-vs-2010-c-missing-msvcp100-dll

		using namespace std;
		//Объявляем экспортируемость функции (актуально в VS 2019 для сборки dll на C++)
		extern "C" __declspec(dllexport)
		//Объявляем саму функцию и получаемый из скрипта аргумент в виде str
		const wchar_t* StringChange(wchar_t* script_str)
		{
			//Для дальнейшего успешного возврата строки в игру нам потребуется статичная переменная
			//Статичные переменные объявляются лишь раз, поэтому обязательно выносим объявлением на отдельную строку
			//Также для удобства статичную переменную можно объявить и вне конкретной функции, что актуально, если вы собираетесь писать сразу несколько разных экспортных функций с возвратом строки в игру
			static wstring wide_string;
			//Если нам необходимо преобразовать wchar_t*, полученный из игры, в string, то подойдёт следующий способ
			//Для удобства данный класс можно объявлять и вне функции в общем пространстве dll
			static wstring_convert<codecvt_utf8<wchar_t>> convert;
			//Применив его, на выходе получим простую string
			string basic_string = convert.to_bytes(script_str);
			//Производим необходимые действия с полученной строкой
			basic_string += "Some text";
			//Аналогичную операцию проводим для преобразования string в статичный wstring для последующего возврата значения в игру
			wide_string = convert.from_bytes(basic_string);
			//После чего возвращаем скрипту wstring в виде константы (также необходимое условие)
			return wide_string.c_str();
		}
    Пример функций в C++ для преобразования float ИЗ и В скриптовый формат:
		//Функция для преобразования переменной типа float из C++ в тип unsigned int, распознаваемый скриптом
		unsigned int FloatToGame(float a)
		{
			return *(unsigned int*)&a;
		}
		//Функция для преобразования переменной типа unsigned int, полученной как float из скрипта, в стандартный float, используемый в C++
		float FloatFromGame(unsigned int a)
		{
			return *(float*)&a;
		}
		  Примечание: Обратите внимание, переменная float в дабоязыке на самом деле double, однако передача значений в DLL доступна лишь в 32-битном формате, поэтому фактически обмен идёт в виде реальных типов float.
ImportAll - производит автоматическое объявление и загрузку в переменные всех функций из объявленной в Main dll-библиотеки: 1 - имя библиотеки строкой;
  Примечание: Данную функцию удобно использовать для подключения внешних функций конкретному интерфейсному, Act- или Use- коду. Все объявленные таким образом функции будут автоматически выгружены из памяти при перезагрузке или выходе из игры. Для сокращения обращений к данной функции (и сокращения лишних переобъявлений функций) при повторных срабатываниях кода допустимо использовать следующую конструкцию в начале нужного кода (объявление LibInit должно оставаться внутри условия):
	01=if(!LibInit)
	02 ^{
		01=int LibInit=1;
		02=ImportAll('LibName');
	}
ImportedFunction - производит упрощённое объявление новой функции из dll, при условии предварительного указания библиотеки и нужной функции из неё в Main.dat: 1 - название объявленной в Main библиотеки строкой, 2 - название конкретной функции строкой (пример: unknown PortionInDiapason=ImportedFunction('UtilityFunctions','PortionInDiapason'));
  Пример объявления dll с функциями в Main.dat:
	Data ^{
		ScriptLibs ^{
			UtilityFunctions ^{ //Название библиотеки для подстановки в ImportedFunction
				Path=Mods\Tweaks\UtilityFunctionsPack\DATA\UtilityFunctions.dll //Путь до файла dll
				RoundToMore=float,RoundToMore,float //Название и объявление функций из библиотеки (аналогично libraryfunction)
				PortionInDiapason=float,PortionInDiapason,float,float,float,float,float
				IsShiftCtrlPressed=int,IsShiftCtrlPressed
				DeclareBonusArray=void,DeclareBonusArray,int
			}
			ScriptName=UtilityFunctions,LibName2,LibName3 //И т.д., объявление библиотек и полного набора их функций для конкретного скрипта ScriptName, при этом при подобном объявлении никаких дополнительных операций в самом скрипте производить не нужно, все функции из объявленных в Main библиотек будут доступны в скрипте с самого начала его инициализации
		}
	}
	  Примечание: Первым в списке указателя функции идёт тип её возврата, однако если функция не подразумевает возврата вовсе (void), то вместо типа можно указать любое невалидное значение. Тот же void для этого вполне подойдёт.
new - создаёт и записывает в переменную новый экземпляр класса: 1 - название нового класса строкой (запоминать нужно в переменную с типом unknown, т.к. вернётся в неё тип class);
delete - удаляет экземпляр класса из переменной: 1 - переменная с типом class;
round - применить банковское (стандартное для игры) округление к дробному: 1 - число;
abs - возвращает модуль числа: 1 - число;
min - возвращает наименьшее число из представленных: 1 - первое число, 2 - второе число, 3 - третье число и т.д.;
max - возвращает наибольшее число из представленных: 1 - первое число, 2 - второе число, 3 - третье число и т.д.;
int - возвращает целое, отбрасывая дробную часть (аналогично округлению в меньшую сторону): 1 - число;
frac - возвращает дробную часть, отбрасывая целое: 1 - число;
sqr - возводит число в квадрат: 1 - число;
sqrt - извлекает из числа квадратный корень: 1 - число;
pi - не функция (!!!), а просто общая переменная, в которой записано число Пи;
sin - вычисляет синус: 1 - число;
cos - вычисляет косинус: 1 - число;
arctan - вычисляет и возвращает в радианах арктангенс числа: 1 - число;
exp - вычисляет экспоненту: 1 - число;
ln - вычисляет натуральный логарифм: 1 - число;
count - возвращает число символов в строке: 1 - строка;
trim - удаляет из строки пробелы, табуляции и переносы строк с правого и левого края: 1 - строка;
substr - выбирает определённые символы из строки: 1 - строка, 2 - номер отсчётного символа (начиная с 0), 3 (опционально) - сколько символов вернуть, начиная с отсчётного (пример - substr('wxyz',1,2) вернёт 'xy', а без указания третьего аргумента вернёт весь остаток строки 'xyz');
findsubstr - ищет в строке определённую строку и при успехе возвращает номер первого символа найденной строки: 1 - строка, 2 - какую строку ищем (пример - findsubstr('xyz','y') вернёт 1) - при неудаче возвращает -1;
lowercase - превращает все буквы в строке в строчные: 1 - строка;
uppercase - превращает все буквы в строке в заглавные: 1 - строка;
copy - копирует одну переменную в другую с сохранением типа: 1 - в какую переменную копировать, 2 - из какой переменной копировать (допустимо копировать переменную "из" и "в" ячейку массива, включая переменные типа unknown);
ord - возвращает числовой код символа: 1 - символ;
toansi - предположительно, переводит кодировку строки в ANSI: 1 - строка;
tounicode - предположительно, переводит кодировку строки в Unicode: 1 - строка;
Angle - возвращает угол между двумя объектами (корабли, астероиды, ракеты, планеты, звёзды и тд.): 1 - первый объект, 2 - второй объект;
Sound - воспроизводит указанный звук: 1 - строка пути к звуку в CacheData/Bm, пример: Sound('Sound.QuestOk') воспроизведёт звук выполненного задания;
CT (вероятно означает "Copy Text") - возвращает строковое значение указанного параметра из Lang.dat: 1 - строка вида 'путь к параметру в датнике', пример CT('Items.Engine.Type.8') вернёт слово 'Темпоральный';
Format - ищет в первом аргументе (строке) сочетание символов из второго аргумента и заменяет на третий, допускается использование множества замен в одной операцией:
	1 - исходная строка;
	2 - что заменить в исходной строке;
	3 - на что это заменить;
	4, 5 аналогично 2, 3 и т.д;
  Пример: Format('Траляля<0> - мне на всё плевать!','<0>','-ляля'); - вернёт строку: 'Траляля<clr>-ляля<clrEnd> - мне на всё плевать!';
GetMainData - функция аналогичная CT, позволяет получить значение параметра по адресу его элемента из Main.dat, пример: GetMainData('Data.SE.Planet.001.BG') - вернёт 312;
GetGameOptions - возвращает значение указанного параметра из игрового конфига (CFG.TXT): 1 - название параметра;
  Пример: 'ResolutionX' или 'ResolutionY' - вернёт разрешение экрана по X или Y (в виде int). Если запросить 'VideoMode', то вернет их же, но одной строкой через запятую (соответственно в виде str);
  Примечание: Функция берёт значения из уже загруженной в память копии конфига, поэтому изменение .txt файла при запущенной игре не даст видимого результата.
SFT - выводит в лог-файл любое значение (например SFT(ShipName(Player())) выведет в лог имя игрока), допускается множество аргументов, незаменимая функция для отладки;
BlockExist – ищет в Lang указанный раздел и при успехе возвращает 1: 1 – путь к разделу в Lang.dat;
ResourceExist – ищет в CacheData указанный ресурс (не путь до файла, а уже объявленный ресурс) и при успехе возвращает 1: 1 – путь к разделу в CacheData.dat, начиная с самого корня (то есть, например 'Bm.FormShip2.YourResourceName');
CreateActCodeEvent - вручную запускает заданный акткодовый эвент определённой инфошки или предмета:
  1 - тип эвента, например t_OnStep, t_OnTakingDamage и т.д.;
  2 - предмет или корабль, из акткода которого будет исполнено событие (для корабля событие сработает сразу во всех его инфошках, в которых оно есть);
  3 - корабль, т.е. то, что будет возвращать функция ScriptItemActShip() в обработчике;
  4 - то, что будет возвращать функция ScriptItemActObject1();
  5 - то, что будет возвращать функция ScriptItemActObject2();
  6 - параметр, т.е. ScriptItemActParam() (при желании, через ScriptItemActParam в самом акткоде события можно что-нибудь вернуть, возвращаемый параметр будет являться результатом вызова CreateActCodeEvent);
GenerateCodeStringFromBlock - создаёт из блока датника готовый код и записывает его в строку: 1 - путь к разделу с кодом (ActCode или UseCode) в Lang;
  Примечание: Готовую строку кода можно подставлять в скриптовые объекты функцией ItemOnActCode или ItemOnUseCode;
ExecuteCodeFromString - исполняет код из строки, позволяет передавать код между скриптами с помощью глобальных переменных или создать таким образом полноценную глобальную функцию:
	1 - строка с кодом;
  Опционально (для создания функции):
	2 - первый аргумент для исполняемой строки в виде строки (имя переменной-аргумента внутри создаваемой функции);
	3 - значение первого аргумента для исполняемой строки (можно подставить сюда любое значение или другую переменную);
	4 - второй аргумент для исполняемой строки в виде строки, либо (если не добавлять 5 аргумент) результат возврата вызова основной функции ExecuteCodeFromString, то есть, по сути, возврат функции из исполняемой строки (имя возвратной внутренней переменной указывать также строкой);
  Примечание: Аргументов для исполняемой строки можно задать сколько угодно, но при этом правило следующее: при нечётном числе аргументов функции ExecuteCodeFromString возврата не будет, а при чётном - последний аргумент всегда будет считаться её возвратом. Если последний возвратный аргумент объявлен как новая переменная, то его непосредственное объявление (присвоение типа int, str и т.д.) должно происходить в самой исполняемой строке. Если же для возврата указан один из ранее указанных аргументов, например: ExecuteCodeFromString('NewsAdd(X);','X',1,'X') - то дополнительно объявлять возвратную переменную не нужно.
  Наглядный пример использования: tempVar=ExecuteCodeFromString('varZ=varX+varY;int result=varZ;','varX',2,'varY',2,'varZ',0,'result'); - где tempVar в конечном итоге получит значение из временного аргумента varZ, то есть 4 (возвратная переменная result здесь так названа чисто для удобства, но на самом деле может иметь любое имя). Также в данном конкретном примере можно было обойтись и без объявления возвратной переменной, указав вместо неё напрямую 'varZ'.
  Ещё примечание: Для передачи кода между скриптами, вместо глобальных переменных можно использовать обычные переменные и функцию GetValueFromScript. Также, вместо использования переменных, общий код можно записывать прямиком в Lang, после чего извлекать его функцией CT и получать готовую исполняемую строку, которую, при желании, будет легко изменить даже без обращения к скрипту.
GetValueFromScript - позволяет узнать значение конкретной переменной (в т.ч. вернуть скриптовый предмет, но не группу, т.к. скриптовая группа - это номер) или элемента массива из конкретного скрипта (в случае отсутствия скрипта вернёт unknown). Работает в том числе и из акткода:
	1 - имя скрипта строкой (путь указывать не нужно);
	2 - имя переменной или массива строкой (не указывать глобалки, иначе крашнет, однако можно указывать общие игровые переменные типа t_Weapon1);
	3 - индекс массива, если вызывается массив;
	4, 5, 6 и далее - дополнительные индексы для многомерных массивов;
  Примечание: При запросе общих игровых переменных вроде t_Weapon1 (иногда бывает полезно) скрипт указывать не обязательно. Вместо него можно оставить пустую строку ''. Если же вы запрашиваете переменную из конкретного скрипта, то этот скрипт должен быть обязательно активен (в момент срабатывания иниткода скрипт уже считается активным).
StartVideo - проигрывает видеоролик: 1 - путь к видеофайлу, 2 - путь к дорожке звука в папке 'Sound' (пример: StartVideo('data\record.vdo','Record'));
GVideoStatus - общая глобальная переменная, используемая для показа видеороликов скриптом, возможные значения: 0 - ролик не воспроизводится, 1 - ролик заказан скриптом, 2 - ролик завершился;


Для работы с интерфейсом:
CurrentForm - возвращает текущую открытую форму строкой (все игровые формы прописаны в Main.dat, в разделе ML):
  Оригинальные формы:
	'StarMap' - форма общего экрана космоса;
	'Film' - форма просмотра повтора хода(ов) в космосе;
	'AB' - форма аркадных боёв и перелёта между системами, при включении соответствующей ТН;
	'Talk' - дочерняя форма диалога с кораблём/станцией в космосе;
	'Planet' - форма экрана обитаемых планет;
	'PlanetNO' - форма экрана необитаемых планет (вызываемое меню для размещения зондов находится здесь же);
	'PlanetQuest' - форма прохождения текстового квеста;
	'Gov' - форма планетарного правительства;
	'RuinsTalk' - правительство и общий экран станции (а также все мостики);
	'GoodsShop' - дочерняя форма магазина товаров;
	'EquipmentShop' - дочерняя форма магазина оборудования;
	'Info' - дочерняя форма инфоцентра;
	'Hangar' - дочерняя форма ангара;
	'Ship' - дочерняя форма, изменяемое игроком меню корабля (его собственный корабль, его транклюкатор, станция с проплаченным взносом на изменение);
	'Scaner' - дочерняя форма, не изменяемое игроком меню корабля (при сканировании других NPC);
	'Rewards' - дочерняя форма меню просмотра правительственных наград/медалей, открываемое через форму 'Ship';
	'Rating' - дочерняя форма рейтинга рейнджеров;
	'Galaxy' - дочерняя форма галакарты;
	'Journal' - дочерняя форма бортового журнала игрока;
	'SelectFace' - дочерняя форма выбора расы, лица и имени, вызываемая из 'RuinsTalk' при смене подданства на ПБ;
	'Quest' - неиспользуемая в игре (и, видимо, недоделанная) дочерняя форма со списком всех текущих заданий игрока;
	'Count' - дочерняя форма вызова интерфейсного элемента CountBox;
	'Number' - дочерняя форма вызова интерфейсного элемента NumberBox;
	Примечание: Элементы MessageBox, TextBox и ListBox конструируются кодом в момент вызова, и потому отдельных форм не имеют.
	'GameMenu' - дочерняя форма игрового меню, вызываемого по Esc;
	'MainForm' - главное (первое) меню игры;
	'SaveManager' - форма экрана сохранения/загрузки игры;
	'CfgSettings' - форма основных игровых настроек;
	'Achievements' - дочерняя форма просмотра игровых достижений;
	'LoadRobot' - дочерняя форма выбора планетарных боёв в главном меню;
	'LoadQuest' - дочерняя форма выбора текстовых квестов в главном меню;
	'LoadAB' - дочерняя форма выбора аркадных боёв в главном меню;
	'ModsManager' - дочерняя форма выбора подключённых модов в главном меню;
	'Score' - форма экрана результатов игры (очки и таблица рекордов);
	'GameSettings' - форма экрана настроек перед началом новой игры;
	'Introduction' - форма экрана загрузки новой игры с введением: "Добровольцы! Вы сделали правильный выбор...";
	'GameEnd' - форма экрана конца игры (когда игрок победил или проиграл/погиб);
	'GameLoad' - форма экрана загрузки игры из главного меню;
	'Jump' - форма экрана загрузки во время прыжков между системами (но не в ЧД);
	'Load' - форма экрана загрузки во всех остальных случаях;
	'About' - форма экрана игровых титров;
	'Style' - вспомогательная служебная форма, содержащая в себе различные элементы (вроде скролл-бара), из которой все прочие формы могут выдёргивать необходимые им куски (но это не точно);
  Кастомные формы:
	'AutoSearch' - форма настройки автопоиска из мода ExpAutoSearch;
FormChange - переход на другую форму: 1 - имя формы строкой;
RunChildForm - переход на другую форму, которая будет считаться дочерней по отношению к текущей и при закрытии вернётся на неё же. Используется для переходов на формы, которые изначально не имеют возможности открываться друг за другом (например, с Ship на Galaxy): 1 - форма строкой, 2 (опционально) - режим, в котором откроется форма Galaxy:
	0 - fgm_Teleport (телепортирует корабль в указанную систему после закрытия формы, есть базовая анимация);
	1 - fgm_Show (режим простого просмотра без возможности совершить прыжок);
	2 - fgm_Move (будет отдавать приказ на обычный прыжок между системами);
	3 - fgm_BlackHole (будет открывать ЧД, как на ТИ);
  По умолчанию дочерняя форма 'Galaxy' откроется в режиме fgm_Teleport;
UpdateFormShip - без аргумента, обновляет форму 'Ship'. Используется для быстрого обновления формы корабля после различных действий (например, после выброса предмета в космос);
FormCurShip - без аргумента, возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner' (помогает определить, что форма 'Ship' открыта для станции или транклюкатора, а не для корабля игрока);
UICheckElement - проверяет текущее состояние элемента (Panel, GraphButton, Image и т.д.):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя элемента;
	3 - тип проверки;
	  Возможные типы:
	    'IsActive' - возвращает состояние элемента, скрыт/виден;
	    'IsDisable' (только для кнопок) - вернёт 1, если кнопка видна, но заблокирована (аналогично кнопке связи, когда у корабля отсутствует радар);
		'IsDown' - проверка состояния кнопки, нажата ли она в текущий момент (полезно для проверки состояний кнопок-чекбоксов);
		'PosX' - текущая позиция элемента по оси X (учитывает скорректированное значение, если автокоррекция имела место быть);
		'PosY' - текущая позиция элемента по оси Y (учитывает скорректированное значение, если автокоррекция имела место быть);
	    'Text' (только для Label и Edit) - позволяет вернуть текущий текст элемента или задать текст для Edit четвёртым аргументом;
	    'Image' (только для Image, GI или GAI) - позволяет вернуть путь к изображению или выставить этот путь четвёртым аргументом;
	    'CurFrame' (только для GAI) - возвращает текущий активный кадр анимации;
	4 (опционально) - задаёт текст или путь к изображению для элемента, если 3-м аргументом выбран 'Text' или 'Image', либо меняет состояние нажатости кнопки, если выбран 'IsDown' (обработчик кнопки при этом запущен не будет);
  Примечание: В отличие от функций описанных ниже, способных работать только с установленными оверрайдами элемента, UICheckElement может возвращать информацию для любых игровых элементов вне зависимости от наличия на них скриптового оверрайда.
InterfaceState - добавляет элементу (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний и возвращает состояние оверрайда (скрыт/виден):
	1 - название формы строкой;
	2 - имя элемента строкой;
	3 (опционально) - установить оверрайд:
	  -1 - убрать оверрайд;
	   0 - скрыть элемент;
	   1 - показать элемент;
	   2 - заблокировать кнопку (Disable);
	   3 - разблокировать кнопку (Enable);
	Без 3-го аргумента вернёт текущее состояние оверрайда (-1, если оверрайда нет);
InterfaceText - возвращает текст элемента, если текст не изменяли модом, то вернёт пустую строку:
	1 - название формы строкой;
	2 - имя элемента (только для типов Label и Edit);
  Опционально:
	3 - новый текст;
InterfaceImage - возвращает/устанавливает картинку элемента, если изображение не изменялось модом, то вернёт пустую строку:
	1 - название формы строкой;
	2 - имя элемента (только для классов GI, GAI или Image);
  Опционально:
	3 - путь к новому изображению;
InterfacePos - возвращает/устанавливает новые координаты элемента:
	1 - название формы строкой;
	2 - имя элемента;
	3 - смещение по оси Х;
	4 - смещение по оси Y (под смещением подразумевается смещение относительно текущего местоположения элемента);
	5 - позиция элемента по оси Z;
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
InterfaceSize - устанавливает параметр Size элемента:
	1 - название формы строкой;
	2 - имя элемента;
	3 - размер по оси Х;
	4 - размер по оси Y;
ButtonClick - запускает кодовый обработчик клика указанной кнопки (не изменяет состояние нажатости кнопки, для этого нужно воспользоваться функцией UICheckElement):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя кнопки;
SetFocus - задаёт фокус указанному элементу (в частности элементу типа Edit):
	1 - название формы строкой (или '', если проверяется элемент на открытой кастомной форме);
	2 - имя элемента;
StarMapCenterView - центрирует камеру на определённой точке космоса (без звука):
	1 - координата Х;
	2 - координата Y;
  Опционально:
	3 - число циклов анимации сходящейся на целевой точке окружности (можно указать дофига, но проигрываться оно будет очень долго);
StarMapCurPosX - без аргументов, возвращает текущую координату X позиции камеры на форме 'StarMap' (в космосе);
StarMapCurPosY - без аргументов, возвращает текущую координату Y позиции камеры на форме 'StarMap' (в космосе);

Для работы с кастомными формами:
OpenCustomForm - открывает кастомную форму: путь к кастомной форме, начиная из папки "Main.ML" (если кастомная форма прописана сразу в разделе 'ML', то просто указать её имя);
CloseCustomForm - закрывает открытую кастомную форму:
   - Без аргументов, либо 1 - закрыть текущую открытую кастомную форму;
   - 0 или любой другой аргумент - отмена выхода с кастомной формы (отменить закрытие из блока CodeAfterRun невозможно, так что хз зачем оно нужно вообще);
   - 255 - закрыть родительскую форму (не знаю нафига нужно);
CustomInterfaceState - добавляет элементу на текущей открытой кастомной форме (Panel, GraphButton, Image и т.д.) скриптовый оверрайд состояний и возвращает состояние оверрайда (скрыт/виден):
	1 - имя элемента строкой;
	2 (опционально) - установить оверрайд:
	  -1 - убрать оверрайд;
	   0 - скрыть элемент;
	   1 - показать элемент;
	   2 - заблокировать кнопку (Disable);
	   3 - разблокировать кнопку (Enable);
	Без 3-го аргумента вернёт текущее состояние оверрайда (-1, если оверрайда нет);
CustomInterfaceText - возвращает текст элемента на текущей открытой кастомной форме, если текст не изменяли модом, то вернёт пустую строку:
	1 - имя элемента (только для типов Label и Edit);
  Опционально:
	2 - новый текст;
CustomInterfaceImage - возвращает/устанавливает картинку элемента на текущей открытой кастомной форме, если изображение не изменялось модом, то вернёт пустую строку:
	1 - имя элемента (только для классов GI, GAI или Image);
  Опционально:
	2 - путь к новому изображению;
CustomInterfacePos - возвращает/устанавливает новые координаты элемента на текущей открытой кастомной форме:
	1 - имя элемента;
	2 - смещение по оси Х;
	3 - смещение по оси Y;
CustomInterfacePosZ - возвращает/устанавливает позицию элемента на текущей открытой кастомной форме по оси Z (слой);
	1 - имя элемента;
	2 - позиция элемента по оси Z;
  Примечание: Слои в КР работают довольно дебильно, и верхним будет считаться слой с наименьшим значением. То есть, например, слой 1 будет расположен выше слоя 2 и т.д. Также для слоя возможно выставление отрицательных и дробных значений по тому же правилу, чем меньше - тем выше. Также обратите внимание, что если вы вызываете оверрайд позиции элемента на форме, на которой Галактики ещё не существует (например, на 'GameSettings'), то указанные параметры X, Y и Z будут задавать не смещение относительно текущих параметров, а фактическую позицию элемента относительно родительского элемента, как если бы вы изменяли его позицию напрямую через Main.
CustomInterfaceSize - устанавливает параметр Size элемента на текущей открытой кастомной форме:
	1 - имя элемента;
	2 - размер по оси Х;
	3 - размер по оси Y;
  Примечание: Проще всего запускать все необходимые функции для изменения размеров и позиций элементов кастомной формы в прикреплённом к ней блоке интерфейсного кода (просто размещаете его внутри кастомной формы) 'CodeBeforeRun'. Аналогично, перед уходом с кастомной формы внутри неё срабатывает обработчик 'CodeAfterRun'.


Для работы с массивами:
newarray - превращает в массив переменную типа unknown (также можно использовать сразу после функции free): 1 - начальное число элементов в новом массиве (пример: unknown array=newarray(7)), 2, 3 и далее (опционально) - сколько подэлементов будет в каждом из предыдущих элементов массива (для объявления многомерного массива);
  Примечание: Раньше данная функция часто использовалась в иниткоде скриптов, т.к. невозможно было объявить массив как-то иначе, но в последних версиях RScript эта необходимость отпала, т.к. появилась возможность объявлять массив напрямую в объекте переменной. При необходимости, этой функцией можно переобъявлять уже объявленные массивы через тернкод (массивы будут очищены автоматически).
free - очищает массив (в отличие от ArrayClear, затирает массив полностью, удаляя даже нулевой элемент): 1 - массив;
  Важно: В тип unknown данная функция массив не превращает, поэтому если обратиться к нему после чистки чем-либо кроме функций newarray или arraychange, то получится краш (в дабокоде массивы без элементов использоваться не могут). Также после чистки можно просто превратить пустой массив в unknown, посредством функции copy (нужно просто скопировать в него переменную с типом unknown). Попытка сохранить игру, пока в памяти имеется пустой массив, приведёт к ошибке.
arraychange - меняет размер массива (также можно использовать сразу после функции free): 1 - массив, 2 - какой размер установить;
ArrayAdd - добавляет новый (следующий по нумерации) элемент в массив и возвращает размер массива после добавления элемента (нельзя использовать после функции free до восстановления нулевого элемента): 1 - массив, 2 - добавляемое значение;
  Допустимо добавлять в конец в том числе элементы верхнего порядка из многомерных массивов, пример: ArrayAdd(array,array[1]) - где array[1] на самом деле содержит в себе подмассивы array[1,2,3];
ArrayDelete - удаляет элемент из массива, попутно сдвигая все остальные: 1 - массив, 2 - индекс элемента для удаления;
  Примечание: В том числе этой функцией допустимо удалять элементы в многомерных массивах. В этом случае для удаления элемента не из первого порядка необходимо строить запрос вот так: ArrayDelete(array[first,second],third). Однако, при удалении многомерного элемента, его подмассивы сами не зачищаются, что может привести к утечке памяти.
ArrayClear - очищает массив, удаляя все индексы кроме 0, которому присваивается пустое значение: 1 - массив;
ArrayDim - возвращает размер массива: 1 - массив;
ArraySort - сортирует массив, либо несколько массивов (сортировка идёт по значениям первого);
ArraySortPartial - частично сортирует массив или несколько массивов (не слишком актуально, но если есть ну очень большой массив, то его сортировку можно делать по частям, чтобы не провоцировать задержку хода, для чего сперва вызывается с первым аргументом 1, потом 2, и так далее до N, где N - количество элементов в массиве, начиная с нулевого);
ArrayRandomize - хаотично, но согласованно перетасовывает содержание архива или нескольких массивов: 1 - сколько раз перетасовать, 2 - первый массив, 3 - второй массив ... N-ый массив;
ArrayFind - ищет в массиве определённый элемент: 1 - массив, 2 - элемент;
ArrayFindInSorted - ищет элемент, предполагая, что массив уже отсортирован (работает быстрее чем ArrayFind, что полезно для больших массивов);


OnUseCode и OnActCode:
ScriptActionsRun - форсирует обработку запрошенных скриптовых действий, которые выполняются в другом потоке. Квесты, ПБ, взлеты и т.д. Все, что заказывается функциями, содержащими GScriptThread.MakeRun(); Предназначено для использования из OnUseCode (в остальных случаях обработка запустится и так);
ShowEffect - используется в OnUseCode и OnActCode, воспроизводит эффект:
	1 - строка пути к эффекту выстрела оружия в Main.dat\SE (чтобы эффекта не было, нужно выставить 'Weapon.NoGraph');
	2 - номер палитры эффекта для оружия, ShotVisual в Lang (вместе с 'Weapon.NoGraph' выставляйте на 1);
	3 - объект для воспроизведения анимации (корабль, база и т.д.);
  Опциональные:
	4 - диллер эффекта (кто якобы наносит выстрел по цели, может быть 0);
	5 - сколько урона нанести (выпрыгивающие цифры), реальный урон цели не наносится, это нужно делать функцией DealDamageToShip или прописывать через HullHP;
	6 - показать или нет анимацию взрыва. Если значение больше 0, то будет показан взрыв с плавным исчезанием "взорванного" корабля, цифры от 1 до 7 определяют, какая именно анимация взрыва будет показана;
	7 - воспроизвести или нет (0/1) звук выстрела (актуально для эффектов в Main.dat\SE\Weapon\***);
	8, 9, 10 - RGB цвета для показа урона (если выставить на 0,0,0, то урон показан не будет, а по умолчанию цвет цифры урона будет равен цвету расы корабля-цели);

ShowStaticEffect - проиграть gai-эффект: 1 - строка в SE.Effect, 2 - координата X, 3 - координата Y (ВАЖНО! Не воспроизводить эффект в отсутствие в системе игрока, т.к. это может привести к крашу с ошибкой деления на ноль!);
FilmSound - используется в OnUse и OnActcode, воспроизводит звук, позволяя указать его источник: 1 - строка пути к звуку (например 'Sound.Drop'), 2 - источник звука (объект) - также желательно проверять, находится ли игрок в момент воспроизведения на планете/станции/в системе, чтобы звук не проигрывался игроку в неподобающих местах;
CurItem - используется в OnUseCode и OnActCode, возвращает текущий предмет (предмет, на котором сработал данный код);
CurInfo - возвращает прямой указатель на текущую инфошку (только для акткода в инфошках);
ScriptItemActShip - используется в OnActCode, возвращает текущий корабль (корабль, на котором сработал данный акткод);
ScriptItemActObject1 - используется в OnActCode, возвращает первый объект действия (подробности ниже);
ScriptItemActObject2 - используется в OnActCode, возвращает второй объект действия (подробности ниже);
ScriptItemActParam - используется в OnActCode, возвращает и/или изменяет текущий параметр акткодового события (подробности ниже);
ScriptItemActionType - используется в OnActCode, возвращает тип текущего сработавшего акткодового события;
(!!!) В целях оптимизации старые виды записи проверок: if(ScriptItemActionType()==t_OnStep && ScriptItemActParam()==0)
необходимо заменять на более быстрые и новые вида: if(ScriptItemActionType(t_OnStep,0)) (!!!)
  Список всех возможных событий ScriptItemActionType:
	t_OnStep - выполняется 12 раз за ход, опрашивая все акткодовые предметы и инфошки в Галактике, начинает с 0 и заканчивает 11 шагом:
		ScriptItemActParam() - текущий шаг (число от 0 до 11);
		ScriptItemActObject1() - система, где лежит предмет (только если предмет с исполняемым акткодом находится в космосе);
	t_OnWeaponShot - выполняется для корабля и орудия в момент выстрела из неракетного оружия:
		ScriptItemActObject1() - цель выстрела;
		ScriptItemActObject2() - оружие, из которого стреляют;
		ScriptItemActParam() - если выстрел был сделан по кораблю, то возвращает (без аргумента) или меняет нанесённый цели урон (до применения к нему защиты цели);
		ScriptItemActParam() - если выстрел был сделан по ракете, то возвращает/ставит маркер (0 - попал, 1 - промазал);
		ScriptItemActParam() - если выстрел был сделан по предмету, то возвращает или устанавливает дополнительный урон от сплеша (как если бы стреляли по взрывной бочке);
	t_OnWeaponShot2	- выполняется для корабля непосредственно перед нанесением урона цели из неракетного оружия (перед t_OnDealingDamage):
		ScriptItemActObject1() - цель выстрела;
		ScriptItemActObject2() - оружие из которого выстрелили;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет;
	t_OnMissileShot - выполняется для корабля в момент выстрела из ракетного оружия:
		ScriptItemActObject1() - ракета;
		ScriptItemActObject2() - оружие, из которого выстрелили;
		  Примечание: В момент срабатывания данного события ракета уже считается потраченной из боекомплекта, так что, восполняя его на единицу, можно получить бесконечное ракетное оружие.
	t_OnMissileShot2 - выполняется для корабля непосредственно перед нанесением урона цели ракетой (перед t_OnDealingDamage):
		ScriptItemActObject1() - цель ракеты;
		ScriptItemActObject2() - ракета;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет;
	t_OnGettingWeaponHit - выполняется, когда по кораблю наносят урон оружием:
	t_OnGettingMissileHit - выполняется, когда по кораблю наносят урон ракетой:
		ScriptItemActShip() - атакуемый корабль;
		ScriptItemActObject1() - атакующий корабль/хозяин ракеты;
		ScriptItemActObject2() - оружие/ракета;
		ScriptItemActParam() - возвращает (без аргумента) или меняет дамагсет наносимого урона;
		  Примечание: Если атакующий корабль пользуется оружием со сплешом (или AOE типа Вертикса), то событие t_OnGettingWeaponHit сработает на всех кораблях, попавших в зону поражения, в том числе на дружественных и не получивших урон.
	t_OnDealingDamage - выполняется для корабля при нанесении урона другому кораблю или станции (до непосредственного применения урона к цели):
		ScriptItemActShip() - корабль/станция, наносящая урон;
		ScriptItemActObject1() - цель;
		ScriptItemActParam() - возвращает (без аргумента) или меняет нанесённый цели урон;
	t_OnTakingDamage - выполняется для корабля при получении любого урона неопределённого типа: от звезды, астероида, бомбы и т.д. (урон от орудий не учитывается):
	t_OnTakingDamageEn - выполняется для корабля при получении энергетического урона:
	t_OnTakingDamageSp - выполняется для корабля при получении осколочного урона:
	t_OnTakingDamageMi - выполняется для корабля при получении ракетного урона:
		ScriptItemActObject1() - источник урона (корабль/станция, ракета/торпеда, астероид, звезда, предмет или 0);
		ScriptItemActParam() - возвращает (без аргумента) или меняет полученный урон;
		  Примечание: При проверке на получение ракетного урона именно от ракеты (!), нужно дополнительно проверять ScriptItemActObject1() командой MissileOwner, чтобы вернуть атакующий корабль, который, однако, к тому моменту, может быть уже мёртв.
	t_OnScan - выполняется при сканировании корабля (срабатывает для игрока и сканируемого корабля, т.к. сами боты сканировать не умеют):
		ScriptItemActShip() - корабль игрока;
		ScriptItemActObject1() - сканируемый корабль;
	t_OnDroidRepair - выполняется для корабля при починке его дроидом:
		ScriptItemActParam() - возвращает/устанавливает количество отремонтированных HP;
	t_OnAnotherItem - выполняется, когда предметом с акткодом кликают по какому-то другому предмету:
	t_OnAnotherItem2 - выполняется, когда по предмету с акткодом кликают каким-то другим предметом:
		CurItem() - предмет с акткодом, для которого выполняется событие;
		ScriptItemActObject1() - другой предмет;
		ScriptItemActParam() - результат клика, аргументы (по умолчанию обработает как 0):
		  0 - предмет останется в руке (t_OnAnotherItem) / будет перемещён в трюм (t_OnAnotherItem2);
		  1 - предмет будет потрачен (удалён);
		  2 - предмет останется висеть в руке, даже если кликнули по другому предмету в трюме;
		  3 - предмет будет потрачен (удалён), а форма 'Ship' автоматически закроется;
	t_OnItemHit - выполняется когда по предмету чем-то попали (срабатывает только для предмета):
		ScriptItemActObject1() - оружие/ракета;
		ScriptItemActObject2() - где лежит предмет (система);
		ScriptItemActParam() - урон при взрыве, если предмет взрывоопасен;
	t_OnMissileHittingObject - выполняется когда ракета попала в предмет/астероид (срабатывает для хозяина ракеты):
		ScriptItemActObject1() - объект;
		ScriptItemActObject2() - ракета;
		ScriptItemActParam() - промах/попал;
	t_OnEnteringForm - выполняется при открытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
	t_OnLeavingForm - выполняется при закрытии формы, срабатывает для игрока и всех прочих кораблей, чья форма может быть открыта:
		CurrentForm() - возвращает текущую открытую форму (не акткодовый параметр, но очень удобно использовать вместе с событиями входа/выхода для определения нужной формы);
		  Примечание: Данные события при открытии формы 'Ship' срабатывают исключительно для игрока и не могут сработать для, например, транклюкатора игрока (или улучшаемой игроком станции), хотя фактически для него при просмотре эквипа также открывается форма 'Ship'.
	t_OnReEnteringForm - выполняется при автоматическом перезаходе на форму Ship (автообновление формы Ship после любого изменения формы, происходит почти на каждое действие игрока в меню корабля):
	t_OnShipBuysGoods - при покупке товара кораблём:
	t_OnShipSellsGoods - при продаже товара кораблём:
		ScriptItemActShip() - корабль, совершающий сделку;
		ScriptItemActObject1() - возвращает указатель на "информационный" предмет товара, из которого можно получить все основные данные о совершённой сделке:
		   - Тип купленного/проданного товара ItemType(ScriptItemActObject1());
			   Типы товаров:
			     t_Food (0) - продукты;
			     t_Medicine (1) - медикаменты;
			     t_Technics (2) - техника;
			     t_Luxury (3) - роскошь;
			     t_Minerals (4) - минералы;
			     t_Alcohol (5) - алкоголь;
			     t_Arms (6) - оружие;
			     t_Narcotics (7) - наркотики;
		   - Количество купленного/проданного товара ItemSize(ScriptItemActObject1());
		   - Общая стоимость купленного/проданного товара (сумма сделки) ItemCost(ScriptItemActObject1());
		ScriptItemActObject2() - имеет возврат только для события t_OnShipSellsGoods и также возвращает "информационный" предмет, но имеющий другие характеристики, из которых можно получить информацию о прибыльности совершённой продажи:
		   - Количество проданного товара с учётом того, сколько товара данного типа было реально закуплено кораблём на свои деньги. Прибыль/убыль с продажи краденного или найденного в космосе/гипере товара не будет учтена в формуле начисления опыта за торговлю/пенальти за торговлю себе в убыток:
			   * Если размер данного предмета окажется 0, значит, весь проданный товар является краденным/найденным и его продажа не будет засчитана в качестве торговой прибыли.
			   * Если размер предмета меньше, чем размер предмета из ScriptItemActObject1(), значит, кораблём была закуплена только часть проданного товара, а полученная с такой сделки прибыль/убыль должна быть пропорционально снижена для данного количества товара.
			   * Если же товар имеет размер равный размеру предмета из ScriptItemActObject1(), значит, весь товар был честно куплен кораблём и 100% от его стоимости будет учтено в качестве прибыли/убыли от продажи.
		   - Непосредственно прибыль/убыль от совершённой продажи:
			   * Если размер первого и второго предмета совпадают, то разница между их стоимостью и будет считаться чистой прибылью (если стоимость первого предмета выше стоимости второго) или убылью (если стоимость первого предмета ниже стоимости второго) от продажи.
			   * Если же размер второго предмета меньше, чем у первого (но не равен 0, т.к. в таком случае считать бессмысленно), то сперва необходимо будет получить фактическую стоимость продажи, которая реально участвует в учёте игрой прибыли/убыли. Сперва поделите стоимость первого предмета на его размер (определите стоимость единицы товара) и затем помножьте полученную стоимость единицы товара на размер второго предмета. Далее необходимо просто сравнить полученную "валидную" стоимость сделки с полной стоимостью второго предмета. Если полученное число выше стоимости второго предмета, значит при продаже была получена прибыль, а иначе на лицо явная убыль, которая будет зачислена игрой в "торговое пенальти".
			      Примечание: Торговое пенальти - общая сумма убыли, полученной игроком (другие корабли пенальти не получают) от торговли в убыток. До тех пор, пока пенальти не будет полностью компенсировано торговой прибылью (любая прибыль вычитается из накопленного пенальти), опыт и рейтинг за прибыльную торговлю начисляться не будут. Начисление и списание пенальти (равно как и начисление рейтинга и опыта) происходит уже после срабатывания описываемых акткодовых событий. Проверить и изменить текущую сумму пенальти можно с помощью функции ShipStatistic(Player(), 9).
		  Примечание: Менять характеристики "информационных" предметов, возвращаемых через ScriptItemActObject1() и ScriptItemActObject2() бессмысленно, т.к. на параметры совершённой сделки они не повлияют. Также попытка удаления или переноса "информационных" предметов в другое место приведёт к крашу.
		ScriptItemActParam() - возвращает/изменяет маркер о легальности совершённой сделки (0 - легальна, 1 - нелегальна);
	t_OnPlayerTalkedWithShip - когда игрок закончил разговор с кораблём, которого вызвал сам:
	t_OnShipTalkedWithPlayer - когда игрок закончил разговор с вызвавшим его кораблём:
		ScriptItemActShip() - корабль игрока (предположительно);
		ScriptItemActObject1() - корабль, с которым закончил говорить игрок;
	t_OnStartAB - срабатывает перед началом любой аркадной битвы, в которую вступает игрок:
		ScriptItemActShip() - всегда возвращает корабль игрока (бесполезный возврат);
		ScriptItemActObject1() - тоже корабль игрока, но уже исключительно АБ-шный. Возврат из этой функции можно использовать только для подстановки первым аргументом в ABShipModifiers, чтобы установить желаемые модификаторы игроку (удобно использовать в акткоде кастомных артефактов);
	  Примечание: Данное событие можно использовать исключительно для изменения аркадных модификаторов игрока (ABShipModifiers). Добавить/удалить корабли NPC в бой в этот момент уже нельзя.
	t_OnABItemDrop - срабатывает при получении игроком предмета из убитого в аркадном бою противника (перед добавлением предмета в трюм и перед выводом уведомления о полученных предметах):
		ScriptItemActShip() - корабль игрока;
		ScriptItemActObject1() - предмет, который будет добавлен в трюм к игроку (можно поменять ему цену, вес, акрин и т.д.);
	t_OnItemPickUp - выполняется когда предмет подняли захватом (срабатывает для поднявшего корабля и предмета):
		ScriptItemActShip() - поднявший корабль;
		ScriptItemActObject1() - поднятый предмет;
	t_OnDropItem - предмет выкинули из трюма и он движется (для детекта дропов из кораблей NPC):
	t_OnDropItemFixed - предмет выкинули из трюма и он неподвижен (для детекта дропов из корабля игрока):
		ScriptItemActShip() - дропнувший корабль (детектится даже после своего "уничтожения");
		ScriptItemActObject1() - дропнутый предмет;
	t_OnReduceEqBattle - срабатывает для предмета, когда происходит его износ в бою:
	t_OnReduceEqUse - срабатывает для предмета, когда происходит его износ от использования:
	t_OnReduceEqForce - срабатывает для предмета, когда происходит его износ от воздействия бертора:
	t_OnReduceEqForsage - срабатывает для двигателя, когда происходит его износ от форсажа:
		ScriptItemActShip() - корабль, на котором установлен предмет;
		ScriptItemActObject1() - предмет, который изнашивается;
		ScriptItemActParam() - количество вычитаемых у предмета очков износа, которое необходимо поделить на 1000, для получения точного процента "урона" (полностью исправный предмет имеет стойкость в 100 тысяч очков износа (100%), а полностью изношенный - 0);
	t_OnTrancPacking - срабатывает при сворачивании транклюкатора для корабля хозяина и транклюкатора:
		ScriptItemActObject1() - транклюкатор-артефакт (при необходимости, можно вернуть самого транка по функции ArtTranclucatorToShip);
		ScriptItemActObject2() - куда сворачивается транклюкатор (корабль, планета, станция);
	t_OnDeath - срабатывает для корабля перед его уничтожением:
		ScriptItemActShip() - погибающий корабль;
	t_OnPlayerChangeHull - срабатывает при смене игроком корпуса:
		ScriptItemActObject1() - новый корпус;
		ScriptItemActObject2() - старый корпус;
	t_OnPlayerUseMM - срабатывает, когда игрок устанавливает микромодуль в оборудование:
		ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция, с проплаченным взносом на изменение;
		ScriptItemActObject1() - оборудование, в которое вставляется ММ;
		ScriptItemActObject2() - микромодуль в виде предмета;
	t_OnPlayerSkillIncrease - срабатывает при повышении навыка игроком для себя самого, своего транклюкатора или станции;
		ScriptItemActShip() - корабль игрока, транклюкатор игрока, или станция с проплаченным взносом на изменение;
	t_OnItemEquip - выполняется, когда предмет в скриптовом объекте или артефакт надевается (не срабатывает для корабля);
	t_OnItemDeEquip - выполняется, когда предмет в скриптовом объекте или артефакт снимается (не срабатывает для корабля);
		CurItem() - предмет;
	  Эти два события - сраное дерьмо! Они не видят корабль, на который экипируется/с которого снимается предмет, и способны работать исключительно для предметов в скриптовых объектах, что делает их бесполезными в 99% случаев.
	t_OnNonStandartEqChange - срабатывает при смене любого оборудования на корабле нестандартным путём, а именно функцией ItemIsInUse (и только ей, т.к. различные функции типа Get и Drop событием не фиксируются) или при смене комплектаций;
		ScriptItemActShip() - корабль, на котором произошла смена оборудования;
	t_OnItemDestroy - выполняется перед уничтожением предмета (срабатывает только для уничтожаемого предмета);
		CurItem() - уничтожаемый предмет;
	t_OnShowingItemInfo - срабатывает перед отображением карточки предмета с данным событием;
		CurItem() - предмет, для которого отображается карточка;
		ScriptItemActShip() - если предмет на корабле или складе планеты/станции, то возвращает корабль, для которого в данный момент открыта форма 'Ship' или 'Scaner';
		ScriptItemActObject1() - возвращает звезду, если предмет находятся в открытом космосе и планету/станцию, если предмет закопан на необитаемой планете или продаётся в магазине обитаемой планеты/станции (если предмет на корабле или складе, то вернёт 0);
	t_OnCheckingUsability - выполняется, когда игрок курсором пикает предмет, по очереди возвращая все эквипнутые на корабле предметы. Если получает в ответ на текущий предмет 1, то подсвечивает слот этого предмета, как если бы игрок мог установить в него микромодуль;
		ScriptItemActObject1() - возвращаемый экипированный предмет;
		ScriptItemActParam(1) - отправляет маркер, что слот текущего экипированного предмета необходимо подсветить;
	Важно!!! В целях оптимизации акткода, после его написания необходимо создать специальные тэги-фильтры с указанием всех событий, задействованных в этом коде, пример:
      OnActCodeTypes=t_OnDeath,t_OnItemDestroy,t_OnStep - тэг для указания самих событий (t_OnStep здесь указывать не обязательно, если ниже вы указали второй тэг);
      OnActStepTypes=0,5,11 - конкретные этапы срабатывания события t_OnStep, в данном примере будут обработаны только этапы 0, 5 и 11 (если в вашем коде нет событий t_OnStep, либо они занимают полный диапазон шагов от 0 до 11, то указывать данный тэг не требуется);
	Данная оптимизация крайне важна, т.к. позволяет убрать из акткода все лишние и заведомо холостые проверки, тем самым значительно повышая скорость расчёта хода. Тэги необходимо ставить в разделе предмета, либо инфошки, наряду с прочими тэгами вроде Name, Text и т.д. Указать подобные тэги для акткода, который затем будет подставлен в скриптовый объект, невозможно, но т.к. подобных объектов во всей игре довольно мало, делать этого и не требуется.
	Примечание: Все события "для корабля" также срабатывают и для всех установленных и лежащих в его трюме предметов с поправкой на то, что для получения акткода оборудование должно быть сперва занесено в скрипт, артефакты обрабатывают акткод только будучи установленными в слот, а юзлесные предметы работают всегда, в том числе и из трюма (и, при желании, даже могут быть эквипнуты в несуществующий слот).


Функции, активирующие активные способности артефактов из оригинальной игры:
OnUseCodeTranclucator - функция, активирующая транклюкатора при использовании, возвращает транклюкатора;
OnUseCodeTransmitter - функция, без аргумента активирующая ТМ при использовании: 1 - трансмиттер, активирует указанный ТМ, 2 - маркер для отключения звука и сообщения об активации ТМ (если 0, то сообщения и звук отключены);
OnUseCodeBlackHole - функция, активирующая Субпортал при использовании, возвращает созданную ЧД;
OnUseCodeMissileDef - функция активации Ракетанга, уничтожение своих ракет;


Виды эффектов в дамагсете (присваиваются в параметре WeaponMods):
  'Energy' (1) - энергетический урон;
  'Splinter' (2) - осколочный урон;
  'Missile' (4) - ракетный урон;
  'Decelerate' (8) - снижает скорость цели, технически перегревает её двигатель (эффект Третона);
  'Destruct' (16) - разрушает оборудования цели;
  'Drain' (32) - восстанавливает по единице структуры за каждую единицу нанесённого урона (100% вампиризм);
  'Shock' (64) - вешает на цель эффект ионизации;
  'Acid' (128) - ослабляет броню цели;
  'Magnetic' (256) - вешает на цель ЭМ-помехи (которые снижают дальность радара, дальность орудий, мощность сканера и силу ГЗП цели);
  'DecelerateA' (512) - полный аналог простого замедления 'Decelerate' (эффект артефакта Вжик);
  'DecelerateAEx' (1024) - полный аналог простого замедления 'Decelerate' и 'DecelerateA' (доп. эффект артефакта Вжик в режиме совместимости);
Примечание: Замедления 'Decelerate', 'DecelerateA' и 'DecelerateAEx' полностью идентичны друг другу, однако при совместном использовании кратно увеличивают замедляющий эффект. К примеру, Вжик в режиме совместимости использует одновременно 'DecelerateA' и 'DecelerateAEx', что увеличивает его замедляющий эффект ровно в два раза.
  'Undefendable' (2048) - применяет к цели урон, считающийся отражённым Поляризатором (наносимый урон игнорирует броню и ГЗП);
  'NonLethal' (4096) - применяет эффект, как от непосредственного воздействия ионизации (наносит урон корпусу, но полностью уничтожить корабль не может)
  'ScanBonus' (8192) - добавляет +15% к урону, если мощность сканера превышает защиту цели;
  'BonusToDamaged' (16384) - повышает урон по повреждённой цели;
  'MoreDrop' (32768) - повышает шанс дропа оборудования при убийстве;
  'DropCargo' (65536) - повышает шанс дропа предметов из трюма при убийстве;
  'ReduceEngine' (131072) - имеет шанс повреждения двигателя цели;
  'BlockWeapon' (262144) - имеет шанс блокировки оружия цели;
  'BlockDroid' (524288) - имеет шанс блокировки дроида цели;
  'NoDelta' (1048576) - отключает разброс урона (оружие с данным эффектом всегда наносит максимальный урон);
Примечание: Для проверки наличия определённых эффектов в дамагсете конкретного орудия, необходимо сперва узнать его полный дамагсет (GetEquipmentStats(weapon,6)), а затем применить к нему одну из проверок следующего вида:
  if((damageset & 64)) - проверит, имеется ли в дамагсете эффект, вешающий на цель ионизацию (в случае наличия эффекта, выражение в скобках вернёт проверке 64);
  if(!(damageset & 64)) - проверит, что в данном дамагсете эффекта, вешающего на цель ионизацию, нет (вернёт 0);
  if((damageset & 64) || (damageset & 256)) - проверит, имеется ли в дамагсете эффект, вешающий ионизацию или эффект, вешающий ЭМ-помехи;
  if((damageset & (64+256)) == (64+256)) - проверит, имеются ли в дамагсете одновременно оба этих эффекта;
  if((damageset & 1+2+4+8+16+32+64+128+256)) - проверит, имеется ли в дамагсете хоть один из перечисленных в проверке эффектов (записывать проверочный сет в виде суммы не обязательно, но удобно для читабельности кода);


Галактические события (запоминаются игрой и могут быть просмотрены в конце хода):
GalaxyEvents - возвращает текущее количество галактических событий;
GalaxyEventDate - возвращает дату галактического события: 1 - номер события из списка;
GalaxyEventType - возвращает тип галактического события в виде строки: 1 - номер события из списка;
GalaxyEventData - возвращает числовые данные галактического события: 1 - номер события из списка (возвращает количество доступных типов данных для этого события), 2 (опционально) - номер типа данных (возвращает значение указанного типа данных события);
GalaxyEventsTextData - возвращает текстовые данные галактического события: 1 - номер события из списка (возвращает количество доступных типов строковых данных для этого события), 2 (опционально) - номер типа данных (возвращает значение указанного типа строковых данных события);

Типы галактических событий:
	'PlayerKillsShip' - игрок кого-то уничтожил:
	'PlayerAssistKillsShip' - игрок оказал помощь в уничтожении:
			Числовые данные: 0 - числовой тип уничтоженного корабля (ShipTypeN), 1 - Id системы, 2 - Id уничтоженного корабля, 3 - раса уничтоженного корабля, 4 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру), 5 - подтип уничтоженного корабля;
			Текстовые данные: 0 - имя уничтоженного корабля, 1 - полное имя уничтоженного корабля, 2 - строчный кастомный тип уничтоженного корабля (ShipType);
	'PlayerTranclucatorKillsShip' - транклюкатор игрока кого-то уничтожил:
	'PlayerTranclucatorAssistKillsShip' - транклюкатор игрока оказал помощь в уничтожении:
			Числовые данные: 0 - тип уничтоженного корабля номером (ShipTypeN), 1 - Id системы, 2 - Id уничтоженного корабля, 3 - раса уничтоженного корабля, 4 - Id транклюкатора игрока, 5 - раса транклюкатора игрока, 6 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру), 7 - подтип уничтоженного корабля;
			Текстовые данные: 0 - имя уничтоженного корабля, 1 - имя транклюкатора игрока, 2 - полное имя уничтоженного корабля, 3 - строчный кастомный тип уничтоженного корабля (ShipType);
	'PlayerCompanionKillsShip' - компаньон игрока кого-то уничтожил:
	'PlayerCompanionAssistKillsShip' - компаньон игрока оказал помощь в уничтожении:
			Числовые данные: 0 - тип уничтоженного корабля, 1 - Id системы, 2 - Id уничтоженного корабля, 3 - раса уничтоженного корабля, 4 - тип корабля компаньона, 5 - Id корабля компаньона, 6 - раса корабля компаньона, 7 - относительная крутизна уничтоженного корабля (100 соответствует среднему рейнджеру), 8 - подтип уничтоженного корабля;
			Текстовые данные: 0 - имя уничтоженного корабля, 1 - имя компаньона, 2 - строчный кастомный тип уничтоженного корабля (ShipType);
		Важно!!! Возврат строчного типа корабля для оригинальных типов кораблей ('Ranger', 'Warrior' и т.д.) всегда будет возвращать пустую строку.
	'LabeledShipKilledInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) был уничтожен:
			Текстовые данные: 0 - строковая метка корабля;
	'LabeledShipSurvivedInAB' - аркадный противник/союзник с особой текстовой меткой (которую можно выставить при его создании) выжил в бою:
			Числовые данные: 0 - оставшееся после боя здоровье в единицах HP, 1 - максимальный уровень здоровья (сколько было в начале боя) в единицах HP;
			Текстовые данные: 0 - строковая метка корабля;
	'PlayerAcceptsMoneyForTruce' - игрок согласился принять деньги за примирение с другим кораблём:
	'PlayerExtortsMoney' - игрок вытребовал деньги у другого корабля (имеется ввиду, вытребовал успешно):
	'PlayerExtortsGoods' - игрок вытребовал груз у другого корабля:
			Числовые данные: 0 - количество полученных денег или стоимость груза, 1 - тип другого корабля, 2 - Id системы, 3 - Id другого корабля, 4 - раса другого корабля;
			Текстовые данные: 0 - имя другого корабля;
	'PlayerDebtNullified' - кредитный долг игрока обнулился из-за уничтожения всех БЦ (срабатывает, если игрок имел долг):
			Числовые данные: 0 - обнулённый долг;
	'PlayerNodesNullified' - нод-счёт игрока обнулился из-за уничтожения всех ЦР (срабатывает, если на счету имелся хоть 1 нод):
			Числовые данные: 0 - обнулённые ноды;
	'PlayerUsesSubportal' - игрок активировал субпортал:
			Числовые данные: 0 - Id ЧД, 1 - дата открытия ЧД;
	'PlayerJumpsThroughSubportal' - игрок совершил прыжок через субпортал:
			Данные отсутствуют;
	'PlayerUsesBeacon' - игрок активировал трансфакторный маяк:
			Числовые данные: 0 - Id системы, в которой был активирован маяк;
	'PlayerChangesNationality' - игрок сменил расу:
			Числовые данные: 0 - новая раса;
	'PlayerChangesSide' - игрок сменил сторону конфликта:
			Числовые данные: 0 - на чью сторону перешёл игрок (0 - Коалиция, 1 - пиратский клан);
	'PlayerOrdersPirateRaid' - игрок заказал пиратский набег:
			Числовые данные: 0 - Id атакуемой системы;
	'PlayerDeath' - игрок погиб:
			Данные отсутствуют;
	'PlayerBuysEquipment' - игрок приобрёл предмет в магазине оборудования:
	'PlayerSellsEquipment' - игрок продал оборудование или юзлесный предмет:
			Числовые данные: 0 - тип предмета, 1 - цена предмета, 2 - вес предмета, 3 - Id предмета, 4 - тип магазина (0 - планета, 1 - база), 5 - Id магазина;
			Текстовые данные: 0 - название предмета;
	'PlayerBuysGoodsFromPlanet' - игрок приобрёл товары на планете:
	'PlayerSellsGoodsToPlanet' - игрок продал товары на планете:
			Числовые данные: 0 - тип товара, 1 - количество товара, 2 - общая стоимость товара, 3 - Id планеты;
	'PlayerBuysMissiles' - игрок зарядил ракетное орудие (купил заряды):
			Числовые данные: 0 - потраченные деньги, 1 - число купленных зарядов;
	'PlayerFinishesQuest' - игрок завершил текстовый квест (возможно, имеются ввиду вообще все задания, кроме ПБ):
			Числовые данные: 0 - тип квеста, 1 - номер квеста, 2 - полученные деньги, 3 - полученный опыт;
	'PlayerFinishesPlanetaryBattle' - игрок завершил планетарный бой:
			Числовые данные: 0 - номер ПБ, 1 - полученные деньги, 2 - полученный опыт;
	'PlayerReceivesMM' - игрок приобрёл микромодуль (видимо, только на ЦР):
			Числовые данные: 0 - Id микромодуля, 1 - тип микромодуля (уровень), 2 - цена микромодуля в нодах;
	'PlayerReceivesMMAsReward' - игрок получил микромодуль в качестве награды:
			Числовые данные: 0 - Id микромодуля, 1 - тип микромодуля;
	'PlayerReceivesMMOnNewYear' - игрок получил микромодуль в качестве новогоднего подарка:
			Числовые данные: 0 - Id микромодуля, 1 - тип микромодуля;
	'PlayerLiberatesSystem' - игрок освободил систему:
			Числовые данные: 0 - Id системы, 1 - новый владелец системы, 2 - бывший владелец системы, 3 - количество сбитых (игроком?) кораблей, 4 - Id планеты награждения;
	'RuinsCreated' - построена новая станция:
	'RuinsDestroyed' - станция уничтожена:
			Числовые данные: 0 - числовой тип станции, 1 - Id станции, 2 - Id системы;
			Текстовые данные: 0 - имя станции (не полное), 1 - строчный кастомный тип станции (ShipType);
		Важно!!! Возврат строчного типа станции для оригинальных станций всегда будет возвращать пустую строку.
	'PlayerEntersCheatCode' - игрок ввёл чит-код:
			Числовые данные: 0 - стоимость чита в очках;
			Текстовые данные: 0 - название чита;
	'SaveLoaded' - игрок загрузил сохранённую игру:
			Числовые данные: 0 - флаг загрузки дампа для загруженного сейва (да/нет);
			Текстовые данные: 0, 1, 2 и т.д. - перечисление всех подключённых в сейве модов в формате 'Expansion\ExpArts';
	'GlobalChangeToPlayerReputation' - произошло глобальное изменение репутации игрока (например, выплатил пособие семьям погибших рейнджеров):
			Числовые данные (как именно хардкод изменил репутацию в данном событии):
			   0 - тип произведённого изменения репутации (диапазон от 0 до 100):
			      0 - повысить репутацию до указанного значения;
			      1 - понизить репутацию до указанного значения;
			      2 - прибавить указанное значение к уже имеющемуся, но не выше 100;
			      3 - отнять указанное значение от уже имеющегося, но не ниже 0;
			      4 - отнять указанное значение от уже имеющегося, но не ниже 10 (то есть не доводить до враждебного уровня);
			   1 - само значение для изменения репутации;
			   2 - сет рас, для планет и кораблей которых было применено данное глобальное изменение репутации;
			Текстовые данные: отсутствуют;

Стейткод (то есть код, привязанный к любому стейту посредством if/Op):
ShipJoin - присоединяет корабль к скриптовой группе: 1 - номер или название группы без кавычек (каждый скрипт определяет свои группы по их внутреннему номеру), 2 - корабль, 3 (опционально) - флаг, который сигнализирует, что не нужно автоматически переводить корабль в первый привязанный к группе стейт (что подразумевает перевод куда-то вручную через ChangeState);
ShipOut - выводит корабль из его текущей скриптовой группы (любой NPC может быть одновременно записан лишь в одну скриптовую группу, так что указывать её не требуется): 1 - корабль (если указать игрока, то он будет выведен из своей текущей группы в данном конкретном скрипте);
AllShipOut - без аргументов, выводит все корабли из всех групп в текущем скрипте (по сути, является функцией для полного отключения скрипта);
ChangeState - сменить State корабля на другой, игнорируя обычную схему переходов: 1 - стэйт (название строкой в кавычках или номер), 2 (опционально) - корабль (по умолчанию стэйт будет изменён для корабля в текущем стэйте CurShip);
StateIs - сравнивает текущий стейт корабля с указанным(и): 1 - текущий стейт, 2, 3, 4 и т.д. - стейт(ы) для сравнения;
  Примечание: Обработка стейткода может происходить множество раз за ход и включается тогда, когда кораблю нужно использовать собственную логику для определения дальнейших действий. Также при работе со стейткодом внутренняя переменная CurShip всегда будет возвращать корабль, для которого в данный момент обрабатывается стейткод. То есть весь привязанный к стейтам код можно смело писать через CurShip вне зависимости от количества кораблей в группе, т.к. все они будут обрабатываться последовательно.
Hit - проверяет, атаковал/был ли атакован игрок скриптовым кораблём: 1 - скриптовый корабль (вернет 1, если игрок, его транк или партнёр нанесли урон этому кораблю), 2 (опционально) - если подставлена 1, то функция вернёт 1 только в случае, если по игроку (и только по нему) нанёс урон скриптовый корабль из первого аргумента;
  Примечание: После выставления маркера Hit на скриптовом корабле, сброшен он с него уже не будет, что делает эту функцию, по сути, одноразовой проверкой на случившуюся агрессию между конкретным скриптовым кораблём и игроком.
CurShip - переменная, в которую записан корабль, для которого в данный момент выполняется текущий стейткод;
EndState - переменная, которая приравнивается к 1, когда текущий стейт завершает своё основное дествие (например, корабль прибыл в точку назначения, указанную для него в стейте с типом Move);
GetData - получить числовые данные типа dword для скриптового (находящегося в группе) корабля:
	1 - номер данных (0-3);
  Опционально:
	2 - корабль (при вызове из стейткода корабль можно не указывать);
SetData - задать числовые данные типа dword для скриптового (находящегося в группе) корабля:
	1 - новое значение данных;
	2 - номер данных (0-3);
  Опционально:
	3 - корабль (при вызове из стейткода корабль можно не указывать);
  Примечание: Данные функции можно вызывать исключительно из скрипта в котором находится группа с проверяемым на данные кораблём.
ShipData - то же, что и GetData/SetData, но объединённое в одной функции и только для первой переменной/ячейки данных:
	Без аргументов - возвращает значение данных;
	1 - новое значение данных;
  Примечание: Данную функцию можно вызывать исключительно из стейткода.
ShipInCurScript - проверяет, участвует ли корабль в текущем скрипте:
	1 - корабль;
  Примечание: Функция ShipInCurScript является внутренней скриптовой проверкой и может быть вызвана только внутри какого-либо скрипта.
ShipInScript - делает проверку, записан ли корабль в какую-то (любую) скриптовую группу и/или имеет на себе включённый OrderLock:
	1 - корабль;
  Опционально:
	2 - если 0, то отключить проверку на OrderLock, оставив проверку только на скриптовую группу (по умолчанию проверка на OrderLock включена);
  Примечание: Функция ShipInScript является универсальной проверкой и может быть вызвана откуда угодно.

Интерфейс и кастомные инфошки:
CurInfo - без аргументов, возвращает прямой указатель на инфошку при вызове из её акткода;
ShipCustomShipInfosCount - возвращает общее количество кастомных инфошек на корабле:
	1 - корабль;
ShipAddCustomShipInfo - добавляет на корабль/станцию кастомную инфошку и возвращает её указатель аналогично функции CurInfo:
  Обязательные:
	1 - корабль;
	2 - строка с системным именем инфошки (из Lang);
  Опциональные:
	3 - строка с описанием инфошки (заменит собой описание из Lang) или маркером 'NoShow' (не будет отображаться в разделе состояний корабля), также можно оставить пустой '';
	4 - числовые данные инфошки №1;
	5 - числовые данные инфошки №2;
	6 - числовые данные инфошки №3;
	7 - текстовые данные инфошки №1;
	8 - текстовые данные инфошки №2;
	9 - текстовые данные инфошки №3;
ShipDeleteCustomShipInfo - удаляет одну указанную кастомную инфошку с корабля (одинаковых инфошек там может висеть и несколько):
	1 - корабль;
	2 - строка с системным именем или номер инфошки, либо прямой указатель CurInfo();
ShipFindCustomShipInfoByType - возвращает номер инфошки по её имени в списке инфошек корабля:
	1 - корабль;
	2 - системное имя инфошки;
ShipCustomShipInfoDescription - возвращает или устанавливает описание инфошки:
	1 - корабль;
	2 - номер или имя инфошки;
  Опционально:
	3 - строка, которая заменит собой текущее описание;
ShipCustomShipInfoData - возвращает или устанавливает числовые данные (тип int) для инфошки:
	1 - корабль;
	2 - номер или имя инфошки (или сама инфошка CurInfo() при вызове из акткода инфошки, в таком случае вместо корабля можно поставить 0);
	3 - номер данных (1, 2, 3);
  Опционально:
	4 - какое значение установить (при подстановке тэга вида <Data1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки данных);
ShipCustomShipInfoTextData - возвращает или устанавливает текстовые данные (тип str) для инфошки:
	1 - корабль;
	2 - номер или имя инфошки;
	3 - номер данных (1, 2, 3);
  Опционально:
	4 - какое значение установить (при подстановке тэга вида <TextData1> в описание этой инфошки, автоматически подставляет в то место значение соответствующей ячейки текстовых данных);
StarMapLabel - добавляет к названию системы на галакарте текстовую метку:
	1 - система;
	2 - метка (строка);
StarCustomStarInfosCount - возвращает общее количество инфошек системы:
	1 - система;
StarAddCustomStarInfo - добавляет кастомную инфошку для системы:
	1 - система;
	2 - имя инфошки;
	3 - текст который будет отображаться в левой части;
	4 - позиция инфошки;
	5 - центральное изображение;
	6 - текст в который будет отображаться в правой части;
StarDeleteCustomStarInfo - удаление кастомной инфошки для системы:
	1 - система;
	2 - текст левой части инфошки;
StarFindCustomStarInfoByType - для конкретной системы ищет номер инфошки нужного типа:
	1 - система;
	2 - имя инфошки;
StarCustomStarInfoData - возвращает/устанавливает нужное значение кастомной инфошки, в нужном поле:
	1 - система;
	2 - текст в левой части;
	3 - нужный параметр ('Name','Dist','Icon','Info');
  Опционально:
	4 - нужное значение;


Прочее:
HoleMamaCreate - осталось от КР1, чёрная дыра Махпеллы;
RobotSupport - поддерживаются планетарные битвы, на особо слабых машинах могут не работать;
StarListToPlanetList - вспомогательная функция для пиратской сюжетки, из списка систем строит список планет по критериям, которые я уже сам не помню (evilcoward);
StarListToTransitPlanetList - вспомогательная функция для пиратской сюжетки, составляет список планет находящихся где-то по дороге от одной системы к другой, с учетом модификаторов, которые я уже не помню (evilcoward);
EndGame - завершает партию: 1 (опционально) - тип концовки;
CustomWin - кастомная победа;
CustomLose - кастомный проигрыш: 1 - текст, выводимый на экране поражения;
PirateWin - без аргументов, возвращает или устанавливает тип завершения пиратской ветки:
	0 - Пираты воюют с Коалицией (стартовая ситуация);
	1 - Пираты проникли во власть;
	2 - Пираты вернулись к истокам;
	3 - Коалиция спасена от пиратов;
	4 - Пиратов преследуют неудачи;
	5 - Пираты поработили Коалицию;
ShipInPrison - проверяет начинает/заканчивает тюремную отсидку корабля: 1 - корабль, 2 (опционально) - посадить/выпустить;
ControlledSystems - возвращает количество контролируемых систем одной из сторон конфликта:
	1 - сторона конфликта:
	  0 - Коалиция;
	  1 - доминаторы;
	  2 - пираты;
CapitalShipStats - проверяет/устанавливает/отменяет мостик для корпуса: 1 - корпус (проверяет), 2 (опционально) - устанавливает корпусу мостик с определённым номером (для мостика ТИ восстанавливает запас энергии до 1000), 3 - (только для мостика ТИ) какой запас энергии установить;
PlayerBridge - возвращает номер мостика, на котором находится игрок или принудительно заходит/выходит с мостика, без агрументов возвращает номер мостика: 1 (опционально) - если значение >0, то зайти на соответствующий номеру мостик, иначе выйти, 2 - фон для мостика;
WeaponHit - конкретный корабль производит выстрел по конкретной цели (не отрисовывает никаких эффектов):
	1 - стреляющий корабль;
	2 - объект-цель (только корабль/станция или ракета);
	3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике, но должно существовать в виде предмета);
FireWeapon - полноценный выстрел, принимает любые цели, сам применяет и отрисовывает всё эффекты:
	1 - стреляющий корабль;
	2 - объект-цель (корабль/станция, астероид, предмет или ракета);
	3 - конкретное орудие, которое производит выстрел (может находиться где угодно в Галактике, но должно существовать в виде предмета);
  Примечание: Если выстрел производится по предмету (астероидам и ракетам всё же нужен указатель на орудие), то показатель урона конкретного орудия не будет иметь никакого значения. Таким образом, третий аргумент можно задать как 0 (что также отменит и анимацию выстрела), и не париться с поисками подходящей для выстрела пушки. Учтите, однако, что выстрел по предмету без указания пушки всё равно вызовет в этом предмете срабатывание события t_OnItemHit, однако в возврате функции ScriptItemActionType() в таком случае будет закономерно стоять 0.
DealDamageToShip - наносит урон кораблю. Не учитывается броня и ГЗП, но учитываются процентные модификаторы артефактов и оружейных модификаций, а также резисты корпуса:
	1 - цель (корабль/станция);
	2 - объект источник урона (может быть 0);
	3 - урон;
	4 - дамагсет;
  Опциональные:
	5 - радиус урона от сплеша;
	  Примечание: Имеется в виду, что сама функция наносит указанной цели сплешевый урон, а не раздаёт сплеш на все окружающие цели. Радиус здесь - это лишь расстояние до условной основной цели (которой урон нужно наносить отдельно). При этом если указана дружественная цель, то такой урон будет автоматически занулён (т.к. весь сплеш в игре именно так и работает). Не задавайте этот аргумент, либо установите его в -1, если подразумевается, что вы наносите урон по основной цели.
RuinsMicromoduleChain - возвращает какой микромодуль предлагает база (любая, не обязательно ЦР) исходя из текущего набора предметов в трюме игрока:
	1 - станция;
	2 - уровень микромодуля:
	  0 - ММ третьего уровня;
	  1 - ММ второго уровня;
	  2 - ММ первого уровня;
  Опционально:
	3 - номер ММ в цепочке;
	4 - если !=0, то возвращает альтернативную цепочку;


Функции для получения игровых достижений (тех же, что есть в Steam):
GetAchievementSHU - без аргументов, получить достижение "Клонобоец";
GetAchievementGIRLSHIRE - без аргументов, получить достижение "Если б я был султан...";
GetAchievementGIRLSQUEST - без аргументов, получить достижение "Подкаблучник";
GetAchievementPIRATEWIN - без аргументов, получить достижение "Рачехан и все-все-все";
GetAchievementCOALLITION - без аргументов, получить достижение "За коалицию!";
GetAchievementHULL - без аргументов, получить достижение "Мир и порядок!";

Типы товаров:
  t_Food (0) - продукты;
  t_Medicine (1) - медикаменты;
  t_Technics (2) - техника;
  t_Luxury (3) - роскошь;
  t_Minerals (4) - минералы;
  t_Alcohol (5) - алкоголь;
  t_Arms (6) - оружие;
  t_Narcotics (7) - наркотики;

Типы предметов:
  t_Artefact (8) кастомный артефакт
  t_Artefact2 (9) неломаемый кастомный артефакт (создаётся подстановкой в раздел Lang тэга NoWear=1)
  t_ArtefactHull (10) Железные жупи, минимальный размер 11
  t_ArtefactFuel (11) Чёрная жижа, минимальный размер 4
  t_ArtefactSpeed (12) Пси-ускоритель материи, минимальный размер 11
  t_ArtefactPower (13) Отморозки, минимальный размер 7
  t_ArtefactRadar (14) Пролонгер, минимальный размер 9
  t_ArtefactScaner (15) Сканерный кэш, минимальный размер 8
  t_ArtefactDroid (16) Дроид младший, минимальный размер 9
  t_ArtefactNano (17) Нанитоиды, минимальный размер 3
  t_ArtefactHook (18) Эриметр, минимальный размер 3
  t_ArtefactDef (19) Поляризатор, минимальный размер 11
  t_ArtefactAnalyzer (20) Вероятностный анализатор, минимальный размер 5
  t_ArtefactMiniExpl (21) Локализатор взрывной волны, минимальный размер 10
  t_ArtefactAntigrav (22) Антигравитатор, минимальный размер 18
  t_ArtefactTransmitter (23) Трансфакторный маяк, минимальный размер 3
  t_ArtefactBomb (24) Кварковая бомба, минимальный размер 5
  t_ArtefactTranclucator (25) Транклюкатор, минимальный размер 45
  t_ArtDefToEnergy (26) Пропорционар, минимальный размер 5
  t_ArtEnergyPulse (27) Пятерик, минимальный размер 8
  t_ArtEnergyDef (28) Проглот, минимальный размер 5
  t_ArtSplinter (29) Навинт, минимальный размер 9
  t_ArtDecelerate (30) Вжик, минимальный размер 5
  t_ArtMissileDef (31) Ракетанг, минимальный размер 6
  t_ArtForsage (32) Обливионный коннектор, минимальный размер 6
  t_ArtWeaponToSpeed (33) Сопланатор, минимальный размер 7
  t_ArtGiperJump (34) Гипергенератор, минимальный размер 5
  t_ArtBlackHole (35) Субпортал, минимальный размер 3
  t_ArtDefToArms1 (36) Протон, минимальный размер 8
  t_ArtDefToArms2 (37) Армс, минимальный размер 7
  t_ArtArtefactor (38) Артефактор, минимальный размер 3
  t_ArtBio (39) Биомир, минимальный размер 3
  t_ArtPDTurret (40) а'Эгис, минимальный размер 9
  t_ArtFastRacks (41) Ралс, минимальный размер ???
  t_Hull (42) корпус;
  t_FuelTanks (43) топливный бак;
  t_Engine (44) двигатель;
  t_Radar (45) радар;
  t_Scaner (46) сканер;
  t_RepairRobot (47) дроид;
  t_CargoHook (48) захват;
  t_DefGenerator (49) ГЗП;
Э  t_Weapon1 - Промышленный лазер (50), все расы;
О  t_Weapon2 - Осколочное орудие (51), все расы;
Э  t_Weapon3 - Лезка (52), все расы;
Р  t_Weapon4 - Ракетомет (53), все расы;
Э  t_Weapon5 - Третон (54), все расы;
Э  t_Weapon6 - Волновой фазер (55), все расы;
О  t_Weapon7 - Потоковый бластер (56), все расы;
Э  t_Weapon8 - Электронный резак (57), все расы;
О  t_Weapon9 - Мультирезонатор (58), все расы;
Э  t_Weapon10 - Атомный визион (59), все расы;
Э  t_Weapon11 - Дезинтегратор (60), все расы;
Э  t_Weapon12 - Турбогравир (61), все расы;
О  t_Weapon13 - ИМХО-9000 (62), только доминаторы;
Э  t_Weapon14 - Вертикс (63), только доминаторы;
Р  t_Weapon15 - Торпедный аппарат (64), только доминаторы;
О  t_Weapon16 - Эсодафер (65), только пиратский клан;
Э  t_Weapon17 - Кафаситор (66), только пиратский клан;
Р  t_Weapon18 - Лирекрон (67), только пиратский клан;
   t_CustomWeapon - кастомное оружие (68);
  t_Protoplasm - ноды (69);
  t_UselessItem - квестовый предмет (70);
  t_MicroModule - микромодуль (71);
  t_Cistern - цистерна (72) (в скриптовом коде может быть создана функцией CreateEquipment);
  t_Satellite - зонд (73);
  t_UselessCountableItem - кастомный сыпучий (74);

Типы предметов со старой нумерацией:
  t_Artefact (8) кастомный артефакт
  t_ArtefactHull (9) Железные жупи, минимальный размер 11
  t_ArtefactFuel (10) Чёрная жижа, минимальный размер 4
  t_ArtefactSpeed (11) Пси-ускоритель материи, минимальный размер 11
  t_ArtefactPower (12) Отморозки, минимальный размер 7
  t_ArtefactRadar (13) Пролонгер, минимальный размер 9
  t_ArtefactScaner (14) Сканерный кэш, минимальный размер 8
  t_ArtefactDroid (15) Дроид младший, минимальный размер 9
  t_ArtefactNano (16) Нанитоиды, минимальный размер 3
  t_ArtefactHook (17) Эриметр, минимальный размер 3
  t_ArtefactDef (18) Поляризатор, минимальный размер 11
  t_ArtefactAnalyzer (19) Вероятностный анализатор, минимальный размер 5
  t_ArtefactMiniExpl (20) Локализатор взрывной волны, минимальный размер 10
  t_ArtefactAntigrav (21) Антигравитатор, минимальный размер 18
  t_ArtefactTransmitter (22) Трансфакторный маяк, минимальный размер 3
  t_ArtefactBomb (23) Кварковая бомба, минимальный размер 5
  t_ArtefactTranclucator (24) Транклюкатор, минимальный размер 45
  t_ArtDefToEnergy (25) Пропорционар, минимальный размер 5
  t_ArtEnergyPulse (26) Пятерик, минимальный размер 8
  t_ArtEnergyDef (27) Проглот, минимальный размер 5
  t_ArtSplinter (28) Навинт, минимальный размер 9
  t_ArtDecelerate (29) Вжик, минимальный размер 5
  t_ArtMissileDef (30) Ракетанг, минимальный размер 6
  t_ArtForsage (31) Обливионный коннектор, минимальный размер 6
  t_ArtWeaponToSpeed (32) Сопланатор, минимальный размер 7
  t_ArtGiperJump (33) Гипергенератор, минимальный размер 5
  t_ArtBlackHole (34) Субпортал, минимальный размер 3
  t_ArtDefToArms1 (35) Протон, минимальный размер 8
  t_ArtDefToArms2 (36) Армс, минимальный размер 7
  t_ArtArtefactor (37) Артефактор, минимальный размер 3
  t_ArtBio (38) Биомир, минимальный размер 3
  t_ArtPDTurret (39) а'Эгис, минимальный размер 9
  t_ArtFastRacks (40) Ралс
  t_Hull (41) корпус
  t_FuelTanks (42) топливный бак
  t_Engine (43) двигатель
  t_Radar (44) радар
  t_Scaner (45) сканер
  t_RepairRobot (46) дроид
  t_CargoHook (47) захват
  t_DefGenerator (48) ГЗП
Э  t_Weapon1 - Промышленный лазер (49), все расы
О  t_Weapon2 - Осколочное орудие (50), все расы
Э  t_Weapon3 - Лезка (51), все расы
Р  t_Weapon4 - Ракетомет (52), все расы
Э  t_Weapon5 - Третон (53), все расы
Э  t_Weapon6 - Волновой фазер (54), все расы
О  t_Weapon7 - Потоковый бластер (55), все расы
Э  t_Weapon8 - Электронный резак (56), все расы
О  t_Weapon9 - Мультирезонатор (57), все расы
Э  t_Weapon10 - Атомный визион (58), все расы
Э  t_Weapon11 - Дезинтегратор (59), все расы
Э  t_Weapon12 - Турбогравир (60), все расы
О  t_Weapon13 - ИМХО-9000 (61), только доминаторы
Э  t_Weapon14 - Вертикс (62), только доминаторы
Р  t_Weapon15 - Торпедный аппарат (63), только доминаторы
О  t_Weapon16 - Эсодафер (64), только пиратский клан
Э  t_Weapon17 - Кафаситор (65), только пиратский клан
Р  t_Weapon18 - Лирекрон (66), только пиратский клан
   t_CustomWeapon - кастомное оружие (67)
  t_Protoplasm - ноды (68)
  t_UselessItem - квестовый предмет (69)
  t_MicroModule - микромодуль (70)
  t_Cistern - цистерна (71) (считается оборудованием и создаётся функцией CreateEquipment)
  t_Satellite - зонд (72)
  t_UselessCountableItem - кастомный сыпучий (73)

Бонусы для акринов и микромодулей (могут выступать и в качестве штрафов):
  bonHull (0) - бонус к броне корпуса;
  bonFuel (1) - бонус к объему топливного бака (работет только в качестве бонуса от ММ);
  bonSpeed (2) - бонус к скорости двигателя;
    Примечание: Все акриновые бонусы к скорости сперва плюсуются к текущей скорости двигателя, а расчёт фактической скорости корабля начинается позднее.
  bonJump (3) - бонус к дальности прыжка двигателя;
  bonRadar (4) - бонус к дальности радара;
  bonScan (5) - бонус к мощности сканера;
  bonDroid (6) - бонус к эффективности починки дроида;
  bonHook (7) - бонус к размеру захватываемых захватом объектов;
  bonDef (8) - бонус к мощности генератора защитного поля;
  bonWEnergy (9) - бонус к силе энергетического оружия;
  bonWSplinter (10) - бонус к силе осколочного оружия;
  bonWMissile (11) - бонус к силе ракетного оружия;
  bonWRadius (12) - бонус к дальности стрельбы оружия;
    Примечание: Данные оружейные (с приставкой W) бонусы, будучи записаны в оружейные акрины, применяются только на то орудие, в котором установлен соответствующий акрин. Все прочие бонусы на оружейных акринах работают по общим правилам.
  bonSlotRadar (13) - открыть/закрыть слот радара;
  bonSlotScaner (14) - открыть/закрыть слот сканера;
  bonSlotDroid (15) - открыть/закрыть слот дроида;
  bonSlotHook (16) - открыть/закрыть слот захвата;
  bonSlotDef (17) - открыть/закрыть слот генератора защитного поля;
  bonSlotWeapon (18) - открыть/закрыть слоты оружия;
  bonSlotArt (19) - открыть/закрыть слоты артефактов;
  bonSlotForsage (20) - открыть/закрыть слот форсажа;
  bonHookRadius (21) - бонус к дальности действия захвата;
  bonSkill1 (22) - изменяет навык точности;
  bonSkill2 (23) - изменяет навык манёвренности;
  bonSkill3 (24) - изменяет навык техники;
  bonSkill4 (25) - изменяет навык торговли;
  bonSkill5 (26) - изменяет навык обаяния;
  bonSkill6 (27) - изменяет навык лидерства;
  bonMass (28) - изменяет процент массы корабля и установленного оборудования (работает только в качестве бонуса от корпусного акрина, либо от ММ);
  bonExtraAkrinEff (29) - изменяет мощность акрина, при значении 100 эффект акрина увеличивается в 2 раза (работет только в качестве бонуса от ММ);
  bonExtraAkrinPenalty (30) - изменяет мощность отрицательного акринового бонуса, при этом положительное не изменяется (работет только в качестве бонуса от ММ);
  bonAmmo (31) - увеличение боезапаса ракетного оружия (применимо только для ракетного оружия);
  bonShots (32) - добавляет ракеты к выстрелу, применимо только для ракетного оружия с типом выстрела Rocket или Missile (бонус работает только из акрина на оружие или ММ);
  bonMissileSpeed (33) - увеличивает скорость выпускаемых ракет/торпед (применимо только для ракетного оружия);
  bonShotSpeed (34) - изменение очерёдности выстрела (применимо только для оружия);
  bonHookMaxSpeed (35) - прибавка к скорости притяжения захвата на дальней дистанции;
  bonHookMinSpeed (36) - прибавка к скорости притяжения захвата на ближней дистанции;
    Примечание: Скорость притяжения предмета минимальна на пределе дистанции захвата и максимальна в нулевой точке, то есть в координатном центре самого корабля. Чем ближе предмет лежит к кораблю - тем выше скорость захвата.
  bonStimCapacity (37) - изменяет максимальное количество принимаемых за раз стимуляторов (учтите, что на МЦ фактическое число стимуляторов для приема в установленном игрой и бонусами диапазоне определяется рандомом);
  bonZonds (38) - бонус к максимальному лимиту зондов под контролем игрока (при превышении лимита зонды начинают получать повышенный износ);
  bonAttacks (39) - дополнительное число выстрелов за ход в конкретном орудии (бонус работает только из акрина или ММ на оружие, либо в ShipSpecialBonuses);
    Примечание: При использовании бонуса bonAttacks в ShipSpecialBonuses, в каждое орудие будут добавлены не дополнительные выстрелы, но полная итерация его залпа за ход. К примеру, если орудие должно выстрелить 3 раза за ход, то с ShipSpecialBonuses +2 оно сделает 9 выстрелов, а с ShipSpecialBonuses -1 ни одного.

Список событий для интерфейсного кода:
OnPressCode - данный код срабатывает при левом щелчке мышью по объекту;
OnMouseRightClick - данный код срабатывает при правом щелчке мышью по объекту (не вызывает срабатывания анимации нажатия);
OnMouseEnterCode - данный код срабатывает при наведении курсора на объект;
OnMouseLeaveCode - данный код срабатывает при убирании курсора с объекта;

Дополнительная информация:
  Добавление кастомных правительственных наград:
	Все награды в КР размещены в разделе Reward в игровом Lang и могут быть, при желании, дополнены новыми. Для этого достаточно добавить новую награду на незанятый порядковый номер (перед этим убедившись, что его не используют другие моды) и увеличить общий счётчик Count в конце раздела с наградами. Максимальное число наград в игре ограничено и составляет 256 слотов (0-255), из которых оригинальная игра использует всего 48 (0-47). В моде ExpBlackMarket была добавлена скриптовая 49-я (номер 48 в Lang) награда, а в ShuRebellion 50-я (номер 49 в Lang).
	Если вам по какой-либо причине нужно добавить в список награду, которая не должна автоматически выдаваться в игре (например, вы хотите выдавать её скриптом), то необходимо "заблокировать" два параметра этой награды, а именно Race и Status, путём подстановки невалидного значения (пустое будет расценено игрой как "Any") в качестве которого отлично подойдёт, например "None". Параметр Type необходимо указывать корректно в любом случае, т.к. он игре необходим.
  Перебор расы при создании корпуса/оборудования/артефакта/предмета:
    Если нужно рандомно определить расу-производителя, но при этом вы хотите исключить из списка возможных рас, например, доминаторов, удобнее всего будет воспользоваться подобной командой: while(race==5)race=Rnd(0,7);
  Исключение Тортугаца и Нифигаца при переборе систем:
	Наиболее удобный способ (исключающий проверку по названиям систем), использовать проверку вида: if(StarToCon(star)==StarToCon(PlanetToStar(PlanetPirateClan())));
